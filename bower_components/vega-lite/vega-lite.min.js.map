{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","vega-lite.js","node_modules/colorbrewer/colorbrewer.js","node_modules/colorbrewer/index.js","node_modules/d3-color/build/color.js","node_modules/d3-format/build/format.js","node_modules/d3-time-format/build/timeFormat.js","node_modules/datalib/node_modules/d3-time/build/time.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/time.js","node_modules/datalib/src/util.js","src/Encoding.js","src/compiler/aggregate.js","src/compiler/axis.js","src/compiler/bin.js","src/compiler/compiler.js","src/compiler/facet.js","src/compiler/filter.js","src/compiler/group.js","src/compiler/layout.js","src/compiler/legend.js","src/compiler/marks.js","src/compiler/scale.js","src/compiler/sort.js","src/compiler/stack.js","src/compiler/style.js","src/compiler/subfacet.js","src/compiler/template.js","src/compiler/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js","src/vl"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,2,"colorbrewer","YlGn",3,4,5,6,7,8,9,"YlGnBu","GnBu","BuGn","PuBuGn","PuBu","BuPu","RdPu","PuRd","OrRd","YlOrRd","YlOrBr","Purples","Blues","Greens","Oranges","Reds","Greys","PuOr",10,11,"BrBG","PRGn","PiYG","RdBu","RdGy","RdYlBu","Spectral","RdYlGn","Accent","Dark2","Paired",12,"Pastel1","Pastel2","Set1","Set2","Set3","./colorbrewer.js","Map","prototype","set","k","v","get","has","factory","color","Color","Rgb","b","Math","max","min","round","format","isNaN","toString","rgbn","rgb","Hsl","h","hsl2rgb","m1","m2","Lab","xyz2rgb","x","pow","lab2xyz","t1","t2","t0","xyz2lab","t3","rgb2xyz","Hcl","c","Cubehelix","named","_prototype","darker","brighter","arguments","NaN","__prototype","hsl","range","reHex3","reHex6","reRgbInteger","reRgbPercent","reHslPercent","m","trim","toLowerCase","exec","parseInt","___prototype","Kn","Xn","Yn","Zn","y","z","deg2rad","PI","____prototype","lab","sin","cos","rad2deg","hcl","sqrt","atan2","gamma","A","B","C","D","E","ED","EB","BC_DA","cubehelix","bl","lgamma","cosh","sinh","interpolateCubehelixLong","ah","as","al","bh","bs","deltaHue","h0","delta","interpolateCubehelix","interpolateHclLong","ac","bc","interpolateHcl","interpolateLab","aa","ab","ba","bb","interpolateHslLong","interpolateHsl","interpolateRgb","ar","ag","br","bg","formatDecimal","p","toExponential","indexOf","coefficient","slice","exponent","abs","formatPrefixAuto","d","prefixExponent","floor","Array","join","formatRounded","formatDefault","toPrecision","out","i1","i0","FormatSpecifier","specifier","match","re","fill","align","sign","symbol","zero","width","comma","precision","type","formatTypes","formatSpecifier","identity","formatGroup","grouping","thousands","value","j","push","substring","reverse","localeFormat","locale","prefix","currency","test","suffix","formatType","maybeSuffix","valuePrefix","valueSuffix","valueNegative","prefixes","charCodeAt","decimal","group","Infinity","padding","formatPrefix","precisionRound","step","precisionPrefix","precisionFixed","%","toFixed","X","toUpperCase","clear","_","delete","Object","create",{"end":{"file":"?","comments_before":[],"nlb":false,"endpos":50706,"endcol":12,"endline":1300,"pos":50702,"col":8,"line":1300,"value":"size","type":"name"},"start":{"file":"?","comments_before":[],"nlb":false,"endpos":50706,"endcol":12,"endline":1300,"pos":50702,"col":8,"line":1300,"value":"size","type":"name"},"name":"size"},"size","forEach","apply","timeFormat","utcDate","date","Date","UTC","H","M","S","L","setUTCFullYear","localDate","setFullYear","newYear","parseLiteralPercent","string","percentRe","parseZone","Z","parseWeekdayNumber","numberRe","w","parseWeekNumberSunday","U","parseWeekNumberMonday","W","parseYear","parseMonthNumber","parseDayOfMonth","parseDayOfYear","parseHour24","parseMinutes","parseSeconds","parseMilliseconds","parseFullYear","formatLiteralPercent","formatUTCZone","pad","formatUTCFullYear","getUTCFullYear","formatUTCYear","newInterval","floori","offseti","count","interval","d0","d1","ceil","offset","start","stop","filter","setTime","end","utcWeekday","setUTCHours","setUTCDate","getUTCDate","getUTCDay","formatUTCWeekNumberMonday","utcMonday","utcYear","formatUTCWeekdayNumber","formatUTCWeekNumberSunday","utcSunday","formatUTCSeconds","getUTCSeconds","formatUTCMinutes","getUTCMinutes","formatUTCMonthNumber","getUTCMonth","formatUTCMilliseconds","getUTCMilliseconds","formatUTCDayOfYear","utcDay","formatUTCHour12","getUTCHours","formatUTCHour24","formatUTCDayOfMonth","formatZone","getTimezoneOffset","formatFullYear","getFullYear","formatYear","weekday","setHours","setDate","getDate","getDay","formatWeekNumberMonday","monday","year","formatWeekdayNumber","formatWeekNumberSunday","sunday","formatSeconds","getSeconds","formatMinutes","getMinutes","formatMonthNumber","getMonth","formatMilliseconds","getMilliseconds","formatDayOfYear","day","formatHour12","getHours","formatHour24","formatDayOfMonth","formatLookup","names","map","requote","replace","requoteRe","formatRe","RegExp","newFormat","formats","pads","charAt","newParse","newDate","parseSpecifier","parse","parses","parseShortWeekday","shortWeekdayRe","shortWeekdayLookup","parseWeekday","weekdayRe","weekdayLookup","parseShortMonth","shortMonthRe","shortMonthLookup","parseMonth","monthRe","monthLookup","parseLocaleDateTime","locale_dateTime","parseLocaleDate","locale_date","parseLocaleTime","locale_time","parsePeriod","periodLookup","formatShortWeekday","locale_shortWeekdays","formatWeekday","locale_weekdays","formatShortMonth","locale_shortMonths","formatMonth","locale_months","formatPeriod","locale_periods","formatUTCShortWeekday","formatUTCWeekday","formatUTCShortMonth","formatUTCMonth","formatUTCPeriod","dateTime","time","periods","days","shortDays","months","shortMonths","I","Y","utcFormats","utcFormat","formatIsoNative","toISOString","-","0","setUTCMonth","setMonth","isoSpecifier","formatIso","isoFormat","second","setMilliseconds","seconds","minute","setSeconds","minutes","hour","setMinutes","hours","sundays","mondays","tuesday","tuesdays","wednesday","wednesdays","thursday","thursdays","friday","fridays","saturday","saturdays","week","weeks","month","years","utcSecond","setUTCMilliseconds","utcSeconds","utcMinute","setUTCSeconds","utcMinutes","utcHour","setUTCMinutes","utcHours","utcDays","utcSundays","utcMondays","utcTuesday","utcTuesdays","utcWednesday","utcWednesdays","utcThursday","utcThursdays","utcFriday","utcFridays","utcSaturday","utcSaturdays","utcWeek","utcWeeks","utcMonth","utcMonths","utcYears","bins","opt","level","minstep","eps","maxb","maxbins","base","logb","log","div","span","steps","bisect","unit","index","lo","hi","mid","util","cmp","EPSILON","date_value","date_index","units","utc","dmin","dmax","minb","minbins","find","spec","raw","../time","../util","gen","repeat","val","zeros","random","uniform","undefined","samples","integer","normal","mean","stdev","next","rds","annotation","data","types","TYPES","values","$","isString","isValid","isDate","isNumber","isBoolean","typeAll","fields","keys","reduce","infer","TESTS","splice","inferAll","PARSERS","boolean","number","all","parsers","stats","unique","results","valid","missing","distinct","median","sort","quantile","quartile","q","sum","variance","isArray","M2","modeskew","avg","med","std","extent","dot","rank","mu","idx","comparator","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","mat","exp","isFunction","L2","R","entropy","counts","LN2","mutual","px","py","info","profile","sd","vals","q1","q3","summary","field","__summary__","./generate","./import/type","./util","tempDate","entry","STEPS","toUnitMap","d3_time","baseDate","utcBaseDate","d3-time",13,"util_escape_str","escape_str_re","strrep","str","truncateOnWord","len","rev","cnt","tok","split","truncate_word_re","buffer","FNAME","namedfunc","name","duplicate","obj","JSON","stringify","equal","extend","toMap","list","keystr","String","isObject","isBuffer","Buffer","array","shift","accessor","mutator","$func","op","$valid","$length","$in","$year","$month","$date","dates","$day","weekdays","$hour","$minute","$second","$utcYear","$utcMonth","$utcDate","$utcDay","$utcHour","$utcMinute","$utcSecond","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","pos","padchar","truncate","word","ellipsis","l1","l2","./time",14,"consts","vlfield","vlenc","schema","Encoding","theme","defaults","instantiate","specExtended","merge","_data","_marktype","marktype","_enc","encoding","_config","config","_filter","proto","fromShorthand","shorthand","delim","assign","enc","fromSpec","toShorthand","specFromShorthand","excludeConfig","toSpec","excludeData","subtract","is","encType","et","filterNull","fieldList","fieldName","Q","containsType","T","O","N","operands","operator","concat","fieldRef","_vega2","fieldTitle","isCount","displayName","aggregate","timeUnit","bin","scale","axis","bandSize","useSmallBand","ROW","COL","band","MAXBINS_DEFAULT","numberFormat","fieldStats","formatConfig","isTypes","toggleSort","support","qField","init","isType","isOrdinalScale","isDimension","isMeasure","isAggregate","alwaysNoOcclusion","isStack","cardinality","isRaw","hasValues","transpose","oldenc","row","col","direction","mode","toggleFilterNullO","nulls","./consts","./enc","./field","./globals","./schema/schema",15,"aggregates","dataTable","dims","meas","detail","facets","nofn","transform","groupby","details","aggregated","../globals",16,"setter","getter","props","defs","layout","def","isCol","isRow","properties","layer","orient","labels","rotate","ticks","titleOffset","grid","title","hideTicks","cellPadding","cellWidth","cellHeight","stroke","opacity","x2","mult","majorTicks","ax","maxLength","titleMaxLength","angle","baseline","dy","height","hasScale","maxLabelLength",17,"binning","output",18,"compiler","legend","marks","facet","stack","style","subfacet","template","compile","compileEncoding","rawTable","addFilters","aggResult","sorting","mark","mdefs","mdef","lineType","line","hasDetails","from","by","legends","scales","update","axes","filterLessThanZero","../Encoding","./aggregate","./axis","./bin","./facet","./filter","./group","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet","./template","datalib/src/stats",19,"faceting","axesGrp","enter","facetKeys","cellAxes","hasRow","hasCol","error","unshift","groupdef","trans",20,"BINARY",">",">=","=","!=","<","<=","filters","condition","op1","op2","console","warn",21,"_name",22,"vllayout","box","hasX","hasY","xCardinality","yCardinality","TEXT","colCardinality","rowCardinality","getMaxNumberLength","d3_format","getMaxLength","extraOffset","d3-format",23,"COLOR","SIZE","SHAPE","shape","text",24,"bar_props","xc","y2","yc","point_props","filled","strokeWidth","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","font","placeholder","family","fontWeight","weight","fontStyle","TABLE","prop","bar","supportedEncoding","requiredEncoding","area","tick","circle","square","point",25,"domain","fieldStat","getbins","numbins","STACKED","prefn","scaleUseRawDomain","useRawDomain","notCountOrSum","isOrdinalFn","RAW","getDataset","bandWidth","nice","outerPadding","points","colorScale","ordinalPalette","c10palette","c20palette","palette","ps","interpolate","interpolator","../schema/schema","d3-color",26,"addSortTransforms","datasetMapping","counter","byClause","dataName","transforms","source","../field",27,"stacking","dim","isXMeasure","isYMeasure","stacked","y1","y0",28,"estimateOpacity","numPoints","numMultiples",29,"subfaceting",30,"table","dataUrl","dataType","url",31,"timeFields","timeUnits","tf","fieldFn","func","d3_time_format","LONG_DATE","stat","yearstat","formula","expr","scaleLabel","labelLength","substr","isColor","d3-time-format",32,"encodingTypes","DETAIL",33,"vldata","*",34,"encTypes","countRetinal","fieldDef","arr","enctype",35,"shorthands","timefns","tu","./compiler/time",36,"INDEX",37,"enum","supportedEnums","supportedTypes","getSupportedRole","supportedRole","defaultTimeFn","scale_type","default","clone","minimum","description","typicalField","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","sortMixin","items","required","bandMixin","legendMixin","textMixin","role","margin","sizeMixin","colorMixin","maximum","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","additionalProperties","viewport","gridColor","gridOpacity","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellGridOpacity","cellBackgroundColor","textCellWidth","singleBarOffset","timeScaleLabelLength","dayScaleLabel","monthScaleLabel","characterWidth","maxSmallNumber","smallNumberFormat","largeNumberFormat","$schema","./schemautil",38,"dest","src","hasOwnProperty","constructor","schemautil","isEmpty","instance","changes","ins",39,"isin","item","thisArg","any","noaugment","msg","datalib/src/bins/bins","datalib/src/generate","datalib/src/util",40,"./Encoding","./compiler/compiler","./data"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n\n},{}],3:[function(require,module,exports){\nmodule.exports = require('./colorbrewer.js');\n\n},{\"./colorbrewer.js\":2}],4:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() {};\n  Map.prototype = {\n    set: function(k, v) { this[\"$\" + k] = v; return this; },\n    get: function(k) { return this[\"$\" + k]; },\n    has: function(k) { return \"$\" + k in this; }\n  };\n}\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function Color() {}\n\n  Color.prototype = {\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  var named = (new Map)\n      .set(\"aliceblue\", 0xf0f8ff)\n      .set(\"antiquewhite\", 0xfaebd7)\n      .set(\"aqua\", 0x00ffff)\n      .set(\"aquamarine\", 0x7fffd4)\n      .set(\"azure\", 0xf0ffff)\n      .set(\"beige\", 0xf5f5dc)\n      .set(\"bisque\", 0xffe4c4)\n      .set(\"black\", 0x000000)\n      .set(\"blanchedalmond\", 0xffebcd)\n      .set(\"blue\", 0x0000ff)\n      .set(\"blueviolet\", 0x8a2be2)\n      .set(\"brown\", 0xa52a2a)\n      .set(\"burlywood\", 0xdeb887)\n      .set(\"cadetblue\", 0x5f9ea0)\n      .set(\"chartreuse\", 0x7fff00)\n      .set(\"chocolate\", 0xd2691e)\n      .set(\"coral\", 0xff7f50)\n      .set(\"cornflowerblue\", 0x6495ed)\n      .set(\"cornsilk\", 0xfff8dc)\n      .set(\"crimson\", 0xdc143c)\n      .set(\"cyan\", 0x00ffff)\n      .set(\"darkblue\", 0x00008b)\n      .set(\"darkcyan\", 0x008b8b)\n      .set(\"darkgoldenrod\", 0xb8860b)\n      .set(\"darkgray\", 0xa9a9a9)\n      .set(\"darkgreen\", 0x006400)\n      .set(\"darkgrey\", 0xa9a9a9)\n      .set(\"darkkhaki\", 0xbdb76b)\n      .set(\"darkmagenta\", 0x8b008b)\n      .set(\"darkolivegreen\", 0x556b2f)\n      .set(\"darkorange\", 0xff8c00)\n      .set(\"darkorchid\", 0x9932cc)\n      .set(\"darkred\", 0x8b0000)\n      .set(\"darksalmon\", 0xe9967a)\n      .set(\"darkseagreen\", 0x8fbc8f)\n      .set(\"darkslateblue\", 0x483d8b)\n      .set(\"darkslategray\", 0x2f4f4f)\n      .set(\"darkslategrey\", 0x2f4f4f)\n      .set(\"darkturquoise\", 0x00ced1)\n      .set(\"darkviolet\", 0x9400d3)\n      .set(\"deeppink\", 0xff1493)\n      .set(\"deepskyblue\", 0x00bfff)\n      .set(\"dimgray\", 0x696969)\n      .set(\"dimgrey\", 0x696969)\n      .set(\"dodgerblue\", 0x1e90ff)\n      .set(\"firebrick\", 0xb22222)\n      .set(\"floralwhite\", 0xfffaf0)\n      .set(\"forestgreen\", 0x228b22)\n      .set(\"fuchsia\", 0xff00ff)\n      .set(\"gainsboro\", 0xdcdcdc)\n      .set(\"ghostwhite\", 0xf8f8ff)\n      .set(\"gold\", 0xffd700)\n      .set(\"goldenrod\", 0xdaa520)\n      .set(\"gray\", 0x808080)\n      .set(\"green\", 0x008000)\n      .set(\"greenyellow\", 0xadff2f)\n      .set(\"grey\", 0x808080)\n      .set(\"honeydew\", 0xf0fff0)\n      .set(\"hotpink\", 0xff69b4)\n      .set(\"indianred\", 0xcd5c5c)\n      .set(\"indigo\", 0x4b0082)\n      .set(\"ivory\", 0xfffff0)\n      .set(\"khaki\", 0xf0e68c)\n      .set(\"lavender\", 0xe6e6fa)\n      .set(\"lavenderblush\", 0xfff0f5)\n      .set(\"lawngreen\", 0x7cfc00)\n      .set(\"lemonchiffon\", 0xfffacd)\n      .set(\"lightblue\", 0xadd8e6)\n      .set(\"lightcoral\", 0xf08080)\n      .set(\"lightcyan\", 0xe0ffff)\n      .set(\"lightgoldenrodyellow\", 0xfafad2)\n      .set(\"lightgray\", 0xd3d3d3)\n      .set(\"lightgreen\", 0x90ee90)\n      .set(\"lightgrey\", 0xd3d3d3)\n      .set(\"lightpink\", 0xffb6c1)\n      .set(\"lightsalmon\", 0xffa07a)\n      .set(\"lightseagreen\", 0x20b2aa)\n      .set(\"lightskyblue\", 0x87cefa)\n      .set(\"lightslategray\", 0x778899)\n      .set(\"lightslategrey\", 0x778899)\n      .set(\"lightsteelblue\", 0xb0c4de)\n      .set(\"lightyellow\", 0xffffe0)\n      .set(\"lime\", 0x00ff00)\n      .set(\"limegreen\", 0x32cd32)\n      .set(\"linen\", 0xfaf0e6)\n      .set(\"magenta\", 0xff00ff)\n      .set(\"maroon\", 0x800000)\n      .set(\"mediumaquamarine\", 0x66cdaa)\n      .set(\"mediumblue\", 0x0000cd)\n      .set(\"mediumorchid\", 0xba55d3)\n      .set(\"mediumpurple\", 0x9370db)\n      .set(\"mediumseagreen\", 0x3cb371)\n      .set(\"mediumslateblue\", 0x7b68ee)\n      .set(\"mediumspringgreen\", 0x00fa9a)\n      .set(\"mediumturquoise\", 0x48d1cc)\n      .set(\"mediumvioletred\", 0xc71585)\n      .set(\"midnightblue\", 0x191970)\n      .set(\"mintcream\", 0xf5fffa)\n      .set(\"mistyrose\", 0xffe4e1)\n      .set(\"moccasin\", 0xffe4b5)\n      .set(\"navajowhite\", 0xffdead)\n      .set(\"navy\", 0x000080)\n      .set(\"oldlace\", 0xfdf5e6)\n      .set(\"olive\", 0x808000)\n      .set(\"olivedrab\", 0x6b8e23)\n      .set(\"orange\", 0xffa500)\n      .set(\"orangered\", 0xff4500)\n      .set(\"orchid\", 0xda70d6)\n      .set(\"palegoldenrod\", 0xeee8aa)\n      .set(\"palegreen\", 0x98fb98)\n      .set(\"paleturquoise\", 0xafeeee)\n      .set(\"palevioletred\", 0xdb7093)\n      .set(\"papayawhip\", 0xffefd5)\n      .set(\"peachpuff\", 0xffdab9)\n      .set(\"peru\", 0xcd853f)\n      .set(\"pink\", 0xffc0cb)\n      .set(\"plum\", 0xdda0dd)\n      .set(\"powderblue\", 0xb0e0e6)\n      .set(\"purple\", 0x800080)\n      .set(\"rebeccapurple\", 0x663399)\n      .set(\"red\", 0xff0000)\n      .set(\"rosybrown\", 0xbc8f8f)\n      .set(\"royalblue\", 0x4169e1)\n      .set(\"saddlebrown\", 0x8b4513)\n      .set(\"salmon\", 0xfa8072)\n      .set(\"sandybrown\", 0xf4a460)\n      .set(\"seagreen\", 0x2e8b57)\n      .set(\"seashell\", 0xfff5ee)\n      .set(\"sienna\", 0xa0522d)\n      .set(\"silver\", 0xc0c0c0)\n      .set(\"skyblue\", 0x87ceeb)\n      .set(\"slateblue\", 0x6a5acd)\n      .set(\"slategray\", 0x708090)\n      .set(\"slategrey\", 0x708090)\n      .set(\"snow\", 0xfffafa)\n      .set(\"springgreen\", 0x00ff7f)\n      .set(\"steelblue\", 0x4682b4)\n      .set(\"tan\", 0xd2b48c)\n      .set(\"teal\", 0x008080)\n      .set(\"thistle\", 0xd8bfd8)\n      .set(\"tomato\", 0xff6347)\n      .set(\"turquoise\", 0x40e0d0)\n      .set(\"violet\", 0xee82ee)\n      .set(\"wheat\", 0xf5deb3)\n      .set(\"white\", 0xffffff)\n      .set(\"whitesmoke\", 0xf5f5f5)\n      .set(\"yellow\", 0xffff00)\n      .set(\"yellowgreen\", 0x9acd32);\n\n  function Rgb(r, g, b) {\n    this.r = Math.max(0, Math.min(255, Math.round(r)));\n    this.g = Math.max(0, Math.min(255, Math.round(g)));\n    this.b = Math.max(0, Math.min(255, Math.round(b)));\n  }\n\n  var _prototype = Rgb.prototype = new Color;\n\n  var darker = .7;\n\n  _prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  var brighter = 1 / darker;\n\n  _prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.rgb = function() {\n    return this;\n  };\n\n  function format(r, g, b) {\n    if (isNaN(r)) r = 0;\n    if (isNaN(g)) g = 0;\n    if (isNaN(b)) b = 0;\n    return \"#\"\n        + (r < 16 ? \"0\" + r.toString(16) : r.toString(16))\n        + (g < 16 ? \"0\" + g.toString(16) : g.toString(16))\n        + (b < 16 ? \"0\" + b.toString(16) : b.toString(16));\n  }\n\n  _prototype.toString = function() {\n    return format(this.r, this.g, this.b);\n  };\n\n  var rgb = function(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }\n\n  function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = Math.max(0, Math.min(1, +s));\n    this.l = Math.max(0, Math.min(1, +l));\n  }\n\n  var __prototype = Hsl.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };/* From FvD 13.37, CSS Color Module Level 3 */\n\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  __prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l <= .5 ? l * (1 + s) : l + s - l * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  var hsl = function(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }\n\n  var reHex3 = /^#([0-9a-f]{3})$/,\n      reHex6 = /^#([0-9a-f]{6})$/,\n      reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/,\n      reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/,\n      reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\n  var color = function(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.has(format) ? rgbn(named.get(format))\n        : null;\n  }// Done lazily to avoid circular dependency between Color, Rgb and Hsl.\n\n  color.prototype = Color.prototype;\n  rgb.prototype = Rgb.prototype;\n  hsl.prototype = Hsl.prototype;\n\n  function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }\n\n  var ___prototype = Lab.prototype = new Color;\n\n  var Kn = 18;\n\n  ___prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  var Xn = 0.950470, // D65 standard referent\n      Yn = 1,\n      Zn = 1.088830,\n      t0 = 4 / 29,\n      t1 = 6 / 29,\n      t2 = 3 * t1 * t1,\n      t3 = t1 * t1 * t1;\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  ___prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n\n  function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }\n\n  var ____prototype = Hcl.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var lab = function(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }\n  lab.prototype = Lab.prototype;\n  var rad2deg = 180 / Math.PI;\n\n  var hcl = function(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }\n  hcl.prototype = Hcl.prototype;\n\n  function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  var gamma = 1, // Default gamma. TODO Customize.\n      A = -0.14861,\n      B = +1.78277,\n      C = -0.29227,\n      D = -0.90649,\n      E = +1.97294,\n      ED = E * D,\n      EB = E * B,\n      BC_DA = B * C - D * A;\n\n  var cubehelix = function(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D, lgamma = Math.pow(l, gamma);\n        s = Math.sqrt(k * k + bl * bl) / (E * lgamma * (1 - lgamma)); // NaN if lgamma=0 or lgamma=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = Math.pow(this.l, gamma),\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n  cubehelix.prototype = Cubehelix.prototype;\n\n  var interpolateCubehelixLong = function(a, b) {\n    a = cubehelix(a);\n    b = cubehelix(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n  var deltaHue = function(h, h0) {\n    var delta = (h - h0) % 360;\n    return delta + (delta > 180 ? -360 : delta < -180 ? 360 : 0);\n  }\n\n  var interpolateCubehelix = function(a, b) {\n    a = cubehelix(a);\n    b = cubehelix(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHclLong = function(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHcl = function(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateLab = function(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHslLong = function(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHsl = function(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateRgb = function(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelix = interpolateCubehelix;\n  exports.interpolateCubehelixLong = interpolateCubehelixLong;\n\n}));\n},{}],5:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function identity(x) {\n    return x;\n  }\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  function localeFormat(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer “value” part that can be\n          // grouped, and fractional or exponential “suffix” part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  var locale = localeFormat({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  exports.format = locale.format;\n  exports.formatPrefix = locale.formatPrefix;\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  exports.formatSpecifier = formatSpecifier;\n  exports.localeFormat = localeFormat;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));\n},{}],6:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  var percentRe = /^%/;\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  var numberRe = /^\\s*\\d+/;\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, offset) {\n    date.setUTCFullYear(date.getUTCFullYear() + offset);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setUTCDate(date.getUTCDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcMonday = utcWeekday(1);\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  var utcSunday = utcWeekday(0);\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setUTCDate(date.getUTCDate() + offset);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setDate(date.getDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var monday = weekday(1);\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  var sunday = weekday(0);\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function localeFormat(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var locale = localeFormat({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  exports.format = locale.format;\n  exports.utcFormat = locale.utcFormat;\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : locale.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  exports.isoFormat = isoFormat;\n  exports.localeFormat = localeFormat;\n\n}));\n},{}],7:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));\n},{}],8:[function(require,module,exports){\nvar util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time\":12,\"../util\":13}],9:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],10:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":13}],11:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":9,\"./import/type\":10,\"./util\":13}],12:[function(require,module,exports){\nvar d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n},{\"d3-time\":7}],13:[function(require,module,exports){\nvar buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{\"./time\":12,\"buffer\":1}],14:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return name ? this._data[name] : this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./consts\":32,\"./enc\":34,\"./field\":35,\"./globals\":36,\"./schema/schema\":37,\"./util\":39}],15:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|'+ field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!dataTable.transform) dataTable.transform = [];\n    dataTable.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n\n},{\"../globals\":36,\"../util\":39}],16:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name===COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name===X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n\n},{\"../globals\":36,\"../util\":39,\"./time\":31}],17:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  if (!dataTable.transform) dataTable.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      dataTable.transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n\n  return dataTable;\n}\n\n},{\"../globals\":36}],18:[function(require,module,exports){\n'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  filter = compiler.filter = require('./filter'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.aggregate = require('./aggregate');\ncompiler.bin = require('./bin');\ncompiler.facet = require('./facet');\ncompiler.group = require('./group');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.template = require('./template');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compiler.layout(encoding, stats),\n    spec = compiler.template(encoding, layout, stats);\n\n  // .data related stuff\n  var rawTable = spec.data[0],\n    dataTable = spec.data[1];\n\n  rawTable = filter.addFilters(rawTable, encoding); // modify rawTable\n  spec = compiler.time(spec, encoding);              // modify rawTable, add scales\n  dataTable = compiler.bin(dataTable, encoding);     // modify dataTable\n  var aggResult = compiler.aggregate(dataTable, encoding); // modify dataTable\n  var sorting = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style, stats),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compiler.stack(spec.data, encoding, mdef, aggResult.facets); // modify spec.data, mdef.{from,properties}\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, stats, style, sorting, {stack: stack});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(dataTable, encoding);\n\n  return spec;\n};\n\n\n},{\"../Encoding\":14,\"../globals\":36,\"./aggregate\":15,\"./axis\":16,\"./bin\":17,\"./facet\":19,\"./filter\":20,\"./group\":21,\"./layout\":22,\"./legend\":23,\"./marks\":24,\"./scale\":25,\"./sort\":26,\"./stack\":27,\"./style\":28,\"./subfacet\":29,\"./template\":30,\"./time\":31,\"datalib/src/stats\":11}],19:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    stats,\n    style,\n    sorting,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":36,\"../util\":39,\"./axis\":16,\"./group\":21,\"./scale\":25}],20:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(rawTable, encoding) {\n  var filters = encoding.filter();  // apply filters to raw data before aggregation\n\n  if (!rawTable.transform)\n    rawTable.transform = [];\n\n  // add custom filters\n  for (var i=0, l=filters.length; i<l; i++) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    rawTable.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n\n  return rawTable;\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.fieldRef(encType) + '>0'\n      });\n    }\n  });\n};\n\n},{\"../globals\":36}],21:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],22:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n\n},{\"../globals\":36,\"../util\":39,\"./time\":31,\"d3-format\":5}],23:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props,\n    timeUnit = encoding.field(name).timeUnit;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ timeUnit;\n  }\n\n  return def;\n};\n\n},{\"../globals\":36,\"./time\":31}],24:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style, stats) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.text.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(name)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n\n},{\"../globals\":36}],25:[function(require,module,exports){\n'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolateLab = require('d3-color').interpolateLab,\n  schema = require('../schema/schema');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, sorting, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, sorting, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  return {data: sorting.getDataset(name), field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette;\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n      } else {\n        if (cardinality <= 2) {\n          range = [colorbrewer[ordinalPalette][3][0], colorbrewer[ordinalPalette][3][2]];\n        } else {\n          range = ordinalPalette;\n        }\n      }\n    } else { //time or quantitative\n      var palette = colorbrewer[ordinalPalette][9];\n      range = [palette[0], palette[8]];\n      s.zero = false;\n    }\n  }\n  return scale.color.palette(range, cardinality, type);\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range],\n      ps = 5;\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    return scale.color.interpolate(palette[ps][0], palette[ps][ps-1], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n  var interpolator = interpolateLab(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n\n},{\"../globals\":36,\"../schema/schema\":37,\"../util\":39,\"./time\":31,\"colorbrewer\":3,\"d3-color\":4}],26:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n\n},{\"../field\":35,\"../globals\":36}],27:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":36,\"./marks\":24}],28:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../field\":35,\"../globals\":36}],29:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n\n},{\"../globals\":36,\"./group\":21}],30:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"../field\":35,\"../globals\":36,\"./group\":21}],31:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nmodule.exports = time;\n\nvar LONG_DATE = new Date(2014, 8, 17);\n\nfunction time(spec, encoding) { // FIXME refactor to reduce side effect #276\n  // jshint unused:false\n  var timeFields = {}, timeUnits = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.timeUnit) {\n      timeFields[encoding.fieldRef(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeUnits[field.timeUnit] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[0],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var timeUnit in timeUnits) {\n    var scale = time.scale.def(timeUnit, encoding);\n    if (scale) scales.push(scale);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.timeUnit, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.fieldRef(encType),\n    expr: time.formula(field)\n  });\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n},{\"../util\":39,\"d3-time-format\":6}],32:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":36}],33:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};\n},{\"./globals\":36,\"datalib/src/stats\":11}],34:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};\n},{\"./consts\":32,\"./field\":35,\"./schema/schema\":37,\"./util\":39}],35:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.data ? 'data.' : '') + (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compiler/time\":31,\"./consts\":32,\"./globals\":36,\"./schema/schema\":37,\"./util\":39}],36:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],37:[function(require,module,exports){\n// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks :{\n          type: 'integer',\n          default: 5,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette'\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: 'BuGn',\n          enum: util.keys(colorbrewer)\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'whether the shape\\'s color should be used as fill color instead of stroke color'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../globals\":36,\"../util\":39,\"./schemautil\":38,\"colorbrewer\":3}],38:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":39}],39:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n\n},{\"datalib/src/bins/bins\":8,\"datalib/src/generate\":9,\"datalib/src/stats\":11,\"datalib/src/util\":13}],40:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;\n},{\"./Encoding\":14,\"./compiler/compiler\":18,\"./consts\":32,\"./data\":33,\"./enc\":34,\"./field\":35,\"./globals\":36,\"./schema/schema\":37,\"./util\":39}]},{},[40])(40)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2NvbG9yYnJld2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2J1aWxkL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvYnVpbGQvdGltZUZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL25vZGVfbW9kdWxlcy9kMy10aW1lL2J1aWxkL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYmlucy9iaW5zLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2dlbmVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdXRpbC5qcyIsInNyYy9FbmNvZGluZy5qcyIsInNyYy9jb21waWxlci9hZ2dyZWdhdGUuanMiLCJzcmMvY29tcGlsZXIvYXhpcy5qcyIsInNyYy9jb21waWxlci9iaW4uanMiLCJzcmMvY29tcGlsZXIvY29tcGlsZXIuanMiLCJzcmMvY29tcGlsZXIvZmFjZXQuanMiLCJzcmMvY29tcGlsZXIvZmlsdGVyLmpzIiwic3JjL2NvbXBpbGVyL2dyb3VwLmpzIiwic3JjL2NvbXBpbGVyL2xheW91dC5qcyIsInNyYy9jb21waWxlci9sZWdlbmQuanMiLCJzcmMvY29tcGlsZXIvbWFya3MuanMiLCJzcmMvY29tcGlsZXIvc2NhbGUuanMiLCJzcmMvY29tcGlsZXIvc29ydC5qcyIsInNyYy9jb21waWxlci9zdGFjay5qcyIsInNyYy9jb21waWxlci9zdHlsZS5qcyIsInNyYy9jb21waWxlci9zdWJmYWNldC5qcyIsInNyYy9jb21waWxlci90ZW1wbGF0ZS5qcyIsInNyYy9jb21waWxlci90aW1lLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9kYXRhLmpzIiwic3JjL2VuYy5qcyIsInNyYy9maWVsZC5qcyIsInNyYy9nbG9iYWxzLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyIsInNyYy92bCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3VCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCIvLyBUaGlzIHByb2R1Y3QgaW5jbHVkZXMgY29sb3Igc3BlY2lmaWNhdGlvbnMgYW5kIGRlc2lnbnMgZGV2ZWxvcGVkIGJ5IEN5bnRoaWEgQnJld2VyIChodHRwOi8vY29sb3JicmV3ZXIub3JnLykuXG4vLyBKYXZhU2NyaXB0IHNwZWNzIGFzIHBhY2thZ2VkIGluIHRoZSBEMyBsaWJyYXJ5IChkM2pzLm9yZykuIFBsZWFzZSBzZWUgbGljZW5zZSBhdCBodHRwOi8vY29sb3JicmV3ZXIub3JnL2V4cG9ydC9MSUNFTlNFLnR4dFxuIWZ1bmN0aW9uKCkge1xuXG52YXIgY29sb3JicmV3ZXIgPSB7WWxHbjoge1xuMzogW1wiI2Y3ZmNiOVwiLFwiI2FkZGQ4ZVwiLFwiIzMxYTM1NFwiXSxcbjQ6IFtcIiNmZmZmY2NcIixcIiNjMmU2OTlcIixcIiM3OGM2NzlcIixcIiMyMzg0NDNcIl0sXG41OiBbXCIjZmZmZmNjXCIsXCIjYzJlNjk5XCIsXCIjNzhjNjc5XCIsXCIjMzFhMzU0XCIsXCIjMDA2ODM3XCJdLFxuNjogW1wiI2ZmZmZjY1wiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzMxYTM1NFwiLFwiIzAwNjgzN1wiXSxcbjc6IFtcIiNmZmZmY2NcIixcIiNkOWYwYTNcIixcIiNhZGRkOGVcIixcIiM3OGM2NzlcIixcIiM0MWFiNWRcIixcIiMyMzg0NDNcIixcIiMwMDVhMzJcIl0sXG44OiBbXCIjZmZmZmU1XCIsXCIjZjdmY2I5XCIsXCIjZDlmMGEzXCIsXCIjYWRkZDhlXCIsXCIjNzhjNjc5XCIsXCIjNDFhYjVkXCIsXCIjMjM4NDQzXCIsXCIjMDA1YTMyXCJdLFxuOTogW1wiI2ZmZmZlNVwiLFwiI2Y3ZmNiOVwiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzQxYWI1ZFwiLFwiIzIzODQ0M1wiLFwiIzAwNjgzN1wiLFwiIzAwNDUyOVwiXVxufSxZbEduQnU6IHtcbjM6IFtcIiNlZGY4YjFcIixcIiM3ZmNkYmJcIixcIiMyYzdmYjhcIl0sXG40OiBbXCIjZmZmZmNjXCIsXCIjYTFkYWI0XCIsXCIjNDFiNmM0XCIsXCIjMjI1ZWE4XCJdLFxuNTogW1wiI2ZmZmZjY1wiLFwiI2ExZGFiNFwiLFwiIzQxYjZjNFwiLFwiIzJjN2ZiOFwiLFwiIzI1MzQ5NFwiXSxcbjY6IFtcIiNmZmZmY2NcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMyYzdmYjhcIixcIiMyNTM0OTRcIl0sXG43OiBbXCIjZmZmZmNjXCIsXCIjYzdlOWI0XCIsXCIjN2ZjZGJiXCIsXCIjNDFiNmM0XCIsXCIjMWQ5MWMwXCIsXCIjMjI1ZWE4XCIsXCIjMGMyYzg0XCJdLFxuODogW1wiI2ZmZmZkOVwiLFwiI2VkZjhiMVwiLFwiI2M3ZTliNFwiLFwiIzdmY2RiYlwiLFwiIzQxYjZjNFwiLFwiIzFkOTFjMFwiLFwiIzIyNWVhOFwiLFwiIzBjMmM4NFwiXSxcbjk6IFtcIiNmZmZmZDlcIixcIiNlZGY4YjFcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMxZDkxYzBcIixcIiMyMjVlYThcIixcIiMyNTM0OTRcIixcIiMwODFkNThcIl1cbn0sR25CdToge1xuMzogW1wiI2UwZjNkYlwiLFwiI2E4ZGRiNVwiLFwiIzQzYTJjYVwiXSxcbjQ6IFtcIiNmMGY5ZThcIixcIiNiYWU0YmNcIixcIiM3YmNjYzRcIixcIiMyYjhjYmVcIl0sXG41OiBbXCIjZjBmOWU4XCIsXCIjYmFlNGJjXCIsXCIjN2JjY2M0XCIsXCIjNDNhMmNhXCIsXCIjMDg2OGFjXCJdLFxuNjogW1wiI2YwZjllOFwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzQzYTJjYVwiLFwiIzA4NjhhY1wiXSxcbjc6IFtcIiNmMGY5ZThcIixcIiNjY2ViYzVcIixcIiNhOGRkYjVcIixcIiM3YmNjYzRcIixcIiM0ZWIzZDNcIixcIiMyYjhjYmVcIixcIiMwODU4OWVcIl0sXG44OiBbXCIjZjdmY2YwXCIsXCIjZTBmM2RiXCIsXCIjY2NlYmM1XCIsXCIjYThkZGI1XCIsXCIjN2JjY2M0XCIsXCIjNGViM2QzXCIsXCIjMmI4Y2JlXCIsXCIjMDg1ODllXCJdLFxuOTogW1wiI2Y3ZmNmMFwiLFwiI2UwZjNkYlwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzRlYjNkM1wiLFwiIzJiOGNiZVwiLFwiIzA4NjhhY1wiLFwiIzA4NDA4MVwiXVxufSxCdUduOiB7XG4zOiBbXCIjZTVmNWY5XCIsXCIjOTlkOGM5XCIsXCIjMmNhMjVmXCJdLFxuNDogW1wiI2VkZjhmYlwiLFwiI2IyZTJlMlwiLFwiIzY2YzJhNFwiLFwiIzIzOGI0NVwiXSxcbjU6IFtcIiNlZGY4ZmJcIixcIiNiMmUyZTJcIixcIiM2NmMyYTRcIixcIiMyY2EyNWZcIixcIiMwMDZkMmNcIl0sXG42OiBbXCIjZWRmOGZiXCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjMmNhMjVmXCIsXCIjMDA2ZDJjXCJdLFxuNzogW1wiI2VkZjhmYlwiLFwiI2NjZWNlNlwiLFwiIzk5ZDhjOVwiLFwiIzY2YzJhNFwiLFwiIzQxYWU3NlwiLFwiIzIzOGI0NVwiLFwiIzAwNTgyNFwiXSxcbjg6IFtcIiNmN2ZjZmRcIixcIiNlNWY1ZjlcIixcIiNjY2VjZTZcIixcIiM5OWQ4YzlcIixcIiM2NmMyYTRcIixcIiM0MWFlNzZcIixcIiMyMzhiNDVcIixcIiMwMDU4MjRcIl0sXG45OiBbXCIjZjdmY2ZkXCIsXCIjZTVmNWY5XCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjNDFhZTc2XCIsXCIjMjM4YjQ1XCIsXCIjMDA2ZDJjXCIsXCIjMDA0NDFiXCJdXG59LFB1QnVHbjoge1xuMzogW1wiI2VjZTJmMFwiLFwiI2E2YmRkYlwiLFwiIzFjOTA5OVwiXSxcbjQ6IFtcIiNmNmVmZjdcIixcIiNiZGM5ZTFcIixcIiM2N2E5Y2ZcIixcIiMwMjgxOGFcIl0sXG41OiBbXCIjZjZlZmY3XCIsXCIjYmRjOWUxXCIsXCIjNjdhOWNmXCIsXCIjMWM5MDk5XCIsXCIjMDE2YzU5XCJdLFxuNjogW1wiI2Y2ZWZmN1wiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzFjOTA5OVwiLFwiIzAxNmM1OVwiXSxcbjc6IFtcIiNmNmVmZjdcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM2N2E5Y2ZcIixcIiMzNjkwYzBcIixcIiMwMjgxOGFcIixcIiMwMTY0NTBcIl0sXG44OiBbXCIjZmZmN2ZiXCIsXCIjZWNlMmYwXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNjdhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDI4MThhXCIsXCIjMDE2NDUwXCJdLFxuOTogW1wiI2ZmZjdmYlwiLFwiI2VjZTJmMFwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzM2OTBjMFwiLFwiIzAyODE4YVwiLFwiIzAxNmM1OVwiLFwiIzAxNDYzNlwiXVxufSxQdUJ1OiB7XG4zOiBbXCIjZWNlN2YyXCIsXCIjYTZiZGRiXCIsXCIjMmI4Y2JlXCJdLFxuNDogW1wiI2YxZWVmNlwiLFwiI2JkYzllMVwiLFwiIzc0YTljZlwiLFwiIzA1NzBiMFwiXSxcbjU6IFtcIiNmMWVlZjZcIixcIiNiZGM5ZTFcIixcIiM3NGE5Y2ZcIixcIiMyYjhjYmVcIixcIiMwNDVhOGRcIl0sXG42OiBbXCIjZjFlZWY2XCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMmI4Y2JlXCIsXCIjMDQ1YThkXCJdLFxuNzogW1wiI2YxZWVmNlwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzc0YTljZlwiLFwiIzM2OTBjMFwiLFwiIzA1NzBiMFwiLFwiIzAzNGU3YlwiXSxcbjg6IFtcIiNmZmY3ZmJcIixcIiNlY2U3ZjJcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM3NGE5Y2ZcIixcIiMzNjkwYzBcIixcIiMwNTcwYjBcIixcIiMwMzRlN2JcIl0sXG45OiBbXCIjZmZmN2ZiXCIsXCIjZWNlN2YyXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDU3MGIwXCIsXCIjMDQ1YThkXCIsXCIjMDIzODU4XCJdXG59LEJ1UHU6IHtcbjM6IFtcIiNlMGVjZjRcIixcIiM5ZWJjZGFcIixcIiM4ODU2YTdcIl0sXG40OiBbXCIjZWRmOGZiXCIsXCIjYjNjZGUzXCIsXCIjOGM5NmM2XCIsXCIjODg0MTlkXCJdLFxuNTogW1wiI2VkZjhmYlwiLFwiI2IzY2RlM1wiLFwiIzhjOTZjNlwiLFwiIzg4NTZhN1wiLFwiIzgxMGY3Y1wiXSxcbjY6IFtcIiNlZGY4ZmJcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4ODU2YTdcIixcIiM4MTBmN2NcIl0sXG43OiBbXCIjZWRmOGZiXCIsXCIjYmZkM2U2XCIsXCIjOWViY2RhXCIsXCIjOGM5NmM2XCIsXCIjOGM2YmIxXCIsXCIjODg0MTlkXCIsXCIjNmUwMTZiXCJdLFxuODogW1wiI2Y3ZmNmZFwiLFwiI2UwZWNmNFwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzhjNmJiMVwiLFwiIzg4NDE5ZFwiLFwiIzZlMDE2YlwiXSxcbjk6IFtcIiNmN2ZjZmRcIixcIiNlMGVjZjRcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4YzZiYjFcIixcIiM4ODQxOWRcIixcIiM4MTBmN2NcIixcIiM0ZDAwNGJcIl1cbn0sUmRQdToge1xuMzogW1wiI2ZkZTBkZFwiLFwiI2ZhOWZiNVwiLFwiI2M1MWI4YVwiXSxcbjQ6IFtcIiNmZWViZTJcIixcIiNmYmI0YjlcIixcIiNmNzY4YTFcIixcIiNhZTAxN2VcIl0sXG41OiBbXCIjZmVlYmUyXCIsXCIjZmJiNGI5XCIsXCIjZjc2OGExXCIsXCIjYzUxYjhhXCIsXCIjN2EwMTc3XCJdLFxuNjogW1wiI2ZlZWJlMlwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2M1MWI4YVwiLFwiIzdhMDE3N1wiXSxcbjc6IFtcIiNmZWViZTJcIixcIiNmY2M1YzBcIixcIiNmYTlmYjVcIixcIiNmNzY4YTFcIixcIiNkZDM0OTdcIixcIiNhZTAxN2VcIixcIiM3YTAxNzdcIl0sXG44OiBbXCIjZmZmN2YzXCIsXCIjZmRlMGRkXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjZGQzNDk3XCIsXCIjYWUwMTdlXCIsXCIjN2EwMTc3XCJdLFxuOTogW1wiI2ZmZjdmM1wiLFwiI2ZkZTBkZFwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2RkMzQ5N1wiLFwiI2FlMDE3ZVwiLFwiIzdhMDE3N1wiLFwiIzQ5MDA2YVwiXVxufSxQdVJkOiB7XG4zOiBbXCIjZTdlMWVmXCIsXCIjYzk5NGM3XCIsXCIjZGQxYzc3XCJdLFxuNDogW1wiI2YxZWVmNlwiLFwiI2Q3YjVkOFwiLFwiI2RmNjViMFwiLFwiI2NlMTI1NlwiXSxcbjU6IFtcIiNmMWVlZjZcIixcIiNkN2I1ZDhcIixcIiNkZjY1YjBcIixcIiNkZDFjNzdcIixcIiM5ODAwNDNcIl0sXG42OiBbXCIjZjFlZWY2XCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZGQxYzc3XCIsXCIjOTgwMDQzXCJdLFxuNzogW1wiI2YxZWVmNlwiLFwiI2Q0YjlkYVwiLFwiI2M5OTRjN1wiLFwiI2RmNjViMFwiLFwiI2U3Mjk4YVwiLFwiI2NlMTI1NlwiLFwiIzkxMDAzZlwiXSxcbjg6IFtcIiNmN2Y0ZjlcIixcIiNlN2UxZWZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNlNzI5OGFcIixcIiNjZTEyNTZcIixcIiM5MTAwM2ZcIl0sXG45OiBbXCIjZjdmNGY5XCIsXCIjZTdlMWVmXCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZTcyOThhXCIsXCIjY2UxMjU2XCIsXCIjOTgwMDQzXCIsXCIjNjcwMDFmXCJdXG59LE9yUmQ6IHtcbjM6IFtcIiNmZWU4YzhcIixcIiNmZGJiODRcIixcIiNlMzRhMzNcIl0sXG40OiBbXCIjZmVmMGQ5XCIsXCIjZmRjYzhhXCIsXCIjZmM4ZDU5XCIsXCIjZDczMDFmXCJdLFxuNTogW1wiI2ZlZjBkOVwiLFwiI2ZkY2M4YVwiLFwiI2ZjOGQ1OVwiLFwiI2UzNGEzM1wiLFwiI2IzMDAwMFwiXSxcbjY6IFtcIiNmZWYwZDlcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlMzRhMzNcIixcIiNiMzAwMDBcIl0sXG43OiBbXCIjZmVmMGQ5XCIsXCIjZmRkNDllXCIsXCIjZmRiYjg0XCIsXCIjZmM4ZDU5XCIsXCIjZWY2NTQ4XCIsXCIjZDczMDFmXCIsXCIjOTkwMDAwXCJdLFxuODogW1wiI2ZmZjdlY1wiLFwiI2ZlZThjOFwiLFwiI2ZkZDQ5ZVwiLFwiI2ZkYmI4NFwiLFwiI2ZjOGQ1OVwiLFwiI2VmNjU0OFwiLFwiI2Q3MzAxZlwiLFwiIzk5MDAwMFwiXSxcbjk6IFtcIiNmZmY3ZWNcIixcIiNmZWU4YzhcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlZjY1NDhcIixcIiNkNzMwMWZcIixcIiNiMzAwMDBcIixcIiM3ZjAwMDBcIl1cbn0sWWxPclJkOiB7XG4zOiBbXCIjZmZlZGEwXCIsXCIjZmViMjRjXCIsXCIjZjAzYjIwXCJdLFxuNDogW1wiI2ZmZmZiMlwiLFwiI2ZlY2M1Y1wiLFwiI2ZkOGQzY1wiLFwiI2UzMWExY1wiXSxcbjU6IFtcIiNmZmZmYjJcIixcIiNmZWNjNWNcIixcIiNmZDhkM2NcIixcIiNmMDNiMjBcIixcIiNiZDAwMjZcIl0sXG42OiBbXCIjZmZmZmIyXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZjAzYjIwXCIsXCIjYmQwMDI2XCJdLFxuNzogW1wiI2ZmZmZiMlwiLFwiI2ZlZDk3NlwiLFwiI2ZlYjI0Y1wiLFwiI2ZkOGQzY1wiLFwiI2ZjNGUyYVwiLFwiI2UzMWExY1wiLFwiI2IxMDAyNlwiXSxcbjg6IFtcIiNmZmZmY2NcIixcIiNmZmVkYTBcIixcIiNmZWQ5NzZcIixcIiNmZWIyNGNcIixcIiNmZDhkM2NcIixcIiNmYzRlMmFcIixcIiNlMzFhMWNcIixcIiNiMTAwMjZcIl0sXG45OiBbXCIjZmZmZmNjXCIsXCIjZmZlZGEwXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZmM0ZTJhXCIsXCIjZTMxYTFjXCIsXCIjYmQwMDI2XCIsXCIjODAwMDI2XCJdXG59LFlsT3JCcjoge1xuMzogW1wiI2ZmZjdiY1wiLFwiI2ZlYzQ0ZlwiLFwiI2Q5NWYwZVwiXSxcbjQ6IFtcIiNmZmZmZDRcIixcIiNmZWQ5OGVcIixcIiNmZTk5MjlcIixcIiNjYzRjMDJcIl0sXG41OiBbXCIjZmZmZmQ0XCIsXCIjZmVkOThlXCIsXCIjZmU5OTI5XCIsXCIjZDk1ZjBlXCIsXCIjOTkzNDA0XCJdLFxuNjogW1wiI2ZmZmZkNFwiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2Q5NWYwZVwiLFwiIzk5MzQwNFwiXSxcbjc6IFtcIiNmZmZmZDRcIixcIiNmZWUzOTFcIixcIiNmZWM0NGZcIixcIiNmZTk5MjlcIixcIiNlYzcwMTRcIixcIiNjYzRjMDJcIixcIiM4YzJkMDRcIl0sXG44OiBbXCIjZmZmZmU1XCIsXCIjZmZmN2JjXCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZWM3MDE0XCIsXCIjY2M0YzAyXCIsXCIjOGMyZDA0XCJdLFxuOTogW1wiI2ZmZmZlNVwiLFwiI2ZmZjdiY1wiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2VjNzAxNFwiLFwiI2NjNGMwMlwiLFwiIzk5MzQwNFwiLFwiIzY2MjUwNlwiXVxufSxQdXJwbGVzOiB7XG4zOiBbXCIjZWZlZGY1XCIsXCIjYmNiZGRjXCIsXCIjNzU2YmIxXCJdLFxuNDogW1wiI2YyZjBmN1wiLFwiI2NiYzllMlwiLFwiIzllOWFjOFwiLFwiIzZhNTFhM1wiXSxcbjU6IFtcIiNmMmYwZjdcIixcIiNjYmM5ZTJcIixcIiM5ZTlhYzhcIixcIiM3NTZiYjFcIixcIiM1NDI3OGZcIl0sXG42OiBbXCIjZjJmMGY3XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjNzU2YmIxXCIsXCIjNTQyNzhmXCJdLFxuNzogW1wiI2YyZjBmN1wiLFwiI2RhZGFlYlwiLFwiI2JjYmRkY1wiLFwiIzllOWFjOFwiLFwiIzgwN2RiYVwiLFwiIzZhNTFhM1wiLFwiIzRhMTQ4NlwiXSxcbjg6IFtcIiNmY2ZiZmRcIixcIiNlZmVkZjVcIixcIiNkYWRhZWJcIixcIiNiY2JkZGNcIixcIiM5ZTlhYzhcIixcIiM4MDdkYmFcIixcIiM2YTUxYTNcIixcIiM0YTE0ODZcIl0sXG45OiBbXCIjZmNmYmZkXCIsXCIjZWZlZGY1XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjODA3ZGJhXCIsXCIjNmE1MWEzXCIsXCIjNTQyNzhmXCIsXCIjM2YwMDdkXCJdXG59LEJsdWVzOiB7XG4zOiBbXCIjZGVlYmY3XCIsXCIjOWVjYWUxXCIsXCIjMzE4MmJkXCJdLFxuNDogW1wiI2VmZjNmZlwiLFwiI2JkZDdlN1wiLFwiIzZiYWVkNlwiLFwiIzIxNzFiNVwiXSxcbjU6IFtcIiNlZmYzZmZcIixcIiNiZGQ3ZTdcIixcIiM2YmFlZDZcIixcIiMzMTgyYmRcIixcIiMwODUxOWNcIl0sXG42OiBbXCIjZWZmM2ZmXCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjMzE4MmJkXCIsXCIjMDg1MTljXCJdLFxuNzogW1wiI2VmZjNmZlwiLFwiI2M2ZGJlZlwiLFwiIzllY2FlMVwiLFwiIzZiYWVkNlwiLFwiIzQyOTJjNlwiLFwiIzIxNzFiNVwiLFwiIzA4NDU5NFwiXSxcbjg6IFtcIiNmN2ZiZmZcIixcIiNkZWViZjdcIixcIiNjNmRiZWZcIixcIiM5ZWNhZTFcIixcIiM2YmFlZDZcIixcIiM0MjkyYzZcIixcIiMyMTcxYjVcIixcIiMwODQ1OTRcIl0sXG45OiBbXCIjZjdmYmZmXCIsXCIjZGVlYmY3XCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjNDI5MmM2XCIsXCIjMjE3MWI1XCIsXCIjMDg1MTljXCIsXCIjMDgzMDZiXCJdXG59LEdyZWVuczoge1xuMzogW1wiI2U1ZjVlMFwiLFwiI2ExZDk5YlwiLFwiIzMxYTM1NFwiXSxcbjQ6IFtcIiNlZGY4ZTlcIixcIiNiYWU0YjNcIixcIiM3NGM0NzZcIixcIiMyMzhiNDVcIl0sXG41OiBbXCIjZWRmOGU5XCIsXCIjYmFlNGIzXCIsXCIjNzRjNDc2XCIsXCIjMzFhMzU0XCIsXCIjMDA2ZDJjXCJdLFxuNjogW1wiI2VkZjhlOVwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzMxYTM1NFwiLFwiIzAwNmQyY1wiXSxcbjc6IFtcIiNlZGY4ZTlcIixcIiNjN2U5YzBcIixcIiNhMWQ5OWJcIixcIiM3NGM0NzZcIixcIiM0MWFiNWRcIixcIiMyMzhiNDVcIixcIiMwMDVhMzJcIl0sXG44OiBbXCIjZjdmY2Y1XCIsXCIjZTVmNWUwXCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjNDFhYjVkXCIsXCIjMjM4YjQ1XCIsXCIjMDA1YTMyXCJdLFxuOTogW1wiI2Y3ZmNmNVwiLFwiI2U1ZjVlMFwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzQxYWI1ZFwiLFwiIzIzOGI0NVwiLFwiIzAwNmQyY1wiLFwiIzAwNDQxYlwiXVxufSxPcmFuZ2VzOiB7XG4zOiBbXCIjZmVlNmNlXCIsXCIjZmRhZTZiXCIsXCIjZTY1NTBkXCJdLFxuNDogW1wiI2ZlZWRkZVwiLFwiI2ZkYmU4NVwiLFwiI2ZkOGQzY1wiLFwiI2Q5NDcwMVwiXSxcbjU6IFtcIiNmZWVkZGVcIixcIiNmZGJlODVcIixcIiNmZDhkM2NcIixcIiNlNjU1MGRcIixcIiNhNjM2MDNcIl0sXG42OiBbXCIjZmVlZGRlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZTY1NTBkXCIsXCIjYTYzNjAzXCJdLFxuNzogW1wiI2ZlZWRkZVwiLFwiI2ZkZDBhMlwiLFwiI2ZkYWU2YlwiLFwiI2ZkOGQzY1wiLFwiI2YxNjkxM1wiLFwiI2Q5NDgwMVwiLFwiIzhjMmQwNFwiXSxcbjg6IFtcIiNmZmY1ZWJcIixcIiNmZWU2Y2VcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNmMTY5MTNcIixcIiNkOTQ4MDFcIixcIiM4YzJkMDRcIl0sXG45OiBbXCIjZmZmNWViXCIsXCIjZmVlNmNlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZjE2OTEzXCIsXCIjZDk0ODAxXCIsXCIjYTYzNjAzXCIsXCIjN2YyNzA0XCJdXG59LFJlZHM6IHtcbjM6IFtcIiNmZWUwZDJcIixcIiNmYzkyNzJcIixcIiNkZTJkMjZcIl0sXG40OiBbXCIjZmVlNWQ5XCIsXCIjZmNhZTkxXCIsXCIjZmI2YTRhXCIsXCIjY2IxODFkXCJdLFxuNTogW1wiI2ZlZTVkOVwiLFwiI2ZjYWU5MVwiLFwiI2ZiNmE0YVwiLFwiI2RlMmQyNlwiLFwiI2E1MGYxNVwiXSxcbjY6IFtcIiNmZWU1ZDlcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNkZTJkMjZcIixcIiNhNTBmMTVcIl0sXG43OiBbXCIjZmVlNWQ5XCIsXCIjZmNiYmExXCIsXCIjZmM5MjcyXCIsXCIjZmI2YTRhXCIsXCIjZWYzYjJjXCIsXCIjY2IxODFkXCIsXCIjOTkwMDBkXCJdLFxuODogW1wiI2ZmZjVmMFwiLFwiI2ZlZTBkMlwiLFwiI2ZjYmJhMVwiLFwiI2ZjOTI3MlwiLFwiI2ZiNmE0YVwiLFwiI2VmM2IyY1wiLFwiI2NiMTgxZFwiLFwiIzk5MDAwZFwiXSxcbjk6IFtcIiNmZmY1ZjBcIixcIiNmZWUwZDJcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNlZjNiMmNcIixcIiNjYjE4MWRcIixcIiNhNTBmMTVcIixcIiM2NzAwMGRcIl1cbn0sR3JleXM6IHtcbjM6IFtcIiNmMGYwZjBcIixcIiNiZGJkYmRcIixcIiM2MzYzNjNcIl0sXG40OiBbXCIjZjdmN2Y3XCIsXCIjY2NjY2NjXCIsXCIjOTY5Njk2XCIsXCIjNTI1MjUyXCJdLFxuNTogW1wiI2Y3ZjdmN1wiLFwiI2NjY2NjY1wiLFwiIzk2OTY5NlwiLFwiIzYzNjM2M1wiLFwiIzI1MjUyNVwiXSxcbjY6IFtcIiNmN2Y3ZjdcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM2MzYzNjNcIixcIiMyNTI1MjVcIl0sXG43OiBbXCIjZjdmN2Y3XCIsXCIjZDlkOWQ5XCIsXCIjYmRiZGJkXCIsXCIjOTY5Njk2XCIsXCIjNzM3MzczXCIsXCIjNTI1MjUyXCIsXCIjMjUyNTI1XCJdLFxuODogW1wiI2ZmZmZmZlwiLFwiI2YwZjBmMFwiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzczNzM3M1wiLFwiIzUyNTI1MlwiLFwiIzI1MjUyNVwiXSxcbjk6IFtcIiNmZmZmZmZcIixcIiNmMGYwZjBcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM3MzczNzNcIixcIiM1MjUyNTJcIixcIiMyNTI1MjVcIixcIiMwMDAwMDBcIl1cbn0sUHVPcjoge1xuMzogW1wiI2YxYTM0MFwiLFwiI2Y3ZjdmN1wiLFwiIzk5OGVjM1wiXSxcbjQ6IFtcIiNlNjYxMDFcIixcIiNmZGI4NjNcIixcIiNiMmFiZDJcIixcIiM1ZTNjOTlcIl0sXG41OiBbXCIjZTY2MTAxXCIsXCIjZmRiODYzXCIsXCIjZjdmN2Y3XCIsXCIjYjJhYmQyXCIsXCIjNWUzYzk5XCJdLFxuNjogW1wiI2IzNTgwNlwiLFwiI2YxYTM0MFwiLFwiI2ZlZTBiNlwiLFwiI2Q4ZGFlYlwiLFwiIzk5OGVjM1wiLFwiIzU0Mjc4OFwiXSxcbjc6IFtcIiNiMzU4MDZcIixcIiNmMWEzNDBcIixcIiNmZWUwYjZcIixcIiNmN2Y3ZjdcIixcIiNkOGRhZWJcIixcIiM5OThlYzNcIixcIiM1NDI3ODhcIl0sXG44OiBbXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCJdLFxuOTogW1wiI2IzNTgwNlwiLFwiI2UwODIxNFwiLFwiI2ZkYjg2M1wiLFwiI2ZlZTBiNlwiLFwiI2Y3ZjdmN1wiLFwiI2Q4ZGFlYlwiLFwiI2IyYWJkMlwiLFwiIzgwNzNhY1wiLFwiIzU0Mjc4OFwiXSxcbjEwOiBbXCIjN2YzYjA4XCIsXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCIsXCIjMmQwMDRiXCJdLFxuMTE6IFtcIiM3ZjNiMDhcIixcIiNiMzU4MDZcIixcIiNlMDgyMTRcIixcIiNmZGI4NjNcIixcIiNmZWUwYjZcIixcIiNmN2Y3ZjdcIixcIiNkOGRhZWJcIixcIiNiMmFiZDJcIixcIiM4MDczYWNcIixcIiM1NDI3ODhcIixcIiMyZDAwNGJcIl1cbn0sQnJCRzoge1xuMzogW1wiI2Q4YjM2NVwiLFwiI2Y1ZjVmNVwiLFwiIzVhYjRhY1wiXSxcbjQ6IFtcIiNhNjYxMWFcIixcIiNkZmMyN2RcIixcIiM4MGNkYzFcIixcIiMwMTg1NzFcIl0sXG41OiBbXCIjYTY2MTFhXCIsXCIjZGZjMjdkXCIsXCIjZjVmNWY1XCIsXCIjODBjZGMxXCIsXCIjMDE4NTcxXCJdLFxuNjogW1wiIzhjNTEwYVwiLFwiI2Q4YjM2NVwiLFwiI2Y2ZThjM1wiLFwiI2M3ZWFlNVwiLFwiIzVhYjRhY1wiLFwiIzAxNjY1ZVwiXSxcbjc6IFtcIiM4YzUxMGFcIixcIiNkOGIzNjVcIixcIiNmNmU4YzNcIixcIiNmNWY1ZjVcIixcIiNjN2VhZTVcIixcIiM1YWI0YWNcIixcIiMwMTY2NWVcIl0sXG44OiBbXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCJdLFxuOTogW1wiIzhjNTEwYVwiLFwiI2JmODEyZFwiLFwiI2RmYzI3ZFwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzgwY2RjMVwiLFwiIzM1OTc4ZlwiLFwiIzAxNjY1ZVwiXSxcbjEwOiBbXCIjNTQzMDA1XCIsXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCIsXCIjMDAzYzMwXCJdLFxuMTE6IFtcIiM1NDMwMDVcIixcIiM4YzUxMGFcIixcIiNiZjgxMmRcIixcIiNkZmMyN2RcIixcIiNmNmU4YzNcIixcIiNmNWY1ZjVcIixcIiNjN2VhZTVcIixcIiM4MGNkYzFcIixcIiMzNTk3OGZcIixcIiMwMTY2NWVcIixcIiMwMDNjMzBcIl1cbn0sUFJHbjoge1xuMzogW1wiI2FmOGRjM1wiLFwiI2Y3ZjdmN1wiLFwiIzdmYmY3YlwiXSxcbjQ6IFtcIiM3YjMyOTRcIixcIiNjMmE1Y2ZcIixcIiNhNmRiYTBcIixcIiMwMDg4MzdcIl0sXG41OiBbXCIjN2IzMjk0XCIsXCIjYzJhNWNmXCIsXCIjZjdmN2Y3XCIsXCIjYTZkYmEwXCIsXCIjMDA4ODM3XCJdLFxuNjogW1wiIzc2MmE4M1wiLFwiI2FmOGRjM1wiLFwiI2U3ZDRlOFwiLFwiI2Q5ZjBkM1wiLFwiIzdmYmY3YlwiLFwiIzFiNzgzN1wiXSxcbjc6IFtcIiM3NjJhODNcIixcIiNhZjhkYzNcIixcIiNlN2Q0ZThcIixcIiNmN2Y3ZjdcIixcIiNkOWYwZDNcIixcIiM3ZmJmN2JcIixcIiMxYjc4MzdcIl0sXG44OiBbXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCJdLFxuOTogW1wiIzc2MmE4M1wiLFwiIzk5NzBhYlwiLFwiI2MyYTVjZlwiLFwiI2U3ZDRlOFwiLFwiI2Y3ZjdmN1wiLFwiI2Q5ZjBkM1wiLFwiI2E2ZGJhMFwiLFwiIzVhYWU2MVwiLFwiIzFiNzgzN1wiXSxcbjEwOiBbXCIjNDAwMDRiXCIsXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCIsXCIjMDA0NDFiXCJdLFxuMTE6IFtcIiM0MDAwNGJcIixcIiM3NjJhODNcIixcIiM5OTcwYWJcIixcIiNjMmE1Y2ZcIixcIiNlN2Q0ZThcIixcIiNmN2Y3ZjdcIixcIiNkOWYwZDNcIixcIiNhNmRiYTBcIixcIiM1YWFlNjFcIixcIiMxYjc4MzdcIixcIiMwMDQ0MWJcIl1cbn0sUGlZRzoge1xuMzogW1wiI2U5YTNjOVwiLFwiI2Y3ZjdmN1wiLFwiI2ExZDc2YVwiXSxcbjQ6IFtcIiNkMDFjOGJcIixcIiNmMWI2ZGFcIixcIiNiOGUxODZcIixcIiM0ZGFjMjZcIl0sXG41OiBbXCIjZDAxYzhiXCIsXCIjZjFiNmRhXCIsXCIjZjdmN2Y3XCIsXCIjYjhlMTg2XCIsXCIjNGRhYzI2XCJdLFxuNjogW1wiI2M1MWI3ZFwiLFwiI2U5YTNjOVwiLFwiI2ZkZTBlZlwiLFwiI2U2ZjVkMFwiLFwiI2ExZDc2YVwiLFwiIzRkOTIyMVwiXSxcbjc6IFtcIiNjNTFiN2RcIixcIiNlOWEzYzlcIixcIiNmZGUwZWZcIixcIiNmN2Y3ZjdcIixcIiNlNmY1ZDBcIixcIiNhMWQ3NmFcIixcIiM0ZDkyMjFcIl0sXG44OiBbXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCJdLFxuOTogW1wiI2M1MWI3ZFwiLFwiI2RlNzdhZVwiLFwiI2YxYjZkYVwiLFwiI2ZkZTBlZlwiLFwiI2Y3ZjdmN1wiLFwiI2U2ZjVkMFwiLFwiI2I4ZTE4NlwiLFwiIzdmYmM0MVwiLFwiIzRkOTIyMVwiXSxcbjEwOiBbXCIjOGUwMTUyXCIsXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCIsXCIjMjc2NDE5XCJdLFxuMTE6IFtcIiM4ZTAxNTJcIixcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNmN2Y3ZjdcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIixcIiMyNzY0MTlcIl1cbn0sUmRCdToge1xuMzogW1wiI2VmOGE2MlwiLFwiI2Y3ZjdmN1wiLFwiIzY3YTljZlwiXSxcbjQ6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiM5MmM1ZGVcIixcIiMwNTcxYjBcIl0sXG41OiBbXCIjY2EwMDIwXCIsXCIjZjRhNTgyXCIsXCIjZjdmN2Y3XCIsXCIjOTJjNWRlXCIsXCIjMDU3MWIwXCJdLFxuNjogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2QxZTVmMFwiLFwiIzY3YTljZlwiLFwiIzIxNjZhY1wiXSxcbjc6IFtcIiNiMjE4MmJcIixcIiNlZjhhNjJcIixcIiNmZGRiYzdcIixcIiNmN2Y3ZjdcIixcIiNkMWU1ZjBcIixcIiM2N2E5Y2ZcIixcIiMyMTY2YWNcIl0sXG44OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCJdLFxuOTogW1wiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzkyYzVkZVwiLFwiIzQzOTNjM1wiLFwiIzIxNjZhY1wiXSxcbjEwOiBbXCIjNjcwMDFmXCIsXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCIsXCIjMDUzMDYxXCJdLFxuMTE6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNmN2Y3ZjdcIixcIiNkMWU1ZjBcIixcIiM5MmM1ZGVcIixcIiM0MzkzYzNcIixcIiMyMTY2YWNcIixcIiMwNTMwNjFcIl1cbn0sUmRHeToge1xuMzogW1wiI2VmOGE2MlwiLFwiI2ZmZmZmZlwiLFwiIzk5OTk5OVwiXSxcbjQ6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiNiYWJhYmFcIixcIiM0MDQwNDBcIl0sXG41OiBbXCIjY2EwMDIwXCIsXCIjZjRhNTgyXCIsXCIjZmZmZmZmXCIsXCIjYmFiYWJhXCIsXCIjNDA0MDQwXCJdLFxuNjogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2UwZTBlMFwiLFwiIzk5OTk5OVwiLFwiIzRkNGQ0ZFwiXSxcbjc6IFtcIiNiMjE4MmJcIixcIiNlZjhhNjJcIixcIiNmZGRiYzdcIixcIiNmZmZmZmZcIixcIiNlMGUwZTBcIixcIiM5OTk5OTlcIixcIiM0ZDRkNGRcIl0sXG44OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCJdLFxuOTogW1wiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2ZmZmZmZlwiLFwiI2UwZTBlMFwiLFwiI2JhYmFiYVwiLFwiIzg3ODc4N1wiLFwiIzRkNGQ0ZFwiXSxcbjEwOiBbXCIjNjcwMDFmXCIsXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCIsXCIjMWExYTFhXCJdLFxuMTE6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNmZmZmZmZcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIixcIiMxYTFhMWFcIl1cbn0sUmRZbEJ1OiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTFiZmRiXCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2FiZDllOVwiLFwiIzJjN2JiNlwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhYmQ5ZTlcIixcIiMyYzdiYjZcIl0sXG42OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDkwXCIsXCIjZTBmM2Y4XCIsXCIjOTFiZmRiXCIsXCIjNDU3NWI0XCJdLFxuNzogW1wiI2Q3MzAyN1wiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA5MFwiLFwiI2ZmZmZiZlwiLFwiI2UwZjNmOFwiLFwiIzkxYmZkYlwiLFwiIzQ1NzViNFwiXSxcbjg6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIl0sXG45OiBbXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjYWJkOWU5XCIsXCIjNzRhZGQxXCIsXCIjNDU3NWI0XCJdLFxuMTA6IFtcIiNhNTAwMjZcIixcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIixcIiMzMTM2OTVcIl0sXG4xMTogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA5MFwiLFwiI2ZmZmZiZlwiLFwiI2UwZjNmOFwiLFwiI2FiZDllOVwiLFwiIzc0YWRkMVwiLFwiIzQ1NzViNFwiLFwiIzMxMzY5NVwiXVxufSxTcGVjdHJhbDoge1xuMzogW1wiI2ZjOGQ1OVwiLFwiI2ZmZmZiZlwiLFwiIzk5ZDU5NFwiXSxcbjQ6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNhYmRkYTRcIixcIiMyYjgzYmFcIl0sXG41OiBbXCIjZDcxOTFjXCIsXCIjZmRhZTYxXCIsXCIjZmZmZmJmXCIsXCIjYWJkZGE0XCIsXCIjMmI4M2JhXCJdLFxuNjogW1wiI2Q1M2U0ZlwiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2U2ZjU5OFwiLFwiIzk5ZDU5NFwiLFwiIzMyODhiZFwiXSxcbjc6IFtcIiNkNTNlNGZcIixcIiNmYzhkNTlcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNlNmY1OThcIixcIiM5OWQ1OTRcIixcIiMzMjg4YmRcIl0sXG44OiBbXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCJdLFxuOTogW1wiI2Q1M2U0ZlwiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2U2ZjU5OFwiLFwiI2FiZGRhNFwiLFwiIzY2YzJhNVwiLFwiIzMyODhiZFwiXSxcbjEwOiBbXCIjOWUwMTQyXCIsXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCIsXCIjNWU0ZmEyXCJdLFxuMTE6IFtcIiM5ZTAxNDJcIixcIiNkNTNlNGZcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNlNmY1OThcIixcIiNhYmRkYTRcIixcIiM2NmMyYTVcIixcIiMzMjg4YmRcIixcIiM1ZTRmYTJcIl1cbn0sUmRZbEduOiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTFjZjYwXCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2E2ZDk2YVwiLFwiIzFhOTY0MVwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhNmQ5NmFcIixcIiMxYTk2NDFcIl0sXG42OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDhiXCIsXCIjZDllZjhiXCIsXCIjOTFjZjYwXCIsXCIjMWE5ODUwXCJdLFxuNzogW1wiI2Q3MzAyN1wiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2Q5ZWY4YlwiLFwiIzkxY2Y2MFwiLFwiIzFhOTg1MFwiXSxcbjg6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIl0sXG45OiBbXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjYTZkOTZhXCIsXCIjNjZiZDYzXCIsXCIjMWE5ODUwXCJdLFxuMTA6IFtcIiNhNTAwMjZcIixcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIixcIiMwMDY4MzdcIl0sXG4xMTogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2Q5ZWY4YlwiLFwiI2E2ZDk2YVwiLFwiIzY2YmQ2M1wiLFwiIzFhOTg1MFwiLFwiIzAwNjgzN1wiXVxufSxBY2NlbnQ6IHtcbjM6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIl0sXG40OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCJdLFxuNTogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiXSxcbjY6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIixcIiNmZmZmOTlcIixcIiMzODZjYjBcIixcIiNmMDAyN2ZcIl0sXG43OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCIsXCIjMzg2Y2IwXCIsXCIjZjAwMjdmXCIsXCIjYmY1YjE3XCJdLFxuODogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiLFwiI2YwMDI3ZlwiLFwiI2JmNWIxN1wiLFwiIzY2NjY2NlwiXVxufSxEYXJrMjoge1xuMzogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiXSxcbjQ6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIl0sXG41OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCJdLFxuNjogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiLFwiI2U3Mjk4YVwiLFwiIzY2YTYxZVwiLFwiI2U2YWIwMlwiXSxcbjc6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIixcIiNlNmFiMDJcIixcIiNhNjc2MWRcIl0sXG44OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCIsXCIjZTZhYjAyXCIsXCIjYTY3NjFkXCIsXCIjNjY2NjY2XCJdXG59LFBhaXJlZDoge1xuMzogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiXSxcbjQ6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIl0sXG41OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCJdLFxuNjogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiXSxcbjc6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIl0sXG44OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCJdLFxuOTogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiXSxcbjEwOiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCIsXCIjY2FiMmQ2XCIsXCIjNmEzZDlhXCJdLFxuMTE6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIixcIiNjYWIyZDZcIixcIiM2YTNkOWFcIixcIiNmZmZmOTlcIl0sXG4xMjogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiLFwiIzZhM2Q5YVwiLFwiI2ZmZmY5OVwiLFwiI2IxNTkyOFwiXVxufSxQYXN0ZWwxOiB7XG4zOiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCJdLFxuNDogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiXSxcbjU6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIl0sXG42OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCJdLFxuNzogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiLFwiI2ZmZmZjY1wiLFwiI2U1ZDhiZFwiXSxcbjg6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIixcIiNmZmZmY2NcIixcIiNlNWQ4YmRcIixcIiNmZGRhZWNcIl0sXG45OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCIsXCIjZTVkOGJkXCIsXCIjZmRkYWVjXCIsXCIjZjJmMmYyXCJdXG59LFBhc3RlbDI6IHtcbjM6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIl0sXG40OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCJdLFxuNTogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiXSxcbjY6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIixcIiNmNGNhZTRcIixcIiNlNmY1YzlcIixcIiNmZmYyYWVcIl0sXG43OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCIsXCIjZmZmMmFlXCIsXCIjZjFlMmNjXCJdLFxuODogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiLFwiI2ZmZjJhZVwiLFwiI2YxZTJjY1wiLFwiI2NjY2NjY1wiXVxufSxTZXQxOiB7XG4zOiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCJdLFxuNDogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiXSxcbjU6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIl0sXG42OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCJdLFxuNzogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiLFwiI2ZmN2YwMFwiLFwiI2ZmZmYzM1wiLFwiI2E2NTYyOFwiXSxcbjg6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIixcIiNhNjU2MjhcIixcIiNmNzgxYmZcIl0sXG45OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCIsXCIjYTY1NjI4XCIsXCIjZjc4MWJmXCIsXCIjOTk5OTk5XCJdXG59LFNldDI6IHtcbjM6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIl0sXG40OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCJdLFxuNTogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiXSxcbjY6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIixcIiNlNzhhYzNcIixcIiNhNmQ4NTRcIixcIiNmZmQ5MmZcIl0sXG43OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCIsXCIjYTZkODU0XCIsXCIjZmZkOTJmXCIsXCIjZTVjNDk0XCJdLFxuODogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiLFwiI2ZmZDkyZlwiLFwiI2U1YzQ5NFwiLFwiI2IzYjNiM1wiXVxufSxTZXQzOiB7XG4zOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCJdLFxuNDogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiXSxcbjU6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIl0sXG42OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCJdLFxuNzogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiXSxcbjg6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIl0sXG45OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCJdLFxuMTA6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIixcIiNkOWQ5ZDlcIixcIiNiYzgwYmRcIl0sXG4xMTogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiLFwiI2ZjY2RlNVwiLFwiI2Q5ZDlkOVwiLFwiI2JjODBiZFwiLFwiI2NjZWJjNVwiXSxcbjEyOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCIsXCIjYmM4MGJkXCIsXCIjY2NlYmM1XCIsXCIjZmZlZDZmXCJdXG59fTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGNvbG9yYnJld2VyKTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gY29sb3JicmV3ZXI7XG59IGVsc2Uge1xuICAgIHRoaXMuY29sb3JicmV3ZXIgPSBjb2xvcmJyZXdlcjtcbn1cblxufSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbG9yYnJld2VyLmpzJyk7XG4iLCJpZiAodHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBNYXAgPSBmdW5jdGlvbigpIHt9O1xuICBNYXAucHJvdG90eXBlID0ge1xuICAgIHNldDogZnVuY3Rpb24oaywgdikgeyB0aGlzW1wiJFwiICsga10gPSB2OyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXNbXCIkXCIgKyBrXTsgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIFwiJFwiICsgayBpbiB0aGlzOyB9XG4gIH07XG59XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmNvbG9yID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIENvbG9yKCkge31cblxuICBDb2xvci5wcm90b3R5cGUgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmdiKCkgKyBcIlwiO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbmFtZWQgPSAobmV3IE1hcClcbiAgICAgIC5zZXQoXCJhbGljZWJsdWVcIiwgMHhmMGY4ZmYpXG4gICAgICAuc2V0KFwiYW50aXF1ZXdoaXRlXCIsIDB4ZmFlYmQ3KVxuICAgICAgLnNldChcImFxdWFcIiwgMHgwMGZmZmYpXG4gICAgICAuc2V0KFwiYXF1YW1hcmluZVwiLCAweDdmZmZkNClcbiAgICAgIC5zZXQoXCJhenVyZVwiLCAweGYwZmZmZilcbiAgICAgIC5zZXQoXCJiZWlnZVwiLCAweGY1ZjVkYylcbiAgICAgIC5zZXQoXCJiaXNxdWVcIiwgMHhmZmU0YzQpXG4gICAgICAuc2V0KFwiYmxhY2tcIiwgMHgwMDAwMDApXG4gICAgICAuc2V0KFwiYmxhbmNoZWRhbG1vbmRcIiwgMHhmZmViY2QpXG4gICAgICAuc2V0KFwiYmx1ZVwiLCAweDAwMDBmZilcbiAgICAgIC5zZXQoXCJibHVldmlvbGV0XCIsIDB4OGEyYmUyKVxuICAgICAgLnNldChcImJyb3duXCIsIDB4YTUyYTJhKVxuICAgICAgLnNldChcImJ1cmx5d29vZFwiLCAweGRlYjg4NylcbiAgICAgIC5zZXQoXCJjYWRldGJsdWVcIiwgMHg1ZjllYTApXG4gICAgICAuc2V0KFwiY2hhcnRyZXVzZVwiLCAweDdmZmYwMClcbiAgICAgIC5zZXQoXCJjaG9jb2xhdGVcIiwgMHhkMjY5MWUpXG4gICAgICAuc2V0KFwiY29yYWxcIiwgMHhmZjdmNTApXG4gICAgICAuc2V0KFwiY29ybmZsb3dlcmJsdWVcIiwgMHg2NDk1ZWQpXG4gICAgICAuc2V0KFwiY29ybnNpbGtcIiwgMHhmZmY4ZGMpXG4gICAgICAuc2V0KFwiY3JpbXNvblwiLCAweGRjMTQzYylcbiAgICAgIC5zZXQoXCJjeWFuXCIsIDB4MDBmZmZmKVxuICAgICAgLnNldChcImRhcmtibHVlXCIsIDB4MDAwMDhiKVxuICAgICAgLnNldChcImRhcmtjeWFuXCIsIDB4MDA4YjhiKVxuICAgICAgLnNldChcImRhcmtnb2xkZW5yb2RcIiwgMHhiODg2MGIpXG4gICAgICAuc2V0KFwiZGFya2dyYXlcIiwgMHhhOWE5YTkpXG4gICAgICAuc2V0KFwiZGFya2dyZWVuXCIsIDB4MDA2NDAwKVxuICAgICAgLnNldChcImRhcmtncmV5XCIsIDB4YTlhOWE5KVxuICAgICAgLnNldChcImRhcmtraGFraVwiLCAweGJkYjc2YilcbiAgICAgIC5zZXQoXCJkYXJrbWFnZW50YVwiLCAweDhiMDA4YilcbiAgICAgIC5zZXQoXCJkYXJrb2xpdmVncmVlblwiLCAweDU1NmIyZilcbiAgICAgIC5zZXQoXCJkYXJrb3JhbmdlXCIsIDB4ZmY4YzAwKVxuICAgICAgLnNldChcImRhcmtvcmNoaWRcIiwgMHg5OTMyY2MpXG4gICAgICAuc2V0KFwiZGFya3JlZFwiLCAweDhiMDAwMClcbiAgICAgIC5zZXQoXCJkYXJrc2FsbW9uXCIsIDB4ZTk5NjdhKVxuICAgICAgLnNldChcImRhcmtzZWFncmVlblwiLCAweDhmYmM4ZilcbiAgICAgIC5zZXQoXCJkYXJrc2xhdGVibHVlXCIsIDB4NDgzZDhiKVxuICAgICAgLnNldChcImRhcmtzbGF0ZWdyYXlcIiwgMHgyZjRmNGYpXG4gICAgICAuc2V0KFwiZGFya3NsYXRlZ3JleVwiLCAweDJmNGY0ZilcbiAgICAgIC5zZXQoXCJkYXJrdHVycXVvaXNlXCIsIDB4MDBjZWQxKVxuICAgICAgLnNldChcImRhcmt2aW9sZXRcIiwgMHg5NDAwZDMpXG4gICAgICAuc2V0KFwiZGVlcHBpbmtcIiwgMHhmZjE0OTMpXG4gICAgICAuc2V0KFwiZGVlcHNreWJsdWVcIiwgMHgwMGJmZmYpXG4gICAgICAuc2V0KFwiZGltZ3JheVwiLCAweDY5Njk2OSlcbiAgICAgIC5zZXQoXCJkaW1ncmV5XCIsIDB4Njk2OTY5KVxuICAgICAgLnNldChcImRvZGdlcmJsdWVcIiwgMHgxZTkwZmYpXG4gICAgICAuc2V0KFwiZmlyZWJyaWNrXCIsIDB4YjIyMjIyKVxuICAgICAgLnNldChcImZsb3JhbHdoaXRlXCIsIDB4ZmZmYWYwKVxuICAgICAgLnNldChcImZvcmVzdGdyZWVuXCIsIDB4MjI4YjIyKVxuICAgICAgLnNldChcImZ1Y2hzaWFcIiwgMHhmZjAwZmYpXG4gICAgICAuc2V0KFwiZ2FpbnNib3JvXCIsIDB4ZGNkY2RjKVxuICAgICAgLnNldChcImdob3N0d2hpdGVcIiwgMHhmOGY4ZmYpXG4gICAgICAuc2V0KFwiZ29sZFwiLCAweGZmZDcwMClcbiAgICAgIC5zZXQoXCJnb2xkZW5yb2RcIiwgMHhkYWE1MjApXG4gICAgICAuc2V0KFwiZ3JheVwiLCAweDgwODA4MClcbiAgICAgIC5zZXQoXCJncmVlblwiLCAweDAwODAwMClcbiAgICAgIC5zZXQoXCJncmVlbnllbGxvd1wiLCAweGFkZmYyZilcbiAgICAgIC5zZXQoXCJncmV5XCIsIDB4ODA4MDgwKVxuICAgICAgLnNldChcImhvbmV5ZGV3XCIsIDB4ZjBmZmYwKVxuICAgICAgLnNldChcImhvdHBpbmtcIiwgMHhmZjY5YjQpXG4gICAgICAuc2V0KFwiaW5kaWFucmVkXCIsIDB4Y2Q1YzVjKVxuICAgICAgLnNldChcImluZGlnb1wiLCAweDRiMDA4MilcbiAgICAgIC5zZXQoXCJpdm9yeVwiLCAweGZmZmZmMClcbiAgICAgIC5zZXQoXCJraGFraVwiLCAweGYwZTY4YylcbiAgICAgIC5zZXQoXCJsYXZlbmRlclwiLCAweGU2ZTZmYSlcbiAgICAgIC5zZXQoXCJsYXZlbmRlcmJsdXNoXCIsIDB4ZmZmMGY1KVxuICAgICAgLnNldChcImxhd25ncmVlblwiLCAweDdjZmMwMClcbiAgICAgIC5zZXQoXCJsZW1vbmNoaWZmb25cIiwgMHhmZmZhY2QpXG4gICAgICAuc2V0KFwibGlnaHRibHVlXCIsIDB4YWRkOGU2KVxuICAgICAgLnNldChcImxpZ2h0Y29yYWxcIiwgMHhmMDgwODApXG4gICAgICAuc2V0KFwibGlnaHRjeWFuXCIsIDB4ZTBmZmZmKVxuICAgICAgLnNldChcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsIDB4ZmFmYWQyKVxuICAgICAgLnNldChcImxpZ2h0Z3JheVwiLCAweGQzZDNkMylcbiAgICAgIC5zZXQoXCJsaWdodGdyZWVuXCIsIDB4OTBlZTkwKVxuICAgICAgLnNldChcImxpZ2h0Z3JleVwiLCAweGQzZDNkMylcbiAgICAgIC5zZXQoXCJsaWdodHBpbmtcIiwgMHhmZmI2YzEpXG4gICAgICAuc2V0KFwibGlnaHRzYWxtb25cIiwgMHhmZmEwN2EpXG4gICAgICAuc2V0KFwibGlnaHRzZWFncmVlblwiLCAweDIwYjJhYSlcbiAgICAgIC5zZXQoXCJsaWdodHNreWJsdWVcIiwgMHg4N2NlZmEpXG4gICAgICAuc2V0KFwibGlnaHRzbGF0ZWdyYXlcIiwgMHg3Nzg4OTkpXG4gICAgICAuc2V0KFwibGlnaHRzbGF0ZWdyZXlcIiwgMHg3Nzg4OTkpXG4gICAgICAuc2V0KFwibGlnaHRzdGVlbGJsdWVcIiwgMHhiMGM0ZGUpXG4gICAgICAuc2V0KFwibGlnaHR5ZWxsb3dcIiwgMHhmZmZmZTApXG4gICAgICAuc2V0KFwibGltZVwiLCAweDAwZmYwMClcbiAgICAgIC5zZXQoXCJsaW1lZ3JlZW5cIiwgMHgzMmNkMzIpXG4gICAgICAuc2V0KFwibGluZW5cIiwgMHhmYWYwZTYpXG4gICAgICAuc2V0KFwibWFnZW50YVwiLCAweGZmMDBmZilcbiAgICAgIC5zZXQoXCJtYXJvb25cIiwgMHg4MDAwMDApXG4gICAgICAuc2V0KFwibWVkaXVtYXF1YW1hcmluZVwiLCAweDY2Y2RhYSlcbiAgICAgIC5zZXQoXCJtZWRpdW1ibHVlXCIsIDB4MDAwMGNkKVxuICAgICAgLnNldChcIm1lZGl1bW9yY2hpZFwiLCAweGJhNTVkMylcbiAgICAgIC5zZXQoXCJtZWRpdW1wdXJwbGVcIiwgMHg5MzcwZGIpXG4gICAgICAuc2V0KFwibWVkaXVtc2VhZ3JlZW5cIiwgMHgzY2IzNzEpXG4gICAgICAuc2V0KFwibWVkaXVtc2xhdGVibHVlXCIsIDB4N2I2OGVlKVxuICAgICAgLnNldChcIm1lZGl1bXNwcmluZ2dyZWVuXCIsIDB4MDBmYTlhKVxuICAgICAgLnNldChcIm1lZGl1bXR1cnF1b2lzZVwiLCAweDQ4ZDFjYylcbiAgICAgIC5zZXQoXCJtZWRpdW12aW9sZXRyZWRcIiwgMHhjNzE1ODUpXG4gICAgICAuc2V0KFwibWlkbmlnaHRibHVlXCIsIDB4MTkxOTcwKVxuICAgICAgLnNldChcIm1pbnRjcmVhbVwiLCAweGY1ZmZmYSlcbiAgICAgIC5zZXQoXCJtaXN0eXJvc2VcIiwgMHhmZmU0ZTEpXG4gICAgICAuc2V0KFwibW9jY2FzaW5cIiwgMHhmZmU0YjUpXG4gICAgICAuc2V0KFwibmF2YWpvd2hpdGVcIiwgMHhmZmRlYWQpXG4gICAgICAuc2V0KFwibmF2eVwiLCAweDAwMDA4MClcbiAgICAgIC5zZXQoXCJvbGRsYWNlXCIsIDB4ZmRmNWU2KVxuICAgICAgLnNldChcIm9saXZlXCIsIDB4ODA4MDAwKVxuICAgICAgLnNldChcIm9saXZlZHJhYlwiLCAweDZiOGUyMylcbiAgICAgIC5zZXQoXCJvcmFuZ2VcIiwgMHhmZmE1MDApXG4gICAgICAuc2V0KFwib3JhbmdlcmVkXCIsIDB4ZmY0NTAwKVxuICAgICAgLnNldChcIm9yY2hpZFwiLCAweGRhNzBkNilcbiAgICAgIC5zZXQoXCJwYWxlZ29sZGVucm9kXCIsIDB4ZWVlOGFhKVxuICAgICAgLnNldChcInBhbGVncmVlblwiLCAweDk4ZmI5OClcbiAgICAgIC5zZXQoXCJwYWxldHVycXVvaXNlXCIsIDB4YWZlZWVlKVxuICAgICAgLnNldChcInBhbGV2aW9sZXRyZWRcIiwgMHhkYjcwOTMpXG4gICAgICAuc2V0KFwicGFwYXlhd2hpcFwiLCAweGZmZWZkNSlcbiAgICAgIC5zZXQoXCJwZWFjaHB1ZmZcIiwgMHhmZmRhYjkpXG4gICAgICAuc2V0KFwicGVydVwiLCAweGNkODUzZilcbiAgICAgIC5zZXQoXCJwaW5rXCIsIDB4ZmZjMGNiKVxuICAgICAgLnNldChcInBsdW1cIiwgMHhkZGEwZGQpXG4gICAgICAuc2V0KFwicG93ZGVyYmx1ZVwiLCAweGIwZTBlNilcbiAgICAgIC5zZXQoXCJwdXJwbGVcIiwgMHg4MDAwODApXG4gICAgICAuc2V0KFwicmViZWNjYXB1cnBsZVwiLCAweDY2MzM5OSlcbiAgICAgIC5zZXQoXCJyZWRcIiwgMHhmZjAwMDApXG4gICAgICAuc2V0KFwicm9zeWJyb3duXCIsIDB4YmM4ZjhmKVxuICAgICAgLnNldChcInJveWFsYmx1ZVwiLCAweDQxNjllMSlcbiAgICAgIC5zZXQoXCJzYWRkbGVicm93blwiLCAweDhiNDUxMylcbiAgICAgIC5zZXQoXCJzYWxtb25cIiwgMHhmYTgwNzIpXG4gICAgICAuc2V0KFwic2FuZHlicm93blwiLCAweGY0YTQ2MClcbiAgICAgIC5zZXQoXCJzZWFncmVlblwiLCAweDJlOGI1NylcbiAgICAgIC5zZXQoXCJzZWFzaGVsbFwiLCAweGZmZjVlZSlcbiAgICAgIC5zZXQoXCJzaWVubmFcIiwgMHhhMDUyMmQpXG4gICAgICAuc2V0KFwic2lsdmVyXCIsIDB4YzBjMGMwKVxuICAgICAgLnNldChcInNreWJsdWVcIiwgMHg4N2NlZWIpXG4gICAgICAuc2V0KFwic2xhdGVibHVlXCIsIDB4NmE1YWNkKVxuICAgICAgLnNldChcInNsYXRlZ3JheVwiLCAweDcwODA5MClcbiAgICAgIC5zZXQoXCJzbGF0ZWdyZXlcIiwgMHg3MDgwOTApXG4gICAgICAuc2V0KFwic25vd1wiLCAweGZmZmFmYSlcbiAgICAgIC5zZXQoXCJzcHJpbmdncmVlblwiLCAweDAwZmY3ZilcbiAgICAgIC5zZXQoXCJzdGVlbGJsdWVcIiwgMHg0NjgyYjQpXG4gICAgICAuc2V0KFwidGFuXCIsIDB4ZDJiNDhjKVxuICAgICAgLnNldChcInRlYWxcIiwgMHgwMDgwODApXG4gICAgICAuc2V0KFwidGhpc3RsZVwiLCAweGQ4YmZkOClcbiAgICAgIC5zZXQoXCJ0b21hdG9cIiwgMHhmZjYzNDcpXG4gICAgICAuc2V0KFwidHVycXVvaXNlXCIsIDB4NDBlMGQwKVxuICAgICAgLnNldChcInZpb2xldFwiLCAweGVlODJlZSlcbiAgICAgIC5zZXQoXCJ3aGVhdFwiLCAweGY1ZGViMylcbiAgICAgIC5zZXQoXCJ3aGl0ZVwiLCAweGZmZmZmZilcbiAgICAgIC5zZXQoXCJ3aGl0ZXNtb2tlXCIsIDB4ZjVmNWY1KVxuICAgICAgLnNldChcInllbGxvd1wiLCAweGZmZmYwMClcbiAgICAgIC5zZXQoXCJ5ZWxsb3dncmVlblwiLCAweDlhY2QzMik7XG5cbiAgZnVuY3Rpb24gUmdiKHIsIGcsIGIpIHtcbiAgICB0aGlzLnIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQocikpKTtcbiAgICB0aGlzLmcgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoZykpKTtcbiAgICB0aGlzLmIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoYikpKTtcbiAgfVxuXG4gIHZhciBfcHJvdG90eXBlID0gUmdiLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICB2YXIgZGFya2VyID0gLjc7XG5cbiAgX3Byb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogayk7XG4gIH07XG5cbiAgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxuICBfcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrKTtcbiAgfTtcblxuICBfcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdChyLCBnLCBiKSB7XG4gICAgaWYgKGlzTmFOKHIpKSByID0gMDtcbiAgICBpZiAoaXNOYU4oZykpIGcgPSAwO1xuICAgIGlmIChpc05hTihiKSkgYiA9IDA7XG4gICAgcmV0dXJuIFwiI1wiXG4gICAgICAgICsgKHIgPCAxNiA/IFwiMFwiICsgci50b1N0cmluZygxNikgOiByLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgKyAoZyA8IDE2ID8gXCIwXCIgKyBnLnRvU3RyaW5nKDE2KSA6IGcudG9TdHJpbmcoMTYpKVxuICAgICAgICArIChiIDwgMTYgPyBcIjBcIiArIGIudG9TdHJpbmcoMTYpIDogYi50b1N0cmluZygxNikpO1xuICB9XG5cbiAgX3Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gIH07XG5cbiAgdmFyIHJnYiA9IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKCEociBpbnN0YW5jZW9mIENvbG9yKSkgciA9IGNvbG9yKHIpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgciA9IHIucmdiKCk7XG4gICAgICAgIGIgPSByLmI7XG4gICAgICAgIGcgPSByLmc7XG4gICAgICAgIHIgPSByLnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gZyA9IGIgPSBOYU47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmdiKHIsIGcsIGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdibihuKSB7XG4gICAgcmV0dXJuIHJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYpO1xuICB9XG5cbiAgZnVuY3Rpb24gSHNsKGgsIHMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLnMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCArcykpO1xuICAgIHRoaXMubCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICtsKSk7XG4gIH1cblxuICB2YXIgX19wcm90b3R5cGUgPSBIc2wucHJvdG90eXBlID0gbmV3IENvbG9yO1xuXG4gIF9fcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgX19wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTsvKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5cbiAgZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgICAgOiBtMSkgKiAyNTU7XG4gIH1cblxuICBfX3Byb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgPD0gLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgaHNsID0gZnVuY3Rpb24oaCwgcywgbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaCBpbnN0YW5jZW9mIEhzbCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIENvbG9yKSkgaCA9IGNvbG9yKGgpO1xuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgIGlmIChoIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gaDtcbiAgICAgICAgICBoID0gaC5yZ2IoKTtcbiAgICAgICAgICB2YXIgciA9IGguciAvIDI1NSxcbiAgICAgICAgICAgICAgZyA9IGguZyAvIDI1NSxcbiAgICAgICAgICAgICAgYiA9IGguYiAvIDI1NSxcbiAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgICAgICByYW5nZSA9IG1heCAtIG1pbjtcbiAgICAgICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgcyA9IGwgPCAuNSA/IHJhbmdlIC8gKG1heCArIG1pbikgOiByYW5nZSAvICgyIC0gbWF4IC0gbWluKTtcbiAgICAgICAgICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcmFuZ2UgKyAoZyA8IGIpICogNjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyByYW5nZSArIDI7XG4gICAgICAgICAgICBlbHNlIGggPSAociAtIGcpIC8gcmFuZ2UgKyA0O1xuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCA9IE5hTjtcbiAgICAgICAgICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoID0gcyA9IGwgPSBOYU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCk7XG4gIH1cblxuICB2YXIgcmVIZXgzID0gL14jKFswLTlhLWZdezN9KSQvLFxuICAgICAgcmVIZXg2ID0gL14jKFswLTlhLWZdezZ9KSQvLFxuICAgICAgcmVSZ2JJbnRlZ2VyID0gL15yZ2JcXChcXHMqKFstK10/XFxkKylcXHMqLFxccyooWy0rXT9cXGQrKVxccyosXFxzKihbLStdP1xcZCspXFxzKlxcKSQvLFxuICAgICAgcmVSZ2JQZXJjZW50ID0gL15yZ2JcXChcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvLFxuICAgICAgcmVIc2xQZXJjZW50ID0gL15oc2xcXChcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPylcXHMqLFxccyooWy0rXT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWy0rXT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG5cbiAgdmFyIGNvbG9yID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdmFyIG07XG4gICAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAobSA9IHJlSGV4My5leGVjKGZvcm1hdCkpID8gKG0gPSBwYXJzZUludChtWzFdLCAxNiksIHJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweDBmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkpIC8vICNmMDBcbiAgICAgICAgOiAobSA9IHJlSGV4Ni5leGVjKGZvcm1hdCkpID8gcmdibihwYXJzZUludChtWzFdLCAxNikpIC8vICNmZjAwMDBcbiAgICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiKG1bMV0sIG1bMl0sIG1bM10pIC8vIHJnYigyNTUsMCwwKVxuICAgICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2IobVsxXSAqIDIuNTUsIG1bMl0gKiAyLjU1LCBtWzNdICogMi41NSkgLy8gcmdiKDEwMCUsMCUsMCUpXG4gICAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbChtWzFdLCBtWzJdICogLjAxLCBtWzNdICogLjAxKSAvLyBoc2woMTIwLDUwJSw1MCUpXG4gICAgICAgIDogbmFtZWQuaGFzKGZvcm1hdCkgPyByZ2JuKG5hbWVkLmdldChmb3JtYXQpKVxuICAgICAgICA6IG51bGw7XG4gIH0vLyBEb25lIGxhemlseSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gQ29sb3IsIFJnYiBhbmQgSHNsLlxuXG4gIGNvbG9yLnByb3RvdHlwZSA9IENvbG9yLnByb3RvdHlwZTtcbiAgcmdiLnByb3RvdHlwZSA9IFJnYi5wcm90b3R5cGU7XG4gIGhzbC5wcm90b3R5cGUgPSBIc2wucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIExhYihsLCBhLCBiKSB7XG4gICAgdGhpcy5sID0gK2w7XG4gICAgdGhpcy5hID0gK2E7XG4gICAgdGhpcy5iID0gK2I7XG4gIH1cblxuICB2YXIgX19fcHJvdG90eXBlID0gTGFiLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICB2YXIgS24gPSAxODtcblxuICBfX19wcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgS24gKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG5cbiAgX19fcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcblxuICBmdW5jdGlvbiB4eXoycmdiKHgpIHtcbiAgICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbiAgfVxuXG4gIHZhciBYbiA9IDAuOTUwNDcwLCAvLyBENjUgc3RhbmRhcmQgcmVmZXJlbnRcbiAgICAgIFluID0gMSxcbiAgICAgIFpuID0gMS4wODg4MzAsXG4gICAgICB0MCA9IDQgLyAyOSxcbiAgICAgIHQxID0gNiAvIDI5LFxuICAgICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG4gIGZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICAgIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xuICB9XG5cbiAgX19fcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIHh5ejJyZ2IoIDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIC8vIEQ2NSAtPiBzUkdCXG4gICAgICB4eXoycmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopLFxuICAgICAgeHl6MnJnYiggMC4wNTU2NDM0ICogeCAtIDAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KVxuICAgICk7XG4gIH07XG5cbiAgZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdiMnh5eih4KSB7XG4gICAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH1cblxuICB2YXIgZGVnMnJhZCA9IE1hdGguUEkgLyAxODA7XG5cbiAgZnVuY3Rpb24gSGNsKGgsIGMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLmMgPSArYztcbiAgICB0aGlzLmwgPSArbDtcbiAgfVxuXG4gIHZhciBfX19fcHJvdG90eXBlID0gSGNsLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfX19fcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLbiAqIChrID09IG51bGwgPyAxIDogaykpO1xuICB9O1xuXG4gIF9fX19wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogaykpO1xuICB9O1xuXG4gIF9fX19wcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhYih0aGlzKS5yZ2IoKTtcbiAgfTtcblxuICB2YXIgbGFiID0gZnVuY3Rpb24obCwgYSwgYikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobCBpbnN0YW5jZW9mIExhYikge1xuICAgICAgICBiID0gbC5iO1xuICAgICAgICBhID0gbC5hO1xuICAgICAgICBsID0gbC5sO1xuICAgICAgfSBlbHNlIGlmIChsIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgICAgIHZhciBoID0gbC5oICogZGVnMnJhZDtcbiAgICAgICAgYiA9IE1hdGguc2luKGgpICogbC5jO1xuICAgICAgICBhID0gTWF0aC5jb3MoaCkgKiBsLmM7XG4gICAgICAgIGwgPSBsLmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShsIGluc3RhbmNlb2YgUmdiKSkgbCA9IHJnYihsKTtcbiAgICAgICAgdmFyIHIgPSByZ2IyeHl6KGwuciksXG4gICAgICAgICAgICBnID0gcmdiMnh5eihsLmcpLFxuICAgICAgICAgICAgYiA9IHJnYjJ4eXoobC5iKSxcbiAgICAgICAgICAgIHggPSB4eXoybGFiKCgwLjQxMjQ1NjQgKiByICsgMC4zNTc1NzYxICogZyArIDAuMTgwNDM3NSAqIGIpIC8gWG4pLFxuICAgICAgICAgICAgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIHIgKyAwLjcxNTE1MjIgKiBnICsgMC4wNzIxNzUwICogYikgLyBZbiksXG4gICAgICAgICAgICB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogciArIDAuMTE5MTkyMCAqIGcgKyAwLjk1MDMwNDEgKiBiKSAvIFpuKTtcbiAgICAgICAgYiA9IDIwMCAqICh5IC0geik7XG4gICAgICAgIGEgPSA1MDAgKiAoeCAtIHkpO1xuICAgICAgICBsID0gMTE2ICogeSAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExhYihsLCBhLCBiKTtcbiAgfVxuICBsYWIucHJvdG90eXBlID0gTGFiLnByb3RvdHlwZTtcbiAgdmFyIHJhZDJkZWcgPSAxODAgLyBNYXRoLlBJO1xuXG4gIHZhciBoY2wgPSBmdW5jdGlvbihoLCBjLCBsKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChoIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgICAgIGwgPSBoLmw7XG4gICAgICAgIGMgPSBoLmM7XG4gICAgICAgIGggPSBoLmg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShoIGluc3RhbmNlb2YgTGFiKSkgaCA9IGxhYihoKTtcbiAgICAgICAgbCA9IGgubDtcbiAgICAgICAgYyA9IE1hdGguc3FydChoLmEgKiBoLmEgKyBoLmIgKiBoLmIpO1xuICAgICAgICBoID0gTWF0aC5hdGFuMihoLmIsIGguYSkgKiByYWQyZGVnO1xuICAgICAgICBpZiAoaCA8IDApIGggKz0gMzYwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEhjbChoLCBjLCBsKTtcbiAgfVxuICBoY2wucHJvdG90eXBlID0gSGNsLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCkge1xuICAgIHRoaXMuaCA9ICtoO1xuICAgIHRoaXMucyA9ICtzO1xuICAgIHRoaXMubCA9ICtsO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IEN1YmVoZWxpeC5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgdmFyIGdhbW1hID0gMSwgLy8gRGVmYXVsdCBnYW1tYS4gVE9ETyBDdXN0b21pemUuXG4gICAgICBBID0gLTAuMTQ4NjEsXG4gICAgICBCID0gKzEuNzgyNzcsXG4gICAgICBDID0gLTAuMjkyMjcsXG4gICAgICBEID0gLTAuOTA2NDksXG4gICAgICBFID0gKzEuOTcyOTQsXG4gICAgICBFRCA9IEUgKiBELFxuICAgICAgRUIgPSBFICogQixcbiAgICAgIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuICB2YXIgY3ViZWhlbGl4ID0gZnVuY3Rpb24oaCwgcywgbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaCBpbnN0YW5jZW9mIEN1YmVoZWxpeCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIFJnYikpIGggPSByZ2IoaCk7XG4gICAgICAgIHZhciByID0gaC5yIC8gMjU1LCBnID0gaC5nIC8gMjU1LCBiID0gaC5iIC8gMjU1O1xuICAgICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKTtcbiAgICAgICAgdmFyIGJsID0gYiAtIGwsIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRCwgbGdhbW1hID0gTWF0aC5wb3cobCwgZ2FtbWEpO1xuICAgICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGxnYW1tYSAqICgxIC0gbGdhbW1hKSk7IC8vIE5hTiBpZiBsZ2FtbWE9MCBvciBsZ2FtbWE9MVxuICAgICAgICBoID0gcyA/IE1hdGguYXRhbjIoaywgYmwpICogcmFkMmRlZyAtIDEyMCA6IE5hTjtcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCwgcywgbCk7XG4gIH1cblxuICBwcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcbiAgICAgICAgbCA9IE1hdGgucG93KHRoaXMubCwgZ2FtbWEpLFxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcbiAgICAgICAgY29zaCA9IE1hdGguY29zKGgpLFxuICAgICAgICBzaW5oID0gTWF0aC5zaW4oaCk7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICAyNTUgKiAobCArIGEgKiAoQSAqIGNvc2ggKyBCICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEMgKiBjb3NoICsgRCAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpXG4gICAgKTtcbiAgfTtcbiAgY3ViZWhlbGl4LnByb3RvdHlwZSA9IEN1YmVoZWxpeC5wcm90b3R5cGU7XG5cbiAgdmFyIGludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBhID0gY3ViZWhlbGl4KGEpO1xuICAgIGIgPSBjdWJlaGVsaXgoYik7XG4gICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgYXMgPSBpc05hTihhLnMpID8gYi5zIDogYS5zLFxuICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGIuaCAtIGFoLFxuICAgICAgICBicyA9IGlzTmFOKGIucykgPyAwIDogYi5zIC0gYXMsXG4gICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIHZhciBkZWx0YUh1ZSA9IGZ1bmN0aW9uKGgsIGgwKSB7XG4gICAgdmFyIGRlbHRhID0gKGggLSBoMCkgJSAzNjA7XG4gICAgcmV0dXJuIGRlbHRhICsgKGRlbHRhID4gMTgwID8gLTM2MCA6IGRlbHRhIDwgLTE4MCA/IDM2MCA6IDApO1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRlQ3ViZWhlbGl4ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGEgPSBjdWJlaGVsaXgoYSk7XG4gICAgYiA9IGN1YmVoZWxpeChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogZGVsdGFIdWUoYi5oLCBhaCksXG4gICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLnMgPSBhcyArIGJzICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdGVIY2xMb25nID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGEgPSBoY2woYSk7XG4gICAgYiA9IGhjbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhYyA9IGlzTmFOKGEuYykgPyBiLmMgOiBhLmMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogYi5oIC0gYWgsXG4gICAgICAgIGJjID0gaXNOYU4oYi5jKSA/IDAgOiBiLmMgLSBhYyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLmMgPSBhYyArIGJjICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdGVIY2wgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgYSA9IGhjbChhKTtcbiAgICBiID0gaGNsKGIpO1xuICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgIGFjID0gaXNOYU4oYS5jKSA/IGIuYyA6IGEuYyxcbiAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBkZWx0YUh1ZShiLmgsIGFoKSxcbiAgICAgICAgYmMgPSBpc05hTihiLmMpID8gMCA6IGIuYyAtIGFjLFxuICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgIGEuYyA9IGFjICsgYmMgKiB0O1xuICAgICAgYS5sID0gYWwgKyBibCAqIHQ7XG4gICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0ZUxhYiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBhID0gbGFiKGEpO1xuICAgIGIgPSBsYWIoYik7XG4gICAgdmFyIGFsID0gYS5sLFxuICAgICAgICBhYSA9IGEuYSxcbiAgICAgICAgYWIgPSBhLmIsXG4gICAgICAgIGJsID0gYi5sIC0gYWwsXG4gICAgICAgIGJhID0gYi5hIC0gYWEsXG4gICAgICAgIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgYS5hID0gYWEgKyBiYSAqIHQ7XG4gICAgICBhLmIgPSBhYiArIGJiICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRlSHNsTG9uZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBhID0gaHNsKGEpO1xuICAgIGIgPSBoc2woYik7XG4gICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgYXMgPSBpc05hTihhLnMpID8gYi5zIDogYS5zLFxuICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGIuaCAtIGFoLFxuICAgICAgICBicyA9IGlzTmFOKGIucykgPyAwIDogYi5zIC0gYXMsXG4gICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRlSHNsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGEgPSBoc2woYSk7XG4gICAgYiA9IGhzbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogZGVsdGFIdWUoYi5oLCBhaCksXG4gICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLnMgPSBhcyArIGJzICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdGVSZ2IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgYSA9IHJnYihhKTtcbiAgICBiID0gcmdiKGIpO1xuICAgIHZhciBhciA9IGEucixcbiAgICAgICAgYWcgPSBhLmcsXG4gICAgICAgIGFiID0gYS5iLFxuICAgICAgICBiciA9IGIuciAtIGFyLFxuICAgICAgICBiZyA9IGIuZyAtIGFnLFxuICAgICAgICBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZm9ybWF0KE1hdGgucm91bmQoYXIgKyBiciAqIHQpLCBNYXRoLnJvdW5kKGFnICsgYmcgKiB0KSwgTWF0aC5yb3VuZChhYiArIGJiICogdCkpO1xuICAgIH07XG4gIH1cblxuICBleHBvcnRzLmNvbG9yID0gY29sb3I7XG4gIGV4cG9ydHMucmdiID0gcmdiO1xuICBleHBvcnRzLmhzbCA9IGhzbDtcbiAgZXhwb3J0cy5sYWIgPSBsYWI7XG4gIGV4cG9ydHMuaGNsID0gaGNsO1xuICBleHBvcnRzLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYiA9IGludGVycG9sYXRlUmdiO1xuICBleHBvcnRzLmludGVycG9sYXRlSHNsID0gaW50ZXJwb2xhdGVIc2w7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIc2xMb25nID0gaW50ZXJwb2xhdGVIc2xMb25nO1xuICBleHBvcnRzLmludGVycG9sYXRlTGFiID0gaW50ZXJwb2xhdGVMYWI7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIY2wgPSBpbnRlcnBvbGF0ZUhjbDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbExvbmcgPSBpbnRlcnBvbGF0ZUhjbExvbmc7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXggPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmc7XG5cbn0pKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC5mb3JtYXQgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuXG4gIC8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbiAgLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4gIC8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuICBmdW5jdGlvbiBmb3JtYXREZWNpbWFsKHgsIHApIHtcbiAgICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gICAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAgIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gICAgcmV0dXJuIFtcbiAgICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgICAreC5zbGljZShpICsgMSlcbiAgICBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwb25lbnQoeCkge1xuICAgIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbChNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xuICB9XG5cbiAgdmFyIHByZWZpeEV4cG9uZW50O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeEF1dG8oeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBwICsgaSAtIDEpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3VuZGVkKHgsIHApIHtcbiAgICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gICAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICAgIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0KHgsIHApIHtcbiAgICB4ID0geC50b1ByZWNpc2lvbihwKTtcblxuICAgIG91dDogZm9yICh2YXIgbiA9IHgubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN3aXRjaCAoeFtpXSkge1xuICAgICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZVwiOiBicmVhayBvdXQ7XG4gICAgICAgIGRlZmF1bHQ6IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGkwID4gMCA/IHguc2xpY2UoMCwgaTApICsgeC5zbGljZShpMSArIDEpIDogeDtcbiAgfVxuXG4gIHZhciBmb3JtYXRUeXBlcyA9IHtcbiAgICBcIlwiOiBmb3JtYXREZWZhdWx0LFxuICAgIFwiJVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiAoeCAqIDEwMCkudG9GaXhlZChwKTsgfSxcbiAgICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgICBcImNcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4geCArIFwiXCI7IH0sXG4gICAgXCJkXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTApOyB9LFxuICAgIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gICAgXCJmXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9GaXhlZChwKTsgfSxcbiAgICBcImdcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b1ByZWNpc2lvbihwKTsgfSxcbiAgICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgICBcInBcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKTsgfSxcbiAgICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgICBcIlhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfSxcbiAgICBcInhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNik7IH1cbiAgfTtcblxuXG4gIC8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bdHlwZV1cbiAgdmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLVxcKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyhbYS16JV0pPyQvaTtcblxuICBmdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuXG4gICAgdmFyIG1hdGNoLFxuICAgICAgICBmaWxsID0gbWF0Y2hbMV0gfHwgXCIgXCIsXG4gICAgICAgIGFsaWduID0gbWF0Y2hbMl0gfHwgXCI+XCIsXG4gICAgICAgIHNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIixcbiAgICAgICAgc3ltYm9sID0gbWF0Y2hbNF0gfHwgXCJcIixcbiAgICAgICAgemVybyA9ICEhbWF0Y2hbNV0sXG4gICAgICAgIHdpZHRoID0gbWF0Y2hbNl0gJiYgK21hdGNoWzZdLFxuICAgICAgICBjb21tYSA9ICEhbWF0Y2hbN10sXG4gICAgICAgIHByZWNpc2lvbiA9IG1hdGNoWzhdICYmICttYXRjaFs4XS5zbGljZSgxKSxcbiAgICAgICAgdHlwZSA9IG1hdGNoWzldIHx8IFwiXCI7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBNYXAgaW52YWxpZCB0eXBlcyB0byB0aGUgZGVmYXVsdCBmb3JtYXQuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSB0eXBlID0gXCJcIjtcblxuICAgIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xuXG4gICAgdGhpcy5maWxsID0gZmlsbDtcbiAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgdGhpcy5zaWduID0gc2lnbjtcbiAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICB0aGlzLnplcm8gPSB6ZXJvO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmNvbW1hID0gY29tbWE7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIEZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXG4gICAgICAgICsgdGhpcy5hbGlnblxuICAgICAgICArIHRoaXMuc2lnblxuICAgICAgICArIHRoaXMuc3ltYm9sXG4gICAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICAgKyAodGhpcy53aWR0aCA9PSBudWxsID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT0gbnVsbCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICAgICsgdGhpcy50eXBlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIHQgPSBbXSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbGVGb3JtYXQobG9jYWxlKSB7XG4gICAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nICYmIGxvY2FsZS50aG91c2FuZHMgPyBmb3JtYXRHcm91cChsb2NhbGUuZ3JvdXBpbmcsIGxvY2FsZS50aG91c2FuZHMpIDogaWRlbnRpdHksXG4gICAgICAgIGN1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LFxuICAgICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWw7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzBdIDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVsxXSA6IC9bJXBdLy50ZXN0KHR5cGUpID8gXCIlXCIgOiBcIlwiO1xuXG4gICAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgICBtYXliZVN1ZmZpeCA9ICF0eXBlIHx8IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAodHlwZSA/IDYgOiAxMilcbiAgICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4O1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG5lZ2F0aXZlIHRvIHBvc2l0aXZlLCBhbmQgY29tcHV0ZSB0aGUgcHJlZml4LlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCAtMCBpcyBub3QgbGVzcyB0aGFuIDAsIGJ1dCAxIC8gLTAgaXMhXG4gICAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSAodmFsdWUgPCAwIHx8IDEgLyB2YWx1ZSA8IDApICYmICh2YWx1ZSAqPSAtMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgICAgdmFsdWUgPSBmb3JtYXRUeXBlKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBcIi1cIikgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICAgIHZhbHVlU3VmZml4ID0gdmFsdWVTdWZmaXggKyAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGgsIGM7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7XG4gICAgICAgICAgY2FzZSBcIj1cIjogcmV0dXJuIHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgY2FzZSBcIl5cIjogcmV0dXJuIHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgICB2YXIgZiA9IGZvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgICBrID0gTWF0aC5wb3coMTAsIC1lKSxcbiAgICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmKGsgKiB2YWx1ZSkgKyBwcmVmaXg7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gICAgfTtcbiAgfVxuXG4gIHZhciBsb2NhbGUgPSBsb2NhbGVGb3JtYXQoe1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxuICB9KTtcblxuICBleHBvcnRzLmZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMuZm9ybWF0UHJlZml4ID0gbG9jYWxlLmZvcm1hdFByZWZpeDtcblxuICBmdW5jdGlvbiBwcmVjaXNpb25Sb3VuZChzdGVwLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQoTWF0aC5hYnMobWF4KSkgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgZXhwb3J0cy5mb3JtYXRTcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXI7XG4gIGV4cG9ydHMubG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0O1xuICBleHBvcnRzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XG4gIGV4cG9ydHMucHJlY2lzaW9uUHJlZml4ID0gcHJlY2lzaW9uUHJlZml4O1xuICBleHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbn0pKTsiLCJpZiAodHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBNYXAgPSBmdW5jdGlvbigpIHsgdGhpcy5jbGVhcigpOyB9O1xuICBNYXAucHJvdG90eXBlID0ge1xuICAgIHNldDogZnVuY3Rpb24oaywgdikgeyB0aGlzLl9ba10gPSB2OyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuX1trXTsgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIGsgaW4gdGhpcy5fOyB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl8gJiYgZGVsZXRlIHRoaXMuX1trXTsgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7IHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH0sXG4gICAgZ2V0IHNpemUoKSB7IHZhciBuID0gMDsgZm9yICh2YXIgayBpbiB0aGlzLl8pICsrbjsgcmV0dXJuIG47IH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oYykgeyBmb3IgKHZhciBrIGluIHRoaXMuXykgYyh0aGlzLl9ba10sIGssIHRoaXMpOyB9XG4gIH07XG59IGVsc2UgKGZ1bmN0aW9uKCkge1xuICB2YXIgbSA9IG5ldyBNYXA7XG4gIGlmIChtLnNldCgwLCAwKSAhPT0gbSkge1xuICAgIG0gPSBtLnNldDtcbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkgeyBtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiB0aGlzOyB9O1xuICB9XG59KSgpO1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC50aW1lRm9ybWF0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICAgIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbERhdGUoZCkge1xuICAgIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xuICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnkpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xuICB9XG5cbiAgdmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifTtcblxuICBmdW5jdGlvbiBuZXdZZWFyKHkpIHtcbiAgICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xuICB9XG5cbiAgdmFyIHBlcmNlbnRSZSA9IC9eJS87XG5cbiAgZnVuY3Rpb24gcGFyc2VMaXRlcmFsUGVyY2VudChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIC9eWystXVxcZHs0fSQvLnRlc3Qoc3RyaW5nID0gc3RyaW5nLnNsaWNlKGksIGkgKyA1KSlcbiAgICAgICAgPyAoZC5aID0gLXN0cmluZywgaSArIDUpIC8vIHNpZ24gZGlmZmVycyBmcm9tIGdldFRpbWV6b25lT2Zmc2V0IVxuICAgICAgICA6IC0xO1xuICB9XG5cbiAgdmFyIG51bWJlclJlID0gL15cXHMqXFxkKy87XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnVsbFllYXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICAgIHJldHVybiBuID8gKGQueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgICByZXR1cm4gXCIlXCI7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICAgIHJldHVybiBcIiswMDAwXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xuICB9XG5cbiAgdmFyIHQxID0gbmV3IERhdGU7XG5cbiAgdmFyIHQwID0gbmV3IERhdGU7XG5cbiAgZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCkge1xuXG4gICAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgICB9XG5cbiAgICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gICAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBuZXcgRGF0ZSgrZGF0ZSksXG4gICAgICAgICAgZDEgPSBuZXcgRGF0ZShkYXRlIC0gMSk7XG4gICAgICBmbG9vcmkoZDApLCBmbG9vcmkoZDEpLCBvZmZzZXRpKGQxLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHN0YXJ0ID0gbmV3IERhdGUoc3RhcnQgLSAxKTtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZSgrc3RvcCk7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICAgIG9mZnNldGkoc3RhcnQsIDEpLCBmbG9vcmkoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHdoaWxlIChvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KSwgc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgICAgd2hpbGUgKC0tc3RlcCA+PSAwKSB3aGlsZSAob2Zmc2V0aShkYXRlLCAxKSwgIXRlc3QoZGF0ZSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjb3VudCkgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIHZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgb2Zmc2V0ICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHV0Y01vbmRheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXkoKTtcbiAgfVxuXG4gIHZhciB1dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQodXRjU3VuZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1NlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENTZWNvbmRzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01pbnV0ZXMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aE51bWJlcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgfVxuXG4gIHZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCgxICsgdXRjRGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gICAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgcmV0dXJuICh6ID4gMCA/IFwiLVwiIDogKHogKj0gLTEsIFwiK1wiKSlcbiAgICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICAgICsgcGFkKHogJSA2MCwgXCIwXCIsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RnVsbFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xuICB9XG5cbiAgdmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xuICB9KTtcblxuICBmdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChtb25kYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gIH1cblxuICB2YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHN1bmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0U2Vjb25kcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TW9udGhOdW1iZXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gIH1cblxuICB2YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdERheU9mWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCgxICsgZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdERheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAsIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgbWFwLnNldChuYW1lc1tpXS50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdmFyIHJlcXVvdGVSZSA9IC9bXFxcXFxcXlxcJFxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxcLlxce1xcfV0vZztcblxuICBmdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsZUZvcm1hdChsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgICBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLFxuICAgICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgICAgbG9jYWxlX3Nob3J0V2Vla2RheXMgPSBsb2NhbGUuc2hvcnREYXlzLFxuICAgICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gICAgdmFyIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICAgIHdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIHNob3J0V2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydE1vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgXCJhXCI6IGZvcm1hdFNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgICBcIkJcIjogZm9ybWF0TW9udGgsXG4gICAgICBcImNcIjogbnVsbCxcbiAgICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgICBcIlVcIjogZm9ybWF0V2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogbnVsbCxcbiAgICAgIFwiWFwiOiBudWxsLFxuICAgICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgICBcIllcIjogZm9ybWF0RnVsbFllYXIsXG4gICAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcbiAgICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgICAgXCJjXCI6IG51bGwsXG4gICAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICAgIFwiSVwiOiBmb3JtYXRVVENIb3VyMTIsXG4gICAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBmb3JtYXRVVENNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxuICAgICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IG51bGwsXG4gICAgICBcIlhcIjogbnVsbCxcbiAgICAgIFwieVwiOiBmb3JtYXRVVENZZWFyLFxuICAgICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgICAgXCJaXCI6IGZvcm1hdFVUQ1pvbmUsXG4gICAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlcyA9IHtcbiAgICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgICBcImJcIjogcGFyc2VTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IHBhcnNlTW9udGgsXG4gICAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICAgIFwiZFwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJJXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgICAgXCJTXCI6IHBhcnNlU2Vjb25kcyxcbiAgICAgIFwiVVwiOiBwYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICAgIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gICAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gICAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBwYWQsXG4gICAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkID09IG51bGwgPyAoYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiKSA6IHBhZCk7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgbmV3RGF0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgZCA9IG5ld1llYXIoMTkwMCksXG4gICAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgICAvLyBJZiBhIHRpbWUgem9uZSBpcyBzcGVjaWZpZWQsIGFsbCBmaWVsZHMgYXJlIGludGVycHJldGVkIGFzIFVUQyBhbmQgdGhlblxuICAgICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgICB2YXIgZGF5ID0gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgaWYgKFwiV1wiIGluIGQpIGQuVSA9IGQuVywgZC53ID0gKGQudyArIDYpICUgNywgLS1kYXk7XG4gICAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgICAgZC5kID0gZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQuSCArPSBkLlogLyAxMDAgfCAwO1xuICAgICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgdmFyIGRheSA9IG5ld0RhdGUobmV3WWVhcihkLnkpKS5nZXREYXkoKTtcbiAgICAgICAgICBpZiAoXCJXXCIgaW4gZCkgZC5VID0gZC5XLCBkLncgPSAoZC53ICsgNikgJSA3LCAtLWRheTtcbiAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgIGQuZCA9IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRlKGQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFyc2U7XG5cbiAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gc2hvcnRXZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gd2Vla2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQubSA9IG1vbnRoTG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gcGVyaW9kTG9va3VwLmdldChzdHJpbmcuc2xpY2UoaSwgaSArPSAyKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBuID09IG51bGwgPyAtMSA6IChkLnAgPSBuLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgICBmLnBhcnNlID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCBsb2NhbERhdGUpO1xuICAgICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCB1dGNGb3JtYXRzKTtcbiAgICAgICAgZi5wYXJzZSA9IG5ld1BhcnNlKHNwZWNpZmllciwgdXRjRGF0ZSk7XG4gICAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBsb2NhbGUgPSBsb2NhbGVGb3JtYXQoe1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9KTtcblxuICBleHBvcnRzLmZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMudXRjRm9ybWF0ID0gbG9jYWxlLnV0Y0Zvcm1hdDtcblxuICB2YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuICBmdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gIH1cblxuICBmb3JtYXRJc29OYXRpdmUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG4gIH07XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzb1NwZWNpZmllcjtcbiAgfTtcblxuICB2YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpXG4gICAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgICAgOiBsb2NhbGUudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XG5cbiAgdmFyIGlzb0Zvcm1hdCA9IGZvcm1hdElzbztcblxuICBleHBvcnRzLmlzb0Zvcm1hdCA9IGlzb0Zvcm1hdDtcbiAgZXhwb3J0cy5sb2NhbGVGb3JtYXQgPSBsb2NhbGVGb3JtYXQ7XG5cbn0pKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC50aW1lID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB0MSA9IG5ldyBEYXRlO1xuXG4gIHZhciB0MCA9IG5ldyBEYXRlO1xuXG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQpIHtcblxuICAgIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gICAgfVxuXG4gICAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICAgIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbmV3IERhdGUoK2RhdGUpLFxuICAgICAgICAgIGQxID0gbmV3IERhdGUoZGF0ZSAtIDEpO1xuICAgICAgZmxvb3JpKGQwKSwgZmxvb3JpKGQxKSwgb2Zmc2V0aShkMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0IC0gMSk7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0b3ApO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgICBvZmZzZXRpKHN0YXJ0LCAxKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICAgIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY291bnQpIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICB2YXIgc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDFlMztcbiAgfSk7XG5cbiAgZXhwb3J0cy5zZWNvbmRzID0gc2Vjb25kLnJhbmdlO1xuXG4gIHZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRTZWNvbmRzKDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDZlNDtcbiAgfSk7XG5cbiAgZXhwb3J0cy5taW51dGVzID0gbWludXRlLnJhbmdlO1xuXG4gIHZhciBob3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0TWludXRlcygwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMzZlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy5ob3VycyA9IGhvdXIucmFuZ2U7XG5cbiAgdmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMuZGF5cyA9IGRheS5yYW5nZTtcblxuICBmdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLnN1bmRheSA9IHdlZWtkYXkoMCk7XG5cbiAgZXhwb3J0cy5zdW5kYXlzID0gZXhwb3J0cy5zdW5kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy5tb25kYXkgPSB3ZWVrZGF5KDEpO1xuXG4gIGV4cG9ydHMubW9uZGF5cyA9IGV4cG9ydHMubW9uZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudHVlc2RheSA9IHdlZWtkYXkoMik7XG5cbiAgZXhwb3J0cy50dWVzZGF5cyA9IGV4cG9ydHMudHVlc2RheS5yYW5nZTtcblxuICBleHBvcnRzLndlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG5cbiAgZXhwb3J0cy53ZWRuZXNkYXlzID0gZXhwb3J0cy53ZWRuZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy50aHVyc2RheSA9IHdlZWtkYXkoNCk7XG5cbiAgZXhwb3J0cy50aHVyc2RheXMgPSBleHBvcnRzLnRodXJzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMuZnJpZGF5ID0gd2Vla2RheSg1KTtcblxuICBleHBvcnRzLmZyaWRheXMgPSBleHBvcnRzLmZyaWRheS5yYW5nZTtcblxuICBleHBvcnRzLnNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxuICBleHBvcnRzLnNhdHVyZGF5cyA9IGV4cG9ydHMuc2F0dXJkYXkucmFuZ2U7XG5cbiAgdmFyIHdlZWsgPSBleHBvcnRzLnN1bmRheTtcblxuICBleHBvcnRzLndlZWtzID0gd2Vlay5yYW5nZTtcblxuICB2YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG4gIH0pO1xuXG4gIGV4cG9ydHMubW9udGhzID0gbW9udGgucmFuZ2U7XG5cbiAgdmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGV4cG9ydHMueWVhcnMgPSB5ZWFyLnJhbmdlO1xuXG4gIHZhciB1dGNTZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y1NlY29uZHMgPSB1dGNTZWNvbmQucmFuZ2U7XG5cbiAgdmFyIHV0Y01pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ1NlY29uZHMoMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNmU0O1xuICB9KTtcblxuICBleHBvcnRzLnV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cbiAgdmFyIHV0Y0hvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENNaW51dGVzKDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAzNmU1O1xuICB9KTtcblxuICBleHBvcnRzLnV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcblxuICB2YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcblxuICBmdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIChkYXRlLmdldFVUQ0RheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy51dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xuXG4gIGV4cG9ydHMudXRjU3VuZGF5cyA9IGV4cG9ydHMudXRjU3VuZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcblxuICBleHBvcnRzLnV0Y01vbmRheXMgPSBleHBvcnRzLnV0Y01vbmRheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xuXG4gIGV4cG9ydHMudXRjVHVlc2RheXMgPSBleHBvcnRzLnV0Y1R1ZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xuXG4gIGV4cG9ydHMudXRjV2VkbmVzZGF5cyA9IGV4cG9ydHMudXRjV2VkbmVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjVGh1cnNkYXkgPSB1dGNXZWVrZGF5KDQpO1xuXG4gIGV4cG9ydHMudXRjVGh1cnNkYXlzID0gZXhwb3J0cy51dGNUaHVyc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG5cbiAgZXhwb3J0cy51dGNGcmlkYXlzID0gZXhwb3J0cy51dGNGcmlkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNTYXR1cmRheSA9IHV0Y1dlZWtkYXkoNik7XG5cbiAgZXhwb3J0cy51dGNTYXR1cmRheXMgPSBleHBvcnRzLnV0Y1NhdHVyZGF5LnJhbmdlO1xuXG4gIHZhciB1dGNXZWVrID0gZXhwb3J0cy51dGNTdW5kYXk7XG5cbiAgZXhwb3J0cy51dGNXZWVrcyA9IHV0Y1dlZWsucmFuZ2U7XG5cbiAgdmFyIHV0Y01vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDTW9udGgoKSAtIHN0YXJ0LmdldFVUQ01vbnRoKCkgKyAoZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpKSAqIDEyO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuXG4gIHZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y1llYXJzID0gdXRjWWVhci5yYW5nZTtcblxuICBleHBvcnRzLmludGVydmFsID0gbmV3SW50ZXJ2YWw7XG4gIGV4cG9ydHMuc2Vjb25kID0gc2Vjb25kO1xuICBleHBvcnRzLm1pbnV0ZSA9IG1pbnV0ZTtcbiAgZXhwb3J0cy5ob3VyID0gaG91cjtcbiAgZXhwb3J0cy5kYXkgPSBkYXk7XG4gIGV4cG9ydHMud2VlayA9IHdlZWs7XG4gIGV4cG9ydHMubW9udGggPSBtb250aDtcbiAgZXhwb3J0cy55ZWFyID0geWVhcjtcbiAgZXhwb3J0cy51dGNTZWNvbmQgPSB1dGNTZWNvbmQ7XG4gIGV4cG9ydHMudXRjTWludXRlID0gdXRjTWludXRlO1xuICBleHBvcnRzLnV0Y0hvdXIgPSB1dGNIb3VyO1xuICBleHBvcnRzLnV0Y0RheSA9IHV0Y0RheTtcbiAgZXhwb3J0cy51dGNXZWVrID0gdXRjV2VlaztcbiAgZXhwb3J0cy51dGNNb250aCA9IHV0Y01vbnRoO1xuICBleHBvcnRzLnV0Y1llYXIgPSB1dGNZZWFyO1xuXG59KSk7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgdGltZSA9IHJlcXVpcmUoJy4uL3RpbWUnKSxcbiAgICBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbnMob3B0KSB7XG4gIGlmICghb3B0KSB7IHRocm93IEVycm9yKFwiTWlzc2luZyBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSwgICAgICBcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcbiAgICBcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHsgc3RlcCAqPSBiYXNlOyB9IHdoaWxlIChNYXRoLmNlaWwoc3Bhbi9zdGVwKSA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGk9MDsgaTxkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuICB2ID0gTWF0aC5sb2coc3RlcCk7XG4gIHByZWNpc2lvbiA9IHYgPj0gMCA/IDAgOiB+figtdiAvIGxvZ2IpICsgMTtcbiAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogIG1heCxcbiAgICBzdGVwOiAgc3RlcCxcbiAgICB1bml0OiAge3ByZWNpc2lvbjogcHJlY2lzaW9ufSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpc2VjdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHYgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgodikge1xuICByZXR1cm4gTWF0aC5mbG9vcigodiAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGRhdGVfdmFsdWUodikge1xuICByZXR1cm4gdGhpcy51bml0LmRhdGUodmFsdWUuY2FsbCh0aGlzLCB2KSk7XG59XG5cbmZ1bmN0aW9uIGRhdGVfaW5kZXgodikge1xuICByZXR1cm4gaW5kZXguY2FsbCh0aGlzLCB0aGlzLnVuaXQudW5pdCh2KSk7XG59XG5cbmJpbnMuZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBpZiAoIW9wdCkgeyB0aHJvdyBFcnJvcihcIk1pc3NpbmcgZGF0ZSBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZmluZCB0aW1lIHN0ZXAsIHRoZW4gYmluXG4gIHZhciB1bml0cyA9IG9wdC51dGMgPyB0aW1lLnV0YyA6IHRpbWUsXG4gICAgICBkbWluID0gb3B0Lm1pbixcbiAgICAgIGRtYXggPSBvcHQubWF4LFxuICAgICAgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDIwLFxuICAgICAgbWluYiA9IG9wdC5taW5iaW5zIHx8IDQsXG4gICAgICBzcGFuID0gKCtkbWF4KSAtICgrZG1pbiksXG4gICAgICB1bml0ID0gb3B0LnVuaXQgPyB1bml0c1tvcHQudW5pdF0gOiB1bml0cy5maW5kKHNwYW4sIG1pbmIsIG1heGIpLFxuICAgICAgc3BlYyA9IGJpbnMoe1xuICAgICAgICBtaW46ICAgICB1bml0Lm1pbiAhPSBudWxsID8gdW5pdC5taW4gOiB1bml0LnVuaXQoZG1pbiksXG4gICAgICAgIG1heDogICAgIHVuaXQubWF4ICE9IG51bGwgPyB1bml0Lm1heCA6IHVuaXQudW5pdChkbWF4KSxcbiAgICAgICAgbWF4YmluczogbWF4YixcbiAgICAgICAgbWluc3RlcDogdW5pdC5taW5zdGVwLFxuICAgICAgICBzdGVwczogICB1bml0LnN0ZXBcbiAgICAgIH0pO1xuXG4gIHNwZWMudW5pdCA9IHVuaXQ7XG4gIHNwZWMuaW5kZXggPSBkYXRlX2luZGV4O1xuICBpZiAoIW9wdC5yYXcpIHNwZWMudmFsdWUgPSBkYXRlX3ZhbHVlO1xuICByZXR1cm4gc3BlYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmlucztcbiIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSBtaW4gPT09IHVuZGVmaW5lZCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYiA9IGE7XG4gICAgYSA9IDA7XG4gIH1cbiAgdmFyIGQgPSBiIC0gYTtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiB8fCAxO1xuICB2YXIgbmV4dDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG4gICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeCA9IG5leHQ7XG4gICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIHggPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHJkcyA9IHgqeCArIHkqeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG4gICAgYyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgbmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG4gICAgcmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIFRZUEVTID0gJ19fdHlwZXNfXyc7XG5cbnZhciBQQVJTRVJTID0ge1xuICBib29sZWFuOiB1dGlsLmJvb2xlYW4sXG4gIGludGVnZXI6IHV0aWwubnVtYmVyLFxuICBudW1iZXI6ICB1dGlsLm51bWJlcixcbiAgZGF0ZTogICAgdXRpbC5kYXRlLFxuICBzdHJpbmc6ICBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09JycgPyBudWxsIDogeDsgfVxufTtcblxudmFyIFRFU1RTID0ge1xuICBib29sZWFuOiBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09J3RydWUnIHx8IHg9PT0nZmFsc2UnIHx8IHV0aWwuaXNCb29sZWFuKHgpOyB9LFxuICBpbnRlZ2VyOiBmdW5jdGlvbih4KSB7IHJldHVybiBURVNUUy5udW1iZXIoeCkgJiYgKHg9K3gpID09PSB+fng7IH0sXG4gIG51bWJlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKCt4KSAmJiAhdXRpbC5pc0RhdGUoeCk7IH0sXG4gIGRhdGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHgpKTsgfVxufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbihkYXRhLCB0eXBlcykge1xuICBpZiAoIXR5cGVzKSByZXR1cm4gZGF0YSAmJiBkYXRhW1RZUEVTXSB8fCBudWxsO1xuICBkYXRhW1RZUEVTXSA9IHR5cGVzO1xufVxuXG5mdW5jdGlvbiB0eXBlKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbjtcblxuICAvLyBpZiBkYXRhIGFycmF5IGhhcyB0eXBlIGFubm90YXRpb25zLCB1c2UgdGhlbVxuICBpZiAodmFsdWVzW1RZUEVTXSkge1xuICAgIHYgPSBmKHZhbHVlc1tUWVBFU10pO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHYpKSByZXR1cm4gdjtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7ICF1dGlsLmlzVmFsaWQodikgJiYgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiB1dGlsLmlzRGF0ZSh2KSA/ICdkYXRlJyA6XG4gICAgdXRpbC5pc051bWJlcih2KSAgICA/ICdudW1iZXInIDpcbiAgICB1dGlsLmlzQm9vbGVhbih2KSAgID8gJ2Jvb2xlYW4nIDpcbiAgICB1dGlsLmlzU3RyaW5nKHYpICAgID8gJ3N0cmluZycgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0eXBlQWxsKGRhdGEsIGZpZWxkcykge1xuICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm47XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgcmV0dXJuICh0eXBlc1tmXSA9IHR5cGUoZGF0YSwgZiksIHR5cGVzKTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBpbmZlcih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIGosIHY7XG5cbiAgLy8gdHlwZXMgdG8gdGVzdCBmb3IsIGluIHByZWNlZGVuY2Ugb3JkZXJcbiAgdmFyIHR5cGVzID0gWydib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJywgJ2RhdGUnXTtcblxuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgbmV4dCB2YWx1ZSB0byB0ZXN0XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgLy8gdGVzdCB2YWx1ZSBhZ2FpbnN0IHJlbWFpbmluZyB0eXBlc1xuICAgIGZvciAoaj0wOyBqPHR5cGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAodXRpbC5pc1ZhbGlkKHYpICYmICFURVNUU1t0eXBlc1tqXV0odikpIHtcbiAgICAgICAgdHlwZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICBqIC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vIHR5cGVzIGxlZnQsIHJldHVybiAnc3RyaW5nJ1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDApIHJldHVybiAnc3RyaW5nJztcbiAgfVxuXG4gIHJldHVybiB0eXBlc1swXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgdHlwZXNbZl0gPSBpbmZlcihkYXRhLCBmKTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH0sIHt9KTtcbn1cblxudHlwZS5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbjtcbnR5cGUuYWxsID0gdHlwZUFsbDtcbnR5cGUuaW5mZXIgPSBpbmZlcjtcbnR5cGUuaW5mZXJBbGwgPSBpbmZlckFsbDtcbnR5cGUucGFyc2VycyA9IFBBUlNFUlM7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGU7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKTtcbnZhciBzdGF0cyA9IHt9O1xuXG4vLyBDb2xsZWN0IHVuaXF1ZSB2YWx1ZXMuXG4vLyBPdXRwdXQ6IGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIGZpcnN0LW9ic2VydmVkIG9yZGVyXG5zdGF0cy51bmlxdWUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHJlc3VsdHMpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIHZhciB1ID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgcmVzdWx0cy5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IGFycmF5Llxuc3RhdHMuY291bnQgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoIHx8IDA7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG5vbi1udWxsLCBub24tdW5kZWZpbmVkLCBub24tTmFOIHZhbHVlcy5cbnN0YXRzLmNvdW50LnZhbGlkID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCB2YWxpZCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgdmFsaWQgKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcy5cbnN0YXRzLmNvdW50Lm1pc3NpbmcgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiA9PSBudWxsKSBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgZGlzdGluY3QgdmFsdWVzLlxuLy8gTnVsbCwgdW5kZWZpbmVkIGFuZCBOYU4gYXJlIGVhY2ggY29uc2lkZXJlZCBkaXN0aW5jdCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5kaXN0aW5jdCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb25zdHJ1Y3QgYSBtYXAgZnJvbSBkaXN0aW5jdCB2YWx1ZXMgdG8gb2NjdXJyZW5jZSBjb3VudHMuXG5zdGF0cy5jb3VudC5tYXAgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1hcCA9IHt9LCB2LCBpLCBuO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIG1hcFt2XSA9ICh2IGluIG1hcCkgPyBtYXBbdl0gKyAxIDogMTtcbiAgfVxuICByZXR1cm4gbWFwO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICByZXR1cm4gc3RhdHMucXVhbnRpbGUodmFsdWVzLCAwLjUpO1xufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHF1YXJ0aWxlIGJvdW5kYXJpZXMgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnF1YXJ0aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgdmFyIHEgPSBzdGF0cy5xdWFudGlsZTtcbiAgcmV0dXJuIFtxKHZhbHVlcywgMC4yNSksIHEodmFsdWVzLCAwLjUwKSwgcSh2YWx1ZXMsIDAuNzUpXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHF1YW50aWxlIG9mIGEgc29ydGVkIGFycmF5IG9mIG51bWJlcnMuXG4vLyBBZGFwdGVkIGZyb20gdGhlIEQzLmpzIGltcGxlbWVudGF0aW9uLlxuc3RhdHMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHApIHtcbiAgaWYgKHAgPT09IHVuZGVmaW5lZCkgeyBwID0gZjsgZiA9IHV0aWwuaWRlbnRpdHk7IH1cbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsXG4gICAgICBoID0gTWF0aC5mbG9vcihIKSxcbiAgICAgIHYgPSArZih2YWx1ZXNbaCAtIDFdKSxcbiAgICAgIGUgPSBIIC0gaDtcbiAgcmV0dXJuIGUgPyB2ICsgZSAqIChmKHZhbHVlc1toXSkgLSB2KSA6IHY7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzdW0gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN1bSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBmb3IgKHZhciBzdW09MCwgaT0wLCBuPXZhbHVlcy5sZW5ndGgsIHY7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgc3VtICs9IHY7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lYW4gKGF2ZXJhZ2UpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtZWFuID0gMCwgZGVsdGEsIGksIG4sIGMsIHY7XG4gIGZvciAoaT0wLCBjPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVhbjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSB2YXJpYW5jZSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMudmFyaWFuY2UgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gIHZhciBtZWFuID0gMCwgTTIgPSAwLCBkZWx0YSwgaSwgYywgdjtcbiAgZm9yIChpPTAsIGM9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHYgLSBtZWFuKTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvIChjIC0gMSk7XG4gIHJldHVybiBNMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN0ZGV2ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3RhdHMudmFyaWFuY2UodmFsdWVzLCBmKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBQZWFyc29uIG1vZGUgc2tld25lc3MgKChtZWRpYW4tbWVhbikvc3RkZXYpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tb2Rlc2tldyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgYXZnID0gc3RhdHMubWVhbih2YWx1ZXMsIGYpLFxuICAgICAgbWVkID0gc3RhdHMubWVkaWFuKHZhbHVlcywgZiksXG4gICAgICBzdGQgPSBzdGF0cy5zdGRldih2YWx1ZXMsIGYpO1xuICByZXR1cm4gc3RkID09PSAwID8gMCA6IChhdmcgLSBtZWQpIC8gc3RkO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSB2YWx1ZSBpbiBhbiBhcnJheS5cbnN0YXRzLm1pbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gc3RhdHMuZXh0ZW50KHZhbHVlcywgZilbMF07XG59O1xuXG4vLyBGaW5kIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWF4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVsxXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gb2YgYW4gYXJyYXkgb2YgdmFsdWVzLlxuc3RhdHMuZXh0ZW50ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPCBhKSBhID0gdjtcbiAgICAgIGlmICh2ID4gYikgYiA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYSwgYl07XG59O1xuXG4vLyBGaW5kIHRoZSBpbnRlZ2VyIGluZGljZXMgb2YgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzLlxuc3RhdHMuZXh0ZW50LmluZGV4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB4ID0gLTEsIHkgPSAtMSwgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHsgYSA9IGIgPSB2OyB4ID0geSA9IGk7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPCBhKSB7IGEgPSB2OyB4ID0gaTsgfVxuICAgICAgaWYgKHYgPiBiKSB7IGIgPSB2OyB5ID0gaTsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW3gsIHldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuZG90ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBzdW0gPSAwLCBpLCB2O1xuICBpZiAoIWIpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKCdBcnJheSBsZW5ndGhzIG11c3QgbWF0Y2guJyk7XG4gICAgfVxuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHZhbHVlc1tpXSAqIGFbaV07XG4gICAgICBpZiAodiA9PT0gdikgc3VtICs9IHY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBhKHZhbHVlc1tpXSkgKiBiKHZhbHVlc1tpXSk7XG4gICAgICBpZiAodiA9PT0gdikgc3VtICs9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIGFzY2VuZGluZyByYW5rIHNjb3JlcyBmb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuLy8gVGllcyBhcmUgYXNzaWduZWQgdGhlaXIgY29sbGVjdGl2ZSBtZWFuIHJhbmsuXG5zdGF0cy5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZikgfHwgdXRpbC5pZGVudGl0eTtcbiAgdmFyIGEgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHJldHVybiB7aWR4OiBpLCB2YWw6IGYodil9O1xuICAgIH0pXG4gICAgLnNvcnQodXRpbC5jb21wYXJhdG9yKCd2YWwnKSk7XG5cbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgciA9IEFycmF5KG4pLFxuICAgICAgdGllID0gLTEsIHAgPSB7fSwgaSwgdiwgbXU7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGFbaV0udmFsO1xuICAgIGlmICh0aWUgPCAwICYmIHAgPT09IHYpIHtcbiAgICAgIHRpZSA9IGkgLSAxO1xuICAgIH0gZWxzZSBpZiAodGllID4gLTEgJiYgcCAhPT0gdikge1xuICAgICAgbXUgPSAxICsgKGktMSArIHRpZSkgLyAyO1xuICAgICAgZm9yICg7IHRpZTxpOyArK3RpZSkgclthW3RpZV0uaWR4XSA9IG11O1xuICAgICAgdGllID0gLTE7XG4gICAgfVxuICAgIHJbYVtpXS5pZHhdID0gaSArIDE7XG4gICAgcCA9IHY7XG4gIH1cblxuICBpZiAodGllID4gLTEpIHtcbiAgICBtdSA9IDEgKyAobi0xICsgdGllKSAvIDI7XG4gICAgZm9yICg7IHRpZTxuOyArK3RpZSkgclthW3RpZV0uaWR4XSA9IG11O1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgUGVhcnNvbiBwcm9kdWN0LW1vbWVudCBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5jb3IgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIGZuID0gYjtcbiAgYiA9IGZuID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYTtcbiAgYSA9IGZuID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzO1xuXG4gIHZhciBkb3QgPSBzdGF0cy5kb3QoYSwgYiksXG4gICAgICBtdWEgPSBzdGF0cy5tZWFuKGEpLFxuICAgICAgbXViID0gc3RhdHMubWVhbihiKSxcbiAgICAgIHNkYSA9IHN0YXRzLnN0ZGV2KGEpLFxuICAgICAgc2RiID0gc3RhdHMuc3RkZXYoYiksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aDtcblxuICByZXR1cm4gKGRvdCAtIG4qbXVhKm11YikgLyAoKG4tMSkgKiBzZGEgKiBzZGIpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU3BlYXJtYW4gcmFuayBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIHZhbHVlcy5cbnN0YXRzLmNvci5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciByYSA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgdXRpbC4kKGEpKSA6IHN0YXRzLnJhbmsodmFsdWVzKSxcbiAgICAgIHJiID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYikpIDogc3RhdHMucmFuayhhKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBpLCBzLCBkO1xuXG4gIGZvciAoaT0wLCBzPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IHJhW2ldIC0gcmJbaV07XG4gICAgcyArPSBkICogZDtcbiAgfVxuXG4gIHJldHVybiAxIC0gNipzIC8gKG4gKiAobipuLTEpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRpc3RhbmNlIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfY29ycmVsYXRpb25cbnN0YXRzLmNvci5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBYID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYTtcblxuICB2YXIgQSA9IHN0YXRzLmRpc3QubWF0KFgpLFxuICAgICAgQiA9IHN0YXRzLmRpc3QubWF0KFkpLFxuICAgICAgbiA9IEEubGVuZ3RoLFxuICAgICAgaSwgYWEsIGJiLCBhYjtcblxuICBmb3IgKGk9MCwgYWE9MCwgYmI9MCwgYWI9MDsgaTxuOyArK2kpIHtcbiAgICBhYSArPSBBW2ldKkFbaV07XG4gICAgYmIgKz0gQltpXSpCW2ldO1xuICAgIGFiICs9IEFbaV0qQltpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoYWIgLyBNYXRoLnNxcnQoYWEqYmIpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHZlY3RvciBkaXN0YW5jZSBiZXR3ZWVuIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIERlZmF1bHQgaXMgRXVjbGlkZWFuIChleHA9MikgZGlzdGFuY2UsIGNvbmZpZ3VyYWJsZSB2aWEgZXhwIGFyZ3VtZW50Llxuc3RhdHMuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgZXhwKSB7XG4gIHZhciBmID0gdXRpbC5pc0Z1bmN0aW9uKGIpIHx8IHV0aWwuaXNTdHJpbmcoYiksXG4gICAgICBYID0gdmFsdWVzLFxuICAgICAgWSA9IGYgPyB2YWx1ZXMgOiBhLFxuICAgICAgZSA9IGYgPyBleHAgOiBiLFxuICAgICAgTDIgPSBlID09PSAyIHx8IGUgPT0gbnVsbCxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBzID0gMCwgZCwgaTtcbiAgaWYgKGYpIHtcbiAgICBhID0gdXRpbC4kKGEpO1xuICAgIGIgPSB1dGlsLiQoYik7XG4gIH1cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IGYgPyAoYShYW2ldKS1iKFlbaV0pKSA6IChYW2ldLVlbaV0pO1xuICAgIHMgKz0gTDIgPyBkKmQgOiBNYXRoLnBvdyhNYXRoLmFicyhkKSwgZSk7XG4gIH1cbiAgcmV0dXJuIEwyID8gTWF0aC5zcXJ0KHMpIDogTWF0aC5wb3cocywgMS9lKTtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1lYW4tY2VudGVyZWQgZGlzdGFuY2UgbWF0cml4IGZvciBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuZGlzdC5tYXQgPSBmdW5jdGlvbihYKSB7XG4gIHZhciBuID0gWC5sZW5ndGgsXG4gICAgICBtID0gbipuLFxuICAgICAgQSA9IEFycmF5KG0pLFxuICAgICAgUiA9IGdlbi56ZXJvcyhuKSxcbiAgICAgIE0gPSAwLCB2LCBpLCBqO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIEFbaSpuK2ldID0gMDtcbiAgICBmb3IgKGo9aSsxOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gPSAodiA9IE1hdGguYWJzKFhbaV0gLSBYW2pdKSk7XG4gICAgICBBW2oqbitpXSA9IHY7XG4gICAgICBSW2ldICs9IHY7XG4gICAgICBSW2pdICs9IHY7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgTSArPSBSW2ldO1xuICAgIFJbaV0gLz0gbjtcbiAgfVxuICBNIC89IG07XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZm9yIChqPWk7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSArPSBNIC0gUltpXSAtIFJbal07XG4gICAgICBBW2oqbitpXSA9IEFbaSpuK2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU2hhbm5vbiBlbnRyb3B5IChsb2cgYmFzZSAyKSBvZiBhbiBhcnJheSBvZiBjb3VudHMuXG5zdGF0cy5lbnRyb3B5ID0gZnVuY3Rpb24oY291bnRzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBpLCBwLCBzID0gMCwgSCA9IDAsIG4gPSBjb3VudHMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBzICs9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKTtcbiAgfVxuICBpZiAocyA9PT0gMCkgcmV0dXJuIDA7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHAgPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSkgLyBzO1xuICAgIGlmIChwKSBIICs9IHAgKiBNYXRoLmxvZyhwKTtcbiAgfVxuICByZXR1cm4gLUggLyBNYXRoLkxOMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBmb3JtIFtNSSwgTUlfZGlzdGFuY2VdIFxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NdXR1YWxfaW5mb3JtYXRpb25cbnN0YXRzLm11dHVhbCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHZhciB4ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgeSA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGEsXG4gICAgICB6ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoY291bnRzKSkgOiBiO1xuXG4gIHZhciBweCA9IHt9LFxuICAgICAgcHkgPSB7fSxcbiAgICAgIG4gPSB6Lmxlbmd0aCxcbiAgICAgIHMgPSAwLCBJID0gMCwgSCA9IDAsIHAsIHQsIGk7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gPSAwO1xuICAgIHB5W3lbaV1dID0gMDtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHB4W3hbaV1dICs9IHpbaV07XG4gICAgcHlbeVtpXV0gKz0geltpXTtcbiAgICBzICs9IHpbaV07XG4gIH1cblxuICB0ID0gMSAvIChzICogTWF0aC5MTjIpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBpZiAoeltpXSA9PT0gMCkgY29udGludWU7XG4gICAgcCA9IChzICogeltpXSkgLyAocHhbeFtpXV0gKiBweVt5W2ldXSk7XG4gICAgSSArPSB6W2ldICogdCAqIE1hdGgubG9nKHApO1xuICAgIEggKz0geltpXSAqIHQgKiBNYXRoLmxvZyh6W2ldL3MpO1xuICB9XG5cbiAgcmV0dXJuIFtJLCAxICsgSS9IXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG5zdGF0cy5tdXR1YWwuaW5mbyA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHJldHVybiBzdGF0cy5tdXR1YWwodmFsdWVzLCBhLCBiLCBjb3VudHMpWzBdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGRpc3RhbmNlIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIE1JX2Rpc3RhbmNlIGlzIGRlZmluZWQgYXMgMSAtIEkoYSxiKSAvIEgoYSxiKS5cbnN0YXRzLm11dHVhbC5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMV07XG59O1xuXG4vLyBDb21wdXRlIGEgcHJvZmlsZSBvZiBzdW1tYXJ5IHN0YXRpc3RpY3MgZm9yIGEgdmFyaWFibGUuXG5zdGF0cy5wcm9maWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBtZWFuID0gMCxcbiAgICAgIHZhbGlkID0gMCxcbiAgICAgIG1pc3NpbmcgPSAwLFxuICAgICAgZGlzdGluY3QgPSAwLFxuICAgICAgbWluID0gbnVsbCxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBNMiA9IDAsXG4gICAgICB2YWxzID0gW10sXG4gICAgICB1ID0ge30sIGRlbHRhLCBzZCwgaSwgdiwgeDtcblxuICAvLyBjb21wdXRlIHN1bW1hcnkgc3RhdHNcbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG5cbiAgICAvLyB1cGRhdGUgdW5pcXVlIHZhbHVlc1xuICAgIHVbdl0gPSAodiBpbiB1KSA/IHVbdl0gKyAxIDogKGRpc3RpbmN0ICs9IDEsIDEpO1xuXG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgKyttaXNzaW5nO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICAvLyB1cGRhdGUgc3RhdHNcbiAgICAgIHggPSAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSA/IHYubGVuZ3RoIDogdjtcbiAgICAgIGlmIChtaW49PT1udWxsIHx8IHggPCBtaW4pIG1pbiA9IHg7XG4gICAgICBpZiAobWF4PT09bnVsbCB8fCB4ID4gbWF4KSBtYXggPSB4O1xuICAgICAgZGVsdGEgPSB4IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKyt2YWxpZCk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAoeCAtIG1lYW4pO1xuICAgICAgdmFscy5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKHZhbGlkIC0gMSk7XG4gIHNkID0gTWF0aC5zcXJ0KE0yKTtcblxuICAvLyBzb3J0IHZhbHVlcyBmb3IgbWVkaWFuIGFuZCBpcXJcbiAgdmFscy5zb3J0KHV0aWwuY21wKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICAgICB0eXBlKHZhbHVlcywgZiksXG4gICAgdW5pcXVlOiAgIHUsXG4gICAgY291bnQ6ICAgIHZhbHVlcy5sZW5ndGgsXG4gICAgdmFsaWQ6ICAgIHZhbGlkLFxuICAgIG1pc3Npbmc6ICBtaXNzaW5nLFxuICAgIGRpc3RpbmN0OiBkaXN0aW5jdCxcbiAgICBtaW46ICAgICAgbWluLFxuICAgIG1heDogICAgICBtYXgsXG4gICAgbWVhbjogICAgIG1lYW4sXG4gICAgc3RkZXY6ICAgIHNkLFxuICAgIG1lZGlhbjogICAodiA9IHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuNSkpLFxuICAgIHExOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjI1KSxcbiAgICBxMzogICAgICAgc3RhdHMucXVhbnRpbGUodmFscywgMC43NSksXG4gICAgbW9kZXNrZXc6IHNkID09PSAwID8gMCA6IChtZWFuIC0gdikgLyBzZFxuICB9O1xufTtcblxuLy8gQ29tcHV0ZSBwcm9maWxlcyBmb3IgYWxsIHZhcmlhYmxlcyBpbiBhIGRhdGEgc2V0Llxuc3RhdHMuc3VtbWFyeSA9IGZ1bmN0aW9uKGRhdGEsIGZpZWxkcykge1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICB2YXIgcyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBwID0gc3RhdHMucHJvZmlsZShkYXRhLCB1dGlsLiQoZikpO1xuICAgIHJldHVybiAocC5maWVsZCA9IGYsIHApO1xuICB9KTtcbiAgcmV0dXJuIChzLl9fc3VtbWFyeV9fID0gdHJ1ZSwgcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXRzOyIsInZhciBkM190aW1lID0gcmVxdWlyZSgnZDMtdGltZScpO1xuXG52YXIgdGVtcERhdGUgPSBuZXcgRGF0ZSgpLFxuICAgIGJhc2VEYXRlID0gbmV3IERhdGUoMCwgMCwgMSkuc2V0RnVsbFllYXIoMCksIC8vIEphbiAxLCAwIEFEXG4gICAgdXRjQmFzZURhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygwLCAwLCAxKSkuc2V0VVRDRnVsbFllYXIoMCk7XG5cbmZ1bmN0aW9uIGRhdGUoZCkge1xuICByZXR1cm4gKHRlbXBEYXRlLnNldFRpbWUoK2QpLCB0ZW1wRGF0ZSk7XG59XG5cbi8vIGNyZWF0ZSBhIHRpbWUgdW5pdCBlbnRyeVxuZnVuY3Rpb24gZW50cnkodHlwZSwgZGF0ZSwgdW5pdCwgc3RlcCwgbWluLCBtYXgpIHtcbiAgdmFyIGUgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRlOiBkYXRlLFxuICAgIHVuaXQ6IHVuaXRcbiAgfTtcbiAgaWYgKHN0ZXApIHtcbiAgICBlLnN0ZXAgPSBzdGVwO1xuICB9IGVsc2Uge1xuICAgIGUubWluc3RlcCA9IDE7XG4gIH1cbiAgaWYgKG1pbiAhPSBudWxsKSBlLm1pbiA9IG1pbjtcbiAgaWYgKG1heCAhPSBudWxsKSBlLm1heCA9IG1heDtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlLCB1bml0LCBiYXNlLCBzdGVwLCBtaW4sIG1heCkge1xuICByZXR1cm4gZW50cnkodHlwZSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0Lm9mZnNldChiYXNlLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0LmNvdW50KGJhc2UsIGQpOyB9LFxuICAgIHN0ZXAsIG1pbiwgbWF4KTtcbn1cblxudmFyIGxvY2FsZSA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnNlY29uZCwgYmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUubWludXRlLCBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS5ob3VyLCAgIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLmRheSwgICAgYmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS5tb250aCwgIGJhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUueWVhciwgICBiYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0U2Vjb25kcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdtaW51dGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldE1pbnV0ZXMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnaG91cnMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0SG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDQrZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXREYXkoKTsgfSxcbiAgICBbMV0sIDAsIDZcbiAgKSxcbiAgZW50cnkoJ2RhdGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldERhdGUoKTsgfSxcbiAgICBbMV0sIDEsIDMxXG4gICksXG4gIGVudHJ5KCdtb250aHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIGQgJSAxMiwgMSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIHV0YyA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnV0Y1NlY29uZCwgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUudXRjTWludXRlLCB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS51dGNIb3VyLCAgIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLnV0Y0RheSwgICAgdXRjQmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS51dGNNb250aCwgIHV0Y0Jhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUudXRjWWVhciwgICB1dGNCYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ1NlY29uZHMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnbWludXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDTWludXRlcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdob3VycycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDSG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDQrZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF5KCk7IH0sXG4gICAgWzFdLCAwLCA2XG4gICksXG4gIGVudHJ5KCdkYXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF0ZSgpOyB9LFxuICAgIFsxXSwgMSwgMzFcbiAgKSxcbiAgZW50cnkoJ21vbnRocycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgZCAlIDEyLCAxKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIFNURVBTID0gW1xuICBbMzE1MzZlNiwgNV0sICAvLyAxLXllYXJcbiAgWzc3NzZlNiwgNF0sICAgLy8gMy1tb250aFxuICBbMjU5MmU2LCA0XSwgICAvLyAxLW1vbnRoXG4gIFsxMjA5NmU1LCAzXSwgIC8vIDItd2Vla1xuICBbNjA0OGU1LCAzXSwgICAvLyAxLXdlZWtcbiAgWzE3MjhlNSwgM10sICAgLy8gMi1kYXlcbiAgWzg2NGU1LCAzXSwgICAgLy8gMS1kYXlcbiAgWzQzMmU1LCAyXSwgICAgLy8gMTItaG91clxuICBbMjE2ZTUsIDJdLCAgICAvLyA2LWhvdXJcbiAgWzEwOGU1LCAyXSwgICAgLy8gMy1ob3VyXG4gIFszNmU1LCAyXSwgICAgIC8vIDEtaG91clxuICBbMThlNSwgMV0sICAgICAvLyAzMC1taW51dGVcbiAgWzllNSwgMV0sICAgICAgLy8gMTUtbWludXRlXG4gIFszZTUsIDFdLCAgICAgIC8vIDUtbWludXRlXG4gIFs2ZTQsIDFdLCAgICAgIC8vIDEtbWludXRlXG4gIFszZTQsIDBdLCAgICAgIC8vIDMwLXNlY29uZFxuICBbMTVlMywgMF0sICAgICAvLyAxNS1zZWNvbmRcbiAgWzVlMywgMF0sICAgICAgLy8gNS1zZWNvbmRcbiAgWzFlMywgMF0gICAgICAgLy8gMS1zZWNvbmRcbl07XG5cbmZ1bmN0aW9uIGZpbmQodW5pdHMsIHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgdmFyIHN0ZXAgPSBTVEVQU1swXSwgaSwgbiwgYmlucztcblxuICBmb3IgKGk9MSwgbj1TVEVQUy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgc3RlcCA9IFNURVBTW2ldO1xuICAgIGlmIChzcGFuID4gc3RlcFswXSkge1xuICAgICAgYmlucyA9IHNwYW4gLyBzdGVwWzBdO1xuICAgICAgaWYgKGJpbnMgPiBtYXhiKSB7XG4gICAgICAgIHJldHVybiB1bml0c1tTVEVQU1tpLTFdWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5zID49IG1pbmIpIHtcbiAgICAgICAgcmV0dXJuIHVuaXRzW3N0ZXBbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5pdHNbU1RFUFNbbi0xXVsxXV07XG59XG5cbmZ1bmN0aW9uIHRvVW5pdE1hcCh1bml0cykge1xuICB2YXIgbWFwID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPXVuaXRzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBtYXBbdW5pdHNbaV0udHlwZV0gPSB1bml0c1tpXTtcbiAgfVxuICBtYXAuZmluZCA9IGZ1bmN0aW9uKHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgICByZXR1cm4gZmluZCh1bml0cywgc3BhbiwgbWluYiwgbWF4Yik7XG4gIH07XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Vbml0TWFwKGxvY2FsZSk7XG5tb2R1bGUuZXhwb3J0cy51dGMgPSB0b1VuaXRNYXAodXRjKTtcbiIsInZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gICAgdXRjID0gdGltZS51dGM7XG5cbnZhciB1ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIEZOQU1FID0gJ19fbmFtZV9fJztcblxudS5uYW1lZGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBmKSB7IHJldHVybiAoZltGTkFNRV0gPSBuYW1lLCBmKTsgfTtcblxudS5uYW1lID0gZnVuY3Rpb24oZikgeyByZXR1cm4gZj09bnVsbCA/IG51bGwgOiBmW0ZOQU1FXTsgfTtcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IHUubmFtZWRmdW5jKCd0cnVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblxudS5mYWxzZSA9IHUubmFtZWRmdW5jKCdmYWxzZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuXG51LmR1cGxpY2F0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnUuZXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYik7XG59O1xuXG51LmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciB4LCBuYW1lLCBpPTEsIGxlbj1hcmd1bWVudHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKG5hbWUgaW4geCkgeyBvYmpbbmFtZV0gPSB4W25hbWVdOyB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbnUubGVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHgubGVuZ3RoICE9IG51bGwgPyB4Lmxlbmd0aCA6IG51bGw7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0LCBmKSB7XG4gIHJldHVybiAoZiA9IHUuJChmKSkgP1xuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialtmKHgpXSA9IDEsIG9iaik7IH0sIHt9KSA6XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW3hdID0gMSwgb2JqKTsgfSwge30pO1xufTtcblxudS5rZXlzdHIgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgLy8gdXNlIHRvIGVuc3VyZSBjb25zaXN0ZW50IGtleSBnZW5lcmF0aW9uIGFjcm9zcyBtb2R1bGVzXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgaWYgKCFuKSByZXR1cm4gJyc7XG4gIGZvciAodmFyIHM9U3RyaW5nKHZhbHVlc1swXSksIGk9MTsgaTxuOyArK2kpIHtcbiAgICBzICs9ICd8JyArIFN0cmluZyh2YWx1ZXNbaV0pO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLy8gdHlwZSBjaGVja2luZyBmdW5jdGlvbnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnUuaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmo7XG59O1xuXG51LmlzQnVmZmVyID0gKGJ1ZmZlci5CdWZmZXIgJiYgYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogK3M7XG59O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhcztcbn07XG5cbnUuZGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBEYXRlLnBhcnNlKHMpO1xufTtcblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdO1xufTtcblxudS5zdHIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB1LmlzQXJyYXkoeCkgPyAnWycgKyB4Lm1hcCh1LnN0cikgKyAnXSdcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/ICgnXFwnJyt1dGlsX2VzY2FwZV9zdHIoeCkrJ1xcJycpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsICckMVxcXFxcXCcnKTtcbn1cblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBTdHJpbmcoZikuc3BsaXQoJ1xcXFwuJylcbiAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3BsaXQoJy4nKTsgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCkgeyBhW2EubGVuZ3RoLTFdICs9ICcuJyArIGIuc2hpZnQoKTsgfVxuICAgICAgYS5wdXNoLmFwcGx5KGEsIGIpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgW10pO1xufTtcblxudS5hY2Nlc3NvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiBmPT1udWxsIHx8IHUuaXNGdW5jdGlvbihmKSA/IGYgOlxuICAgIHUubmFtZWRmdW5jKGYsIChzID0gdS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBzLnJlZHVjZShmdW5jdGlvbih4LGYpIHsgcmV0dXJuIHhbZl07IH0sIHgpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZl07IH1cbiAgICApO1xufTtcblxuLy8gc2hvcnQtY3V0IGZvciBhY2Nlc3NvclxudS4kID0gdS5hY2Nlc3NvcjtcblxudS5tdXRhdG9yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgZnVuY3Rpb24oeCwgdikge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICB4W3NbaV1dID0gdjtcbiAgICB9IDpcbiAgICBmdW5jdGlvbih4LCB2KSB7IHhbZl0gPSB2OyB9O1xufTtcblxuXG51LiRmdW5jID0gZnVuY3Rpb24obmFtZSwgb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICBmID0gdS4kKGYpIHx8IHUuaWRlbnRpdHk7XG4gICAgdmFyIG4gPSBuYW1lICsgKHUubmFtZShmKSA/ICdfJyt1Lm5hbWUoZikgOiAnJyk7XG4gICAgcmV0dXJuIHUubmFtZWRmdW5jKG4sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG9wKGYoZCkpOyB9KTtcbiAgfTtcbn07XG5cbnUuJHZhbGlkICA9IHUuJGZ1bmMoJ3ZhbGlkJywgdS5pc1ZhbGlkKTtcbnUuJGxlbmd0aCA9IHUuJGZ1bmMoJ2xlbmd0aCcsIHUubGVuZ3RoKTtcblxudS4kaW4gPSBmdW5jdGlvbihmLCB2YWx1ZXMpIHtcbiAgZiA9IHUuJChmKTtcbiAgdmFyIG1hcCA9IHUuaXNBcnJheSh2YWx1ZXMpID8gdS50b01hcCh2YWx1ZXMpIDogdmFsdWVzO1xuICByZXR1cm4gZnVuY3Rpb24oZCkgeyByZXR1cm4gISFtYXBbZihkKV07IH07XG59O1xuXG51LiR5ZWFyICAgPSB1LiRmdW5jKCd5ZWFyJywgdGltZS55ZWFyLnVuaXQpO1xudS4kbW9udGggID0gdS4kZnVuYygnbW9udGgnLCB0aW1lLm1vbnRocy51bml0KTtcbnUuJGRhdGUgICA9IHUuJGZ1bmMoJ2RhdGUnLCB0aW1lLmRhdGVzLnVuaXQpO1xudS4kZGF5ICAgID0gdS4kZnVuYygnZGF5JywgdGltZS53ZWVrZGF5cy51bml0KTtcbnUuJGhvdXIgICA9IHUuJGZ1bmMoJ2hvdXInLCB0aW1lLmhvdXJzLnVuaXQpO1xudS4kbWludXRlID0gdS4kZnVuYygnbWludXRlJywgdGltZS5taW51dGVzLnVuaXQpO1xudS4kc2Vjb25kID0gdS4kZnVuYygnc2Vjb25kJywgdGltZS5zZWNvbmRzLnVuaXQpO1xuXG51LiR1dGNZZWFyICAgPSB1LiRmdW5jKCd1dGNZZWFyJywgdXRjLnllYXIudW5pdCk7XG51LiR1dGNNb250aCAgPSB1LiRmdW5jKCd1dGNNb250aCcsIHV0Yy5tb250aHMudW5pdCk7XG51LiR1dGNEYXRlICAgPSB1LiRmdW5jKCd1dGNEYXRlJywgdXRjLmRhdGVzLnVuaXQpO1xudS4kdXRjRGF5ICAgID0gdS4kZnVuYygndXRjRGF5JywgdXRjLndlZWtkYXlzLnVuaXQpO1xudS4kdXRjSG91ciAgID0gdS4kZnVuYygndXRjSG91cicsIHV0Yy5ob3Vycy51bml0KTtcbnUuJHV0Y01pbnV0ZSA9IHUuJGZ1bmMoJ3V0Y01pbnV0ZScsIHV0Yy5taW51dGVzLnVuaXQpO1xudS4kdXRjU2Vjb25kID0gdS4kZnVuYygndXRjU2Vjb25kJywgdXRjLnNlY29uZHMudW5pdCk7XG5cbi8vIGNvbXBhcmlzb24gLyBzb3J0aW5nIGZ1bmN0aW9uc1xuXG51LmNvbXBhcmF0b3IgPSBmdW5jdGlvbihzb3J0KSB7XG4gIHZhciBzaWduID0gW107XG4gIGlmIChzb3J0ID09PSB1bmRlZmluZWQpIHNvcnQgPSBbXTtcbiAgc29ydCA9IHUuYXJyYXkoc29ydCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcyA9IDE7XG4gICAgaWYgICAgICAoZlswXSA9PT0gJy0nKSB7IHMgPSAtMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBlbHNlIGlmIChmWzBdID09PSAnKycpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbnUucGFkID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHBhZGNoYXIpIHtcbiAgcGFkY2hhciA9IHBhZGNoYXIgfHwgXCIgXCI7XG4gIHZhciBkID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG4gIGlmIChkIDw9IDApIHJldHVybiBzO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIHN0cnJlcChkLCBwYWRjaGFyKSArIHM7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHN0cnJlcChNYXRoLmZsb29yKGQvMiksIHBhZGNoYXIpICtcbiAgICAgICAgIHMgKyBzdHJyZXAoTWF0aC5jZWlsKGQvMiksIHBhZGNoYXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcyArIHN0cnJlcChkLCBwYWRjaGFyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RycmVwKG4sIHN0cikge1xuICB2YXIgcyA9IFwiXCIsIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgcyArPSBzdHI7XG4gIHJldHVybiBzO1xufVxuXG51LnRydW5jYXRlID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHdvcmQsIGVsbGlwc2lzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBsZW5ndGgpIHJldHVybiBzO1xuICBlbGxpcHNpcyA9IGVsbGlwc2lzICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoZWxsaXBzaXMpIDogJ1xcdTIwMjYnO1xuICB2YXIgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGVsbGlwc2lzLmxlbmd0aCk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsLDEpIDogcy5zbGljZShsZW4tbCkpO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgK1xuICAgICAgICBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHRydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKCcnKS50cmltKCkgOiB0b2tbMF0uc2xpY2UoMCwgbGVuKTtcbn1cblxudmFyIHRydW5jYXRlX3dvcmRfcmUgPSAvKFtcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MjAyOFxcdTIwMjlcXHUzMDAwXFx1RkVGRl0pLztcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyksXG4gIHZsZW5jID0gcmVxdWlyZSgnLi9lbmMnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBFbmNvZGluZyhzcGVjLCB0aGVtZSkge1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpLFxuICAgICAgc3BlY0V4dGVuZGVkID0gc2NoZW1hLnV0aWwubWVyZ2UoZGVmYXVsdHMsIHRoZW1lIHx8IHt9LCBzcGVjKSA7XG5cbiAgICB0aGlzLl9kYXRhID0gc3BlY0V4dGVuZGVkLmRhdGE7XG4gICAgdGhpcy5fbWFya3R5cGUgPSBzcGVjRXh0ZW5kZWQubWFya3R5cGU7XG4gICAgdGhpcy5fZW5jID0gc3BlY0V4dGVuZGVkLmVuY29kaW5nO1xuICAgIHRoaXMuX2NvbmZpZyA9IHNwZWNFeHRlbmRlZC5jb25maWc7XG4gICAgdGhpcy5fZmlsdGVyID0gc3BlY0V4dGVuZGVkLmZpbHRlcjtcbiAgICAvLyB0aGlzLl92ZWdhMiA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJvdG8gPSBFbmNvZGluZy5wcm90b3R5cGU7XG5cbiAgRW5jb2RpbmcuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnLCB0aGVtZSkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgICAgICAgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy5kZWxpbSksXG4gICAgICAgIG1hcmt0eXBlID0gc3BsaXQuc2hpZnQoKS5zcGxpdChjLmFzc2lnbilbMV0udHJpbSgpLFxuICAgICAgICBlbmMgPSB2bGVuYy5mcm9tU2hvcnRoYW5kKHNwbGl0KTtcblxuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1hcmt0eXBlOiBtYXJrdHlwZSxcbiAgICAgIGVuY29kaW5nOiBlbmMsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGZpbHRlcjogW11cbiAgICB9LCB0aGVtZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCB0aGVtZSkge1xuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoc3BlYywgdGhlbWUpO1xuICB9O1xuXG4gIHByb3RvLnRvU2hvcnRoYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICAgIHJldHVybiAnbWFyaycgKyBjLmFzc2lnbiArIHRoaXMuX21hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQodGhpcy5fZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyBzcGVjLm1hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc3BlY0Zyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgZXhjbHVkZUNvbmZpZykge1xuICAgIHJldHVybiBFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnKS50b1NwZWMoZXhjbHVkZUNvbmZpZyk7XG4gIH07XG5cbiAgcHJvdG8udG9TcGVjID0gZnVuY3Rpb24oZXhjbHVkZUNvbmZpZywgZXhjbHVkZURhdGEpIHtcbiAgICB2YXIgZW5jID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fZW5jKSxcbiAgICAgIHNwZWM7XG5cbiAgICBzcGVjID0ge1xuICAgICAgbWFya3R5cGU6IHRoaXMuX21hcmt0eXBlLFxuICAgICAgZW5jb2Rpbmc6IGVuYyxcbiAgICAgIGZpbHRlcjogdGhpcy5fZmlsdGVyXG4gICAgfTtcblxuICAgIGlmICghZXhjbHVkZUNvbmZpZykge1xuICAgICAgc3BlYy5jb25maWcgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9jb25maWcpO1xuICAgIH1cblxuICAgIGlmICghZXhjbHVkZURhdGEpIHtcbiAgICAgIHNwZWMuZGF0YSA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2RhdGEpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBkZWZhdWx0c1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuICAgIHJldHVybiBzY2hlbWEudXRpbC5zdWJ0cmFjdChzcGVjLCBkZWZhdWx0cyk7XG4gIH07XG5cblxuICBwcm90by5tYXJrdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZTtcbiAgfTtcblxuICBwcm90by5pcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgPT09IG07XG4gIH07XG5cbiAgcHJvdG8uaGFzID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIC8vIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB2bGVuYy5oYXModGhpcy5fZW5jLCBlbmNUeXBlKVxuICAgIHJldHVybiB0aGlzLl9lbmNbZW5jVHlwZV0ubmFtZSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHByb3RvLmZpZWxkID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XTtcbiAgfTtcblxuICBwcm90by5maWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmlsdGVyTnVsbCA9IFtdLFxuICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMoKSxcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgdXRpbC5mb3JFYWNoKGZpZWxkcywgZnVuY3Rpb24oZmllbGRMaXN0LCBmaWVsZE5hbWUpIHtcbiAgICAgIGlmIChmaWVsZE5hbWUgPT09ICcqJykgcmV0dXJuOyAvL2NvdW50XG5cbiAgICAgIGlmICgoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5RICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbUV0pIHx8XG4gICAgICAgICAgKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuVCAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1RdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLk8gJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtPXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5OICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbTl0pKSB7XG4gICAgICAgIGZpbHRlck51bGwucHVzaCh7XG4gICAgICAgICAgb3BlcmFuZHM6IFtmaWVsZE5hbWVdLFxuICAgICAgICAgIG9wZXJhdG9yOiAnbm90TnVsbCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlsdGVyTnVsbC5jb25jYXQodGhpcy5fZmlsdGVyKTtcbiAgfTtcblxuICAvLyBnZXQgXCJmaWVsZFwiIHJlZmVyZW5jZSBmb3IgdmVnYVxuICBwcm90by5maWVsZFJlZiA9IGZ1bmN0aW9uKGV0LCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgb3B0LmRhdGEgPSAhdGhpcy5fdmVnYTIgJiYgKG9wdC5kYXRhICE9PSBmYWxzZSk7XG4gICAgcmV0dXJuIHZsZmllbGQuZmllbGRSZWYodGhpcy5fZW5jW2V0XSwgb3B0KTtcbiAgfTtcblxuICBwcm90by5maWVsZE5hbWUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gIH07XG5cbiAgLypcbiAgICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAgICovXG4gIHByb3RvLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5maWVsZHModGhpcy5fZW5jKTtcbiAgfTtcblxuICBwcm90by5maWVsZFRpdGxlID0gZnVuY3Rpb24oZXQpIHtcbiAgICBpZiAodmxmaWVsZC5pc0NvdW50KHRoaXMuX2VuY1tldF0pKSB7XG4gICAgICByZXR1cm4gdmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZTtcbiAgICB9XG4gICAgdmFyIGZuID0gdGhpcy5fZW5jW2V0XS5hZ2dyZWdhdGUgfHwgdGhpcy5fZW5jW2V0XS50aW1lVW5pdCB8fCAodGhpcy5fZW5jW2V0XS5iaW4gJiYgJ2JpbicpO1xuICAgIGlmIChmbikge1xuICAgICAgcmV0dXJuIGZuLnRvVXBwZXJDYXNlKCkgKyAnKCcgKyB0aGlzLl9lbmNbZXRdLm5hbWUgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLnNjYWxlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5zY2FsZSB8fCB7fTtcbiAgfTtcblxuICBwcm90by5heGlzID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5heGlzIHx8IHt9O1xuICB9O1xuXG4gIHByb3RvLmJhbmRTaXplID0gZnVuY3Rpb24oZW5jVHlwZSwgdXNlU21hbGxCYW5kKSB7XG4gICAgdXNlU21hbGxCYW5kID0gdXNlU21hbGxCYW5kIHx8XG4gICAgICAvL2lzQmFuZEluU21hbGxNdWx0aXBsZXNcbiAgICAgIChlbmNUeXBlID09PSBZICYmIHRoaXMuaGFzKFJPVykgJiYgdGhpcy5oYXMoWSkpIHx8XG4gICAgICAoZW5jVHlwZSA9PT0gWCAmJiB0aGlzLmhhcyhDT0wpICYmIHRoaXMuaGFzKFgpKTtcblxuICAgIC8vIGlmIGJhbmQuc2l6ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgZm9sbG93IHRoZSBzcGVjaWZpY2F0aW9uLCBvdGhlcndpc2UgZHJhdyB2YWx1ZSBmcm9tIGNvbmZpZy5cbiAgICByZXR1cm4gdGhpcy5maWVsZChlbmNUeXBlKS5iYW5kLnNpemUgfHxcbiAgICAgIHRoaXMuY29uZmlnKHVzZVNtYWxsQmFuZCA/ICdzbWFsbEJhbmRTaXplJyA6ICdsYXJnZUJhbmRTaXplJyk7XG4gIH07XG5cbiAgcHJvdG8uYWdncmVnYXRlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5hZ2dyZWdhdGU7XG4gIH07XG5cbiAgLy8gcmV0dXJucyBmYWxzZSBpZiBiaW5uaW5nIGlzIGRpc2FibGVkLCBvdGhlcndpc2UgYW4gb2JqZWN0IHdpdGggYmlubmluZyBwcm9wZXJ0aWVzXG4gIHByb3RvLmJpbiA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgdmFyIGJpbiA9IHRoaXMuX2VuY1tldF0uYmluO1xuICAgIGlmIChiaW4gPT09IHt9KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiaW4gPT09IHRydWUpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXhiaW5zOiBzY2hlbWEuTUFYQklOU19ERUZBVUxUXG4gICAgICB9O1xuICAgIHJldHVybiBiaW47XG4gIH07XG5cbiAgcHJvdG8udmFsdWUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLnZhbHVlO1xuICB9O1xuXG4gIHByb3RvLm51bWJlckZvcm1hdCA9IGZ1bmN0aW9uKGZpZWxkU3RhdHMpIHtcbiAgICB2YXIgZm9ybWF0Q29uZmlnID0gZmllbGRTdGF0cy5tYXggPiB0aGlzLmNvbmZpZygnbWF4U21hbGxOdW1iZXInKSA/XG4gICAgICAnbGFyZ2VOdW1iZXJGb3JtYXQnOiAnc21hbGxOdW1iZXJGb3JtYXQnO1xuICAgIHJldHVybiB0aGlzLmNvbmZpZyhmb3JtYXRDb25maWcpO1xuICB9O1xuXG4gIHByb3RvLnNvcnQgPSBmdW5jdGlvbihldCwgc3RhdHMpIHtcbiAgICB2YXIgc29ydCA9IHRoaXMuX2VuY1tldF0uc29ydCxcbiAgICAgIGVuYyA9IHRoaXMuX2VuYyxcbiAgICAgIGlzVHlwZXMgPSB2bGZpZWxkLmlzVHlwZXM7XG5cbiAgICBpZiAoKCFzb3J0IHx8IHNvcnQubGVuZ3RoPT09MCkgJiZcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0KHtlbmNvZGluZzp0aGlzLl9lbmN9LCBzdGF0cywgdHJ1ZSkgJiYgLy9IQUNLXG4gICAgICAgIHRoaXMuY29uZmlnKCd0b2dnbGVTb3J0JykgPT09IFFcbiAgICAgICkge1xuICAgICAgdmFyIHFGaWVsZCA9IGlzVHlwZXMoZW5jLngsIFtOLCBPXSkgPyBlbmMueSA6IGVuYy54O1xuXG4gICAgICBpZiAoaXNUeXBlcyhlbmNbZXRdLCBbTiwgT10pKSB7XG4gICAgICAgIHNvcnQgPSBbe1xuICAgICAgICAgIG5hbWU6IHFGaWVsZC5uYW1lLFxuICAgICAgICAgIGFnZ3JlZ2F0ZTogcUZpZWxkLmFnZ3JlZ2F0ZSxcbiAgICAgICAgICB0eXBlOiBxRmllbGQudHlwZSxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3J0O1xuICB9O1xuXG4gIHByb3RvLm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMubWFwKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8ucmVkdWNlID0gZnVuY3Rpb24oZiwgaW5pdCkge1xuICAgIHJldHVybiB2bGVuYy5yZWR1Y2UodGhpcy5fZW5jLCBmLCBpbml0KTtcbiAgfTtcblxuICBwcm90by5mb3JFYWNoID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB2bGVuYy5mb3JFYWNoKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8udHlwZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGV0KSA/IHRoaXMuX2VuY1tldF0udHlwZSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8uaXNUeXBlID0gZnVuY3Rpb24oZXQsIHR5cGUpIHtcbiAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkKGV0KTtcbiAgICByZXR1cm4gZmllbGQgJiYgdmxmaWVsZC5pc1R5cGUoZmllbGQsIHR5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzVHlwZXMgPSBmdW5jdGlvbihldCwgdHlwZSkge1xuICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQoZXQpO1xuICAgIHJldHVybiBmaWVsZCAmJiB2bGZpZWxkLmlzVHlwZXMoZmllbGQsIHR5cGUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc09yZGluYWxTY2FsZShlbmNvZGluZy5maWVsZChlbmNUeXBlKSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzRGltZW5zaW9uKGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzTWVhc3VyZShlbmNvZGluZy5maWVsZChlbmNUeXBlKSk7XG4gIH07XG5cbiAgcHJvdG8uaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc0RpbWVuc2lvbih0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzTWVhc3VyZSh0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZSh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZShzcGVjLmVuY29kaW5nKTtcbiAgfTtcblxuICBFbmNvZGluZy5hbHdheXNOb09jY2x1c2lvbiA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAvLyBGSVhNRSByYXcgT3hRIHdpdGggIyBvZiByb3dzID0gIyBvZiBPXG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jb2RpbmcpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzU3RhY2sgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgLy8gRklYTUUgdXBkYXRlIHRoaXMgb25jZSB3ZSBoYXZlIGNvbnRyb2wgZm9yIHN0YWNrIC4uLlxuICAgIHJldHVybiAoc3BlYy5tYXJrdHlwZSA9PT0gJ2JhcicgfHwgc3BlYy5tYXJrdHlwZSA9PT0gJ2FyZWEnKSAmJlxuICAgICAgc3BlYy5lbmNvZGluZy5jb2xvcjtcbiAgfTtcblxuICBwcm90by5pc1N0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gRklYTUUgdXBkYXRlIHRoaXMgb25jZSB3ZSBoYXZlIGNvbnRyb2wgZm9yIHN0YWNrIC4uLlxuICAgIHJldHVybiAodGhpcy5pcygnYmFyJykgfHwgdGhpcy5pcygnYXJlYScpKSAmJiB0aGlzLmhhcygnY29sb3InKTtcbiAgfTtcblxuICBwcm90by5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGVuY1R5cGUsIHN0YXRzKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuY2FyZGluYWxpdHkodGhpcy5maWVsZChlbmNUeXBlKSwgc3RhdHMsIHRoaXMuY29uZmlnKCdmaWx0ZXJOdWxsJykpO1xuICB9O1xuXG4gIHByb3RvLmlzUmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzQWdncmVnYXRlKCk7XG4gIH07XG5cbiAgcHJvdG8uZGF0YSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA/IHRoaXMuX2RhdGFbbmFtZV0gOiB0aGlzLl9kYXRhO1xuICB9O1xuXG4gICAvLyByZXR1cm5zIHdoZXRoZXIgdGhlIGVuY29kaW5nIGhhcyB2YWx1ZXMgZW1iZWRkZWRcbiAgcHJvdG8uaGFzVmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHMgPSB0aGlzLmRhdGEoJ3ZhbHVlcycpO1xuICAgIHJldHVybiB2YWxzICYmIHZhbHMubGVuZ3RoO1xuICB9O1xuXG4gIHByb3RvLmNvbmZpZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnW25hbWVdO1xuICB9O1xuXG4gIEVuY29kaW5nLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICB2YXIgb2xkZW5jID0gc3BlYy5lbmNvZGluZyxcbiAgICAgIGVuYyA9IHV0aWwuZHVwbGljYXRlKHNwZWMuZW5jb2RpbmcpO1xuICAgIGVuYy54ID0gb2xkZW5jLnk7XG4gICAgZW5jLnkgPSBvbGRlbmMueDtcbiAgICBlbmMucm93ID0gb2xkZW5jLmNvbDtcbiAgICBlbmMuY29sID0gb2xkZW5jLnJvdztcbiAgICBzcGVjLmVuY29kaW5nID0gZW5jO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG4gIC8vIEZJWE1FOiBSRU1PVkUgZXZlcnl0aGluZyBiZWxvdyBoZXJlXG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydCA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBzcGVjLmNvbmZpZyA9IHNwZWMuY29uZmlnIHx8IHt9O1xuICAgIHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQgPSBzcGVjLmNvbmZpZy50b2dnbGVTb3J0ID09PSBRID8gTiA6IFE7XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cblxuICBFbmNvZGluZy50b2dnbGVTb3J0LmRpcmVjdGlvbiA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBpZiAoIUVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydChzcGVjKSkgeyByZXR1cm47IH1cbiAgICB2YXIgZW5jID0gc3BlYy5lbmNvZGluZztcbiAgICByZXR1cm4gZW5jLngudHlwZSA9PT0gTiA/ICd4JyA6ICd5JztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVTb3J0Lm1vZGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQ7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0ID0gZnVuY3Rpb24oc3BlYywgc3RhdHMpIHtcbiAgICB2YXIgZW5jID0gc3BlYy5lbmNvZGluZyxcbiAgICAgIGlzVHlwZXMgPSB2bGZpZWxkLmlzVHlwZXM7XG5cbiAgICBpZiAodmxlbmMuaGFzKGVuYywgUk9XKSB8fCB2bGVuYy5oYXMoZW5jLCBDT0wpIHx8XG4gICAgICAhdmxlbmMuaGFzKGVuYywgWCkgfHwgIXZsZW5jLmhhcyhlbmMsIFkpIHx8XG4gICAgICAhRW5jb2RpbmcuYWx3YXlzTm9PY2NsdXNpb24oc3BlYywgc3RhdHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICggaXNUeXBlcyhlbmMueCwgW04sT10pICYmIHZsZmllbGQuaXNNZWFzdXJlKGVuYy55KSkgPyAneCcgOlxuICAgICAgKCBpc1R5cGVzKGVuYy55LCBbTixPXSkgJiYgdmxmaWVsZC5pc01lYXN1cmUoZW5jLngpKSA/ICd5JyA6IGZhbHNlO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZUZpbHRlck51bGxPID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHNwZWMuY29uZmlnID0gc3BlYy5jb25maWcgfHwge307XG4gICAgc3BlYy5jb25maWcuZmlsdGVyTnVsbCA9IHNwZWMuY29uZmlnLmZpbHRlck51bGwgfHwgeyAvL0ZJWE1FXG4gICAgICBUOiB0cnVlLFxuICAgICAgUTogdHJ1ZVxuICAgIH07XG4gICAgc3BlYy5jb25maWcuZmlsdGVyTnVsbC5PID0gIXNwZWMuY29uZmlnLmZpbHRlck51bGwuTztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVGaWx0ZXJOdWxsTy5zdXBwb3J0ID0gZnVuY3Rpb24oc3BlYywgc3RhdHMpIHtcbiAgICB2YXIgZmllbGRzID0gdmxlbmMuZmllbGRzKHNwZWMuZW5jb2RpbmcpO1xuICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZExpc3QgPSBmaWVsZHNbZmllbGROYW1lXTtcbiAgICAgIGlmIChmaWVsZExpc3QuY29udGFpbnNUeXBlLk8gJiYgZmllbGROYW1lIGluIHN0YXRzICYmIHN0YXRzW2ZpZWxkTmFtZV0ubnVsbHMgPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIEVuY29kaW5nO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZ2dyZWdhdGVzO1xuXG5mdW5jdGlvbiBhZ2dyZWdhdGVzKGRhdGFUYWJsZSwgZW5jb2RpbmcsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgdmFyIGRpbXMgPSB7fSwgbWVhcyA9IHt9LCBkZXRhaWwgPSB7fSwgZmFjZXRzID0ge307XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChmaWVsZC5hZ2dyZWdhdGUpIHtcbiAgICAgIGlmIChmaWVsZC5hZ2dyZWdhdGUgPT09ICdjb3VudCcpIHtcbiAgICAgICAgbWVhcy5jb3VudCA9IHtvcDogJ2NvdW50JywgZmllbGQ6ICcqJ307XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIG1lYXNbZmllbGQuYWdncmVnYXRlICsgJ3wnKyBmaWVsZC5uYW1lXSA9IHtcbiAgICAgICAgICBvcDogZmllbGQuYWdncmVnYXRlLFxuICAgICAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlLCB7bm9mbjogdHJ1ZX0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbXNbZmllbGQubmFtZV0gPSBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKTtcbiAgICAgIGlmIChlbmNUeXBlID09IFJPVyB8fCBlbmNUeXBlID09IENPTCkge1xuICAgICAgICBmYWNldHNbZmllbGQubmFtZV0gPSBkaW1zW2ZpZWxkLm5hbWVdO1xuICAgICAgfWVsc2UgaWYgKGVuY1R5cGUgIT09IFggJiYgZW5jVHlwZSAhPT0gWSkge1xuICAgICAgICBkZXRhaWxbZmllbGQubmFtZV0gPSBkaW1zW2ZpZWxkLm5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGRpbXMgPSB1dGlsLnZhbHMoZGltcyk7XG4gIG1lYXMgPSB1dGlsLnZhbHMobWVhcyk7XG5cbiAgaWYgKG1lYXMubGVuZ3RoID4gMCkge1xuICAgIGlmICghZGF0YVRhYmxlLnRyYW5zZm9ybSkgZGF0YVRhYmxlLnRyYW5zZm9ybSA9IFtdO1xuICAgIGRhdGFUYWJsZS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgIGdyb3VwYnk6IGRpbXMsXG4gICAgICBmaWVsZHM6IG1lYXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRldGFpbHM6IHV0aWwudmFscyhkZXRhaWwpLFxuICAgIGRpbXM6IGRpbXMsXG4gICAgZmFjZXRzOiB1dGlsLnZhbHMoZmFjZXRzKSxcbiAgICBhZ2dyZWdhdGVkOiBtZWFzLmxlbmd0aCA+IDBcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIGdldHRlciA9IHV0aWwuZ2V0dGVyLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbnZhciBheGlzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuYXhpcy5uYW1lcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gIHJldHVybiB1dGlsLmtleXModXRpbC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgIHZhciBzID0gcHJvcHNbeF0uc2NhbGU7XG4gICAgaWYgKHMgPT09IFggfHwgcyA9PT0gWSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufTtcblxuYXhpcy5kZWZzID0gZnVuY3Rpb24obmFtZXMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpIHtcbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihhLCBuYW1lKSB7XG4gICAgYS5wdXNoKGF4aXMuZGVmKG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpKTtcbiAgICByZXR1cm4gYTtcbiAgfSwgW10pO1xufTtcblxuYXhpcy5kZWYgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSB7XG4gIHZhciBpc0NvbCA9IG5hbWUgPT0gQ09MLFxuICAgIGlzUm93ID0gbmFtZSA9PSBST1csXG4gICAgdHlwZSA9IGlzQ29sID8gJ3gnIDogaXNSb3cgPyAneScgOiBuYW1lO1xuXG4gIHZhciBkZWYgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzY2FsZTogbmFtZSxcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBsYXllcjogZW5jb2RpbmcuZmllbGQobmFtZSkuYXhpcy5sYXllcixcbiAgICBvcmllbnQ6IGF4aXMub3JpZW50KG5hbWUsIGVuY29kaW5nLCBzdGF0cylcbiAgfTtcblxuICAvLyBBZGQgYXhpcyBsYWJlbCBjdXN0b20gc2NhbGUgKGZvciBiaW4gLyB0aW1lKVxuICBkZWYgPSBheGlzLmxhYmVscy5zY2FsZShkZWYsIGVuY29kaW5nLCBuYW1lKTtcbiAgZGVmID0gYXhpcy5sYWJlbHMuZm9ybWF0KGRlZiwgbmFtZSwgZW5jb2RpbmcsIHN0YXRzKTtcblxuICAvLyBmb3IgeC1heGlzLCBzZXQgdGlja3MgZm9yIFEgb3Igcm90YXRlIHNjYWxlIGZvciBvcmRpbmFsIHNjYWxlXG4gIGlmIChuYW1lID09IFgpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNEaW1lbnNpb24oWCkgfHwgZW5jb2RpbmcuaXNUeXBlKFgsIFQpKSB7XG4gICAgICAvLyBUT0RPKGthbml0dyk6IEp1bCAxOSwgMjAxNSAtICM1MDYgYWRkIGNvbmRpdGlvbiBmb3Igcm90YXRpb25cbiAgICAgIGRlZiA9IGF4aXMubGFiZWxzLnJvdGF0ZShkZWYpO1xuICAgIH0gZWxzZSB7IC8vIFFcbiAgICAgIGRlZi50aWNrcyA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLmF4aXMudGlja3M7XG4gICAgfVxuICB9XG5cbiAgLy8gVGl0bGVPZmZzZXQgZGVwZW5kcyBvbiBsYWJlbHMgcm90YXRpb25cbiAgZGVmLnRpdGxlT2Zmc2V0ID0gYXhpcy50aXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBuYW1lKTtcblxuICAvL2RlZi5vZmZzZXQgaXMgdXNlZCBpbiBheGlzLmdyaWRcbiAgaWYoaXNSb3cpIGRlZi5vZmZzZXQgPSBheGlzLnRpdGxlT2Zmc2V0KGVuY29kaW5nLCBsYXlvdXQsIFkpICsgMjA7XG4gIC8vIEZJWE1FKGthbml0dyk6IEp1bCAxOSwgMjAxNSAtIG9mZnNldCBmb3IgY29sdW1uIHdoZW4geCBpcyBwdXQgb24gdG9wXG5cbiAgZGVmID0gYXhpcy5ncmlkKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCk7XG4gIGRlZiA9IGF4aXMudGl0bGUoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBvcHQpO1xuXG4gIGlmIChpc1JvdyB8fCBpc0NvbCkgZGVmID0gYXhpcy5oaWRlVGlja3MoZGVmKTtcblxuICByZXR1cm4gZGVmO1xufTtcblxuYXhpcy5vcmllbnQgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIG9yaWVudCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLmF4aXMub3JpZW50O1xuICBpZiAob3JpZW50KSByZXR1cm4gb3JpZW50O1xuXG4gIGlmIChuYW1lPT09Q09MKSByZXR1cm4gJ3RvcCc7XG5cbiAgLy8geC1heGlzIGZvciBsb25nIHkgLSBwdXQgb24gdG9wXG4gIGlmIChuYW1lPT09WCAmJiBlbmNvZGluZy5oYXMoWSkgJiYgZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWSkgJiYgZW5jb2RpbmcuY2FyZGluYWxpdHkoWSwgc3RhdHMpID4gMzApIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuYXhpcy5ncmlkID0gZnVuY3Rpb24oZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0KSB7XG4gIHZhciBjZWxsUGFkZGluZyA9IGxheW91dC5jZWxsUGFkZGluZyxcbiAgICBpc0NvbCA9IG5hbWUgPT0gQ09MLFxuICAgIGlzUm93ID0gbmFtZSA9PSBST1c7XG5cbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkuZ3JpZCkge1xuICAgIGRlZi5ncmlkID0gdHJ1ZTtcblxuICAgIGlmIChpc0NvbCkge1xuICAgICAgLy8gc2V0IGdyaWQgcHJvcGVydHkgLS0gcHV0IHRoZSBsaW5lcyBvbiB0aGUgcmlnaHQgdGhlIGNlbGxcbiAgICAgIGRlZi5wcm9wZXJ0aWVzLmdyaWQgPSB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBvZmZzZXQ6IGxheW91dC5jZWxsV2lkdGggKiAoMSsgY2VsbFBhZGRpbmcvMi4wKSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBzY2FsZTogJ2NvbCdcbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHZhbHVlOiAtbGF5b3V0LmNlbGxIZWlnaHQgKiAoY2VsbFBhZGRpbmcvMiksXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZE9wYWNpdHknKSB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNSb3cpIHtcbiAgICAgIC8vIHNldCBncmlkIHByb3BlcnR5IC0tIHB1dCB0aGUgbGluZXMgb24gdGhlIHRvcFxuICAgICAgZGVmLnByb3BlcnRpZXMuZ3JpZCA9IHtcbiAgICAgICAgeToge1xuICAgICAgICAgIG9mZnNldDogLWxheW91dC5jZWxsSGVpZ2h0ICogKGNlbGxQYWRkaW5nLzIpLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAncm93J1xuICAgICAgICB9LFxuICAgICAgICB4OiB7XG4gICAgICAgICAgdmFsdWU6IGRlZi5vZmZzZXRcbiAgICAgICAgfSxcbiAgICAgICAgeDI6IHtcbiAgICAgICAgICBvZmZzZXQ6IGRlZi5vZmZzZXQgKyAobGF5b3V0LmNlbGxXaWR0aCAqIDAuMDUpLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIGdyb3VwOiAnbWFyay5ncm91cC53aWR0aCcsXG4gICAgICAgICAgbXVsdDogMVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEdyaWRDb2xvcicpIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEdyaWRPcGFjaXR5JykgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmLnByb3BlcnRpZXMuZ3JpZCA9IHtcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2dyaWRDb2xvcicpIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnZ3JpZE9wYWNpdHknKSB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmO1xufTtcblxuYXhpcy5oaWRlVGlja3MgPSBmdW5jdGlvbihkZWYpIHtcbiAgZGVmLnByb3BlcnRpZXMudGlja3MgPSB7b3BhY2l0eToge3ZhbHVlOiAwfX07XG4gIGRlZi5wcm9wZXJ0aWVzLm1ham9yVGlja3MgPSB7b3BhY2l0eToge3ZhbHVlOiAwfX07XG4gIGRlZi5wcm9wZXJ0aWVzLmF4aXMgPSB7b3BhY2l0eToge3ZhbHVlOiAwfX07XG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLnRpdGxlID0gZnVuY3Rpb24gKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCkge1xuICB2YXIgYXggPSBlbmNvZGluZy5maWVsZChuYW1lKS5heGlzO1xuXG4gIGlmIChheC50aXRsZSkge1xuICAgIGRlZi50aXRsZSA9IGF4LnRpdGxlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIG5vdCBkZWZpbmVkLCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSBheGlzIHRpdGxlIGZyb20gZmllbGQgZGVmXG4gICAgdmFyIGZpZWxkVGl0bGUgPSBlbmNvZGluZy5maWVsZFRpdGxlKG5hbWUpLFxuICAgICAgbWF4TGVuZ3RoO1xuXG4gICAgaWYgKGF4LnRpdGxlTWF4TGVuZ3RoKSB7XG4gICAgICBtYXhMZW5ndGggPSBheC50aXRsZU1heExlbmd0aDtcbiAgICB9IGVsc2UgaWYgKG5hbWU9PT1YKSB7XG4gICAgICBtYXhMZW5ndGggPSBsYXlvdXQuY2VsbFdpZHRoIC8gZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gWSkge1xuICAgICAgbWF4TGVuZ3RoID0gbGF5b3V0LmNlbGxIZWlnaHQgLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gICAgfVxuXG4gICAgZGVmLnRpdGxlID0gbWF4TGVuZ3RoID8gdXRpbC50cnVuY2F0ZShmaWVsZFRpdGxlLCBtYXhMZW5ndGgpIDogZmllbGRUaXRsZTtcbiAgfVxuXG4gIGlmIChuYW1lID09PSBST1cpIHtcbiAgICBkZWYucHJvcGVydGllcy50aXRsZSA9IHtcbiAgICAgIGFuZ2xlOiB7dmFsdWU6IDB9LFxuICAgICAgYWxpZ246IHt2YWx1ZTogJ3JpZ2h0J30sXG4gICAgICBiYXNlbGluZToge3ZhbHVlOiAnbWlkZGxlJ30sXG4gICAgICBkeToge3ZhbHVlOiAoLWxheW91dC5oZWlnaHQvMikgLTIwfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGVmO1xufTtcblxuYXhpcy5sYWJlbHMgPSB7fTtcblxuLyoqIGFkZCBjdXN0b20gbGFiZWwgZm9yIHRpbWUgdHlwZSBhbmQgYmluICovXG5heGlzLmxhYmVscy5zY2FsZSA9IGZ1bmN0aW9uKGRlZiwgZW5jb2RpbmcsIG5hbWUpIHtcbiAgLy8gdGltZVxuICB2YXIgdGltZVVuaXQgPSBlbmNvZGluZy5maWVsZChuYW1lKS50aW1lVW5pdDtcbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiB0aW1lVW5pdCAmJiAodGltZS5oYXNTY2FsZSh0aW1lVW5pdCkpKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywndGV4dCcsJ3NjYWxlJ10sICd0aW1lLScrIHRpbWVVbml0KTtcbiAgfVxuICAvLyBGSVhNRSBiaW5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIG51bWJlciBmb3JtYXQgb3IgdHJ1bmNhdGUgaWYgbWF4TGFiZWwgbGVuZ3RoIGlzIHByZXNlbnRlZC5cbiAqL1xuYXhpcy5sYWJlbHMuZm9ybWF0ID0gZnVuY3Rpb24gKGRlZiwgbmFtZSwgZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBmaWVsZFN0YXRzID0gc3RhdHNbZW5jb2RpbmcuZmllbGQobmFtZSkubmFtZV07XG5cbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkuZm9ybWF0KSB7XG4gICAgZGVmLmZvcm1hdCA9IGVuY29kaW5nLmF4aXMobmFtZSkuZm9ybWF0O1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBRKSB8fCBmaWVsZFN0YXRzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgZGVmLmZvcm1hdCA9IGVuY29kaW5nLm51bWJlckZvcm1hdChmaWVsZFN0YXRzKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkpIHtcbiAgICB2YXIgdGltZVVuaXQgPSBlbmNvZGluZy5maWVsZChuYW1lKS50aW1lVW5pdDtcbiAgICBpZiAoIXRpbWVVbml0KSB7XG4gICAgICBkZWYuZm9ybWF0ID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lRm9ybWF0Jyk7XG4gICAgfSBlbHNlIGlmICh0aW1lVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICBkZWYuZm9ybWF0ID0gJ2QnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGVzKG5hbWUsIFtOLCBPXSkgJiYgZW5jb2RpbmcuYXhpcyhuYW1lKS5tYXhMYWJlbExlbmd0aCkge1xuICAgIHNldHRlcihkZWYsXG4gICAgICBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCd0ZXh0JywndGVtcGxhdGUnXSxcbiAgICAgICd7e2RhdGEgfCB0cnVuY2F0ZTonICsgZW5jb2RpbmcuYXhpcyhuYW1lKS5tYXhMYWJlbExlbmd0aCArICd9fSdcbiAgICAgICk7XG4gIH1cblxuICByZXR1cm4gZGVmO1xufTtcblxuYXhpcy5sYWJlbHMucm90YXRlID0gZnVuY3Rpb24oZGVmKSB7XG4gdmFyIGFsaWduID0gZGVmLm9yaWVudCA9PT0ndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywgJ2FuZ2xlJywgJ3ZhbHVlJ10sIDI3MCk7XG4gc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywgJ2FsaWduJywgJ3ZhbHVlJ10sIGFsaWduKTtcbiBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCAnYmFzZWxpbmUnLCAndmFsdWUnXSwgJ21pZGRsZScpO1xuIHJldHVybiBkZWY7XG59O1xuXG5heGlzLnRpdGxlT2Zmc2V0ID0gZnVuY3Rpb24gKGVuY29kaW5nLCBsYXlvdXQsIG5hbWUpIHtcbiAgLy8gcmV0dXJuIHNwZWNpZmllZCB2YWx1ZSBpZiBzcGVjaWZpZWRcbiAgdmFyIHZhbHVlID0gZW5jb2RpbmcuYXhpcyhuYW1lKS50aXRsZU9mZnNldDtcbiAgaWYgKHZhbHVlKSAgcmV0dXJuIHZhbHVlO1xuXG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vRklYTUUgbWFrZSB0aGlzIGFkanVzdGFibGVcbiAgICBjYXNlIFJPVzogcmV0dXJuIDA7XG4gICAgY2FzZSBDT0w6IHJldHVybiAzNTtcbiAgfVxuICByZXR1cm4gZ2V0dGVyKGxheW91dCwgW25hbWUsICdheGlzVGl0bGVPZmZzZXQnXSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmlubmluZztcblxuZnVuY3Rpb24gYmlubmluZyhkYXRhVGFibGUsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIGlmICghZGF0YVRhYmxlLnRyYW5zZm9ybSkgZGF0YVRhYmxlLnRyYW5zZm9ybSA9IFtdO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2RpbmcuYmluKGVuY1R5cGUpKSB7XG4gICAgICBkYXRhVGFibGUudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmluJyxcbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUsIHtub2ZuOiB0cnVlfSksXG4gICAgICAgIG91dHB1dDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSksXG4gICAgICAgIG1heGJpbnM6IGVuY29kaW5nLmJpbihlbmNUeXBlKS5tYXhiaW5zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhVGFibGU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdW1tYXJ5ID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdkYXRhbGliL3NyYy9zdGF0cycpLnN1bW1hcnk7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGNvbXBpbGVyID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmFyIEVuY29kaW5nID0gcmVxdWlyZSgnLi4vRW5jb2RpbmcnKSxcbiAgYXhpcyA9IGNvbXBpbGVyLmF4aXMgPSByZXF1aXJlKCcuL2F4aXMnKSxcbiAgZmlsdGVyID0gY29tcGlsZXIuZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKSxcbiAgbGVnZW5kID0gY29tcGlsZXIubGVnZW5kID0gcmVxdWlyZSgnLi9sZWdlbmQnKSxcbiAgbWFya3MgPSBjb21waWxlci5tYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKSxcbiAgc2NhbGUgPSBjb21waWxlci5zY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxuY29tcGlsZXIuYWdncmVnYXRlID0gcmVxdWlyZSgnLi9hZ2dyZWdhdGUnKTtcbmNvbXBpbGVyLmJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG5jb21waWxlci5mYWNldCA9IHJlcXVpcmUoJy4vZmFjZXQnKTtcbmNvbXBpbGVyLmdyb3VwID0gcmVxdWlyZSgnLi9ncm91cCcpO1xuY29tcGlsZXIubGF5b3V0ID0gcmVxdWlyZSgnLi9sYXlvdXQnKTtcbmNvbXBpbGVyLnNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKTtcbmNvbXBpbGVyLnN0YWNrID0gcmVxdWlyZSgnLi9zdGFjaycpO1xuY29tcGlsZXIuc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG5jb21waWxlci5zdWJmYWNldCA9IHJlcXVpcmUoJy4vc3ViZmFjZXQnKTtcbmNvbXBpbGVyLnRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuY29tcGlsZXIudGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG5jb21waWxlci5jb21waWxlID0gZnVuY3Rpb24gKHNwZWMsIHN0YXRzLCB0aGVtZSkge1xuICByZXR1cm4gY29tcGlsZXIuY29tcGlsZUVuY29kaW5nKEVuY29kaW5nLmZyb21TcGVjKHNwZWMsIHRoZW1lKSwgc3RhdHMpO1xufTtcblxuY29tcGlsZXIuc2hvcnRoYW5kID0gZnVuY3Rpb24gKHNob3J0aGFuZCwgc3RhdHMsIGNvbmZpZywgdGhlbWUpIHtcbiAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVFbmNvZGluZyhFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgY29uZmlnLCB0aGVtZSksIHN0YXRzKTtcbn07XG5cbmNvbXBpbGVyLmNvbXBpbGVFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhdHMpIHtcbiAgLy8gbm8gbmVlZCB0byBwYXNzIHN0YXRzIGlmIHlvdSBwYXNzIGluIHRoZSBkYXRhXG4gIGlmICghc3RhdHMgJiYgZW5jb2RpbmcuaGFzVmFsdWVzKCkpIHtcbiAgICBzdGF0cyA9IHN1bW1hcnkoZW5jb2RpbmcuZGF0YSgndmFsdWVzJykpLnJlZHVjZShmdW5jdGlvbihzLCBwKSB7XG4gICAgICBzW3AuZmllbGRdID0gcDtcbiAgICAgIHJldHVybiBzO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIHZhciBsYXlvdXQgPSBjb21waWxlci5sYXlvdXQoZW5jb2RpbmcsIHN0YXRzKSxcbiAgICBzcGVjID0gY29tcGlsZXIudGVtcGxhdGUoZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpO1xuXG4gIC8vIC5kYXRhIHJlbGF0ZWQgc3R1ZmZcbiAgdmFyIHJhd1RhYmxlID0gc3BlYy5kYXRhWzBdLFxuICAgIGRhdGFUYWJsZSA9IHNwZWMuZGF0YVsxXTtcblxuICByYXdUYWJsZSA9IGZpbHRlci5hZGRGaWx0ZXJzKHJhd1RhYmxlLCBlbmNvZGluZyk7IC8vIG1vZGlmeSByYXdUYWJsZVxuICBzcGVjID0gY29tcGlsZXIudGltZShzcGVjLCBlbmNvZGluZyk7ICAgICAgICAgICAgICAvLyBtb2RpZnkgcmF3VGFibGUsIGFkZCBzY2FsZXNcbiAgZGF0YVRhYmxlID0gY29tcGlsZXIuYmluKGRhdGFUYWJsZSwgZW5jb2RpbmcpOyAgICAgLy8gbW9kaWZ5IGRhdGFUYWJsZVxuICB2YXIgYWdnUmVzdWx0ID0gY29tcGlsZXIuYWdncmVnYXRlKGRhdGFUYWJsZSwgZW5jb2RpbmcpOyAvLyBtb2RpZnkgZGF0YVRhYmxlXG4gIHZhciBzb3J0aW5nID0gY29tcGlsZXIuc29ydChzcGVjLmRhdGEsIGVuY29kaW5nLCBzdGF0cyk7IC8vIGFwcGVuZCBuZXcgZGF0YVxuXG4gIC8vIG1hcmtzXG4gIHZhciBzdHlsZSA9IGNvbXBpbGVyLnN0eWxlKGVuY29kaW5nLCBzdGF0cyksXG4gICAgZ3JvdXAgPSBzcGVjLm1hcmtzWzBdLFxuICAgIG1hcmsgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXSxcbiAgICBtZGVmcyA9IG1hcmtzLmRlZihtYXJrLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpLFxuICAgIG1kZWYgPSBtZGVmc1swXTsgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRpcnR5IGhhY2sgYnkgcmVmYWN0b3JpbmcgdGhlIHdob2xlIGZsb3dcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ3JvdXAubWFya3MucHVzaChtZGVmc1tpXSk7XG4gIH1cblxuICB2YXIgbGluZVR5cGUgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5saW5lO1xuXG4gIC8vIGhhbmRsZSBzdWJmYWNldHNcblxuICB2YXIgZGV0YWlscyA9IGFnZ1Jlc3VsdC5kZXRhaWxzLFxuICAgIGhhc0RldGFpbHMgPSBkZXRhaWxzICYmIGRldGFpbHMubGVuZ3RoID4gMCxcbiAgICBzdGFjayA9IGhhc0RldGFpbHMgJiYgY29tcGlsZXIuc3RhY2soc3BlYy5kYXRhLCBlbmNvZGluZywgbWRlZiwgYWdnUmVzdWx0LmZhY2V0cyk7IC8vIG1vZGlmeSBzcGVjLmRhdGEsIG1kZWYue2Zyb20scHJvcGVydGllc31cblxuICBpZiAoaGFzRGV0YWlscyAmJiAoc3RhY2sgfHwgbGluZVR5cGUpKSB7XG4gICAgLy9zdWJmYWNldCB0byBncm91cCBzdGFjayAvIGxpbmUgdG9nZXRoZXIgaW4gb25lIGdyb3VwXG4gICAgY29tcGlsZXIuc3ViZmFjZXQoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBhdXRvLXNvcnQgbGluZS9hcmVhIHZhbHVlc1xuICAvL1RPRE8oa2FuaXR3KTogaGF2ZSBzb21lIGNvbmZpZyB0byB0dXJuIG9mZiBhdXRvLXNvcnQgZm9yIGxpbmUgKGZvciBsaW5lIGNoYXJ0IHRoYXQgZW5jb2RlcyB0ZW1wb3JhbCBpbmZvcm1hdGlvbilcbiAgaWYgKGxpbmVUeXBlKSB7XG4gICAgdmFyIGYgPSAoZW5jb2RpbmcuaXNNZWFzdXJlKFgpICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFkpKSA/IFkgOiBYO1xuICAgIGlmICghbWRlZi5mcm9tKSBtZGVmLmZyb20gPSB7fTtcbiAgICAvLyBUT0RPOiB3aHkgLSA/XG4gICAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7dHlwZTogJ3NvcnQnLCBieTogJy0nICsgZW5jb2RpbmcuZmllbGRSZWYoZil9XTtcbiAgfVxuXG4gIC8vIFNtYWxsIE11bHRpcGxlc1xuICBpZiAoZW5jb2RpbmcuaGFzKFJPVykgfHwgZW5jb2RpbmcuaGFzKENPTCkpIHtcbiAgICBzcGVjID0gY29tcGlsZXIuZmFjZXQoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpO1xuICAgIHNwZWMubGVnZW5kcyA9IGxlZ2VuZC5kZWZzKGVuY29kaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBncm91cC5zY2FsZXMgPSBzY2FsZS5kZWZzKHNjYWxlLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgc3R5bGUsIHNvcnRpbmcsIHtzdGFjazogc3RhY2t9KTtcbiAgICBncm91cC5heGVzID0gYXhpcy5kZWZzKGF4aXMubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSksIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKTtcbiAgICBncm91cC5sZWdlbmRzID0gbGVnZW5kLmRlZnMoZW5jb2RpbmcpO1xuICB9XG5cbiAgZmlsdGVyLmZpbHRlckxlc3NUaGFuWmVybyhkYXRhVGFibGUsIGVuY29kaW5nKTtcblxuICByZXR1cm4gc3BlYztcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGF4aXMgPSByZXF1aXJlKCcuL2F4aXMnKSxcbiAgZ3JvdXBkZWYgPSByZXF1aXJlKCcuL2dyb3VwJykuZGVmLFxuICBzY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWNldGluZztcblxuZnVuY3Rpb24gZmFjZXRpbmcoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpIHtcbiAgdmFyIGVudGVyID0gZ3JvdXAucHJvcGVydGllcy5lbnRlcjtcbiAgdmFyIGZhY2V0S2V5cyA9IFtdLCBjZWxsQXhlcyA9IFtdLCBmcm9tLCBheGVzR3JwO1xuXG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSwgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCk7XG5cbiAgZW50ZXIuZmlsbCA9IHt2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsQmFja2dyb3VuZENvbG9yJyl9O1xuXG4gIC8vbW92ZSBcImZyb21cIiB0byBjZWxsIGxldmVsIGFuZCBhZGQgZmFjZXQgdHJhbnNmb3JtXG4gIGdyb3VwLmZyb20gPSB7ZGF0YTogZ3JvdXAubWFya3NbMF0uZnJvbS5kYXRhfTtcblxuICAvLyBIYWNrLCB0aGlzIG5lZWRzIHRvIGJlIHJlZmFjdG9yZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXJrID0gZ3JvdXAubWFya3NbaV07XG4gICAgaWYgKG1hcmsuZnJvbS50cmFuc2Zvcm0pIHtcbiAgICAgIGRlbGV0ZSBtYXJrLmZyb20uZGF0YTsgLy9uZWVkIHRvIGtlZXAgdHJhbnNmb3JtIGZvciBzdWJmYWNldHRpbmcgY2FzZVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgbWFyay5mcm9tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNSb3cpIHtcbiAgICBpZiAoIWVuY29kaW5nLmlzRGltZW5zaW9uKFJPVykpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ1JvdyBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC4nKTtcbiAgICB9XG4gICAgZW50ZXIueSA9IHtzY2FsZTogUk9XLCBmaWVsZDogJ2tleXMuJyArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgIGVudGVyLmhlaWdodCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkUmVmKFJPVykpO1xuXG4gICAgaWYgKGhhc0NvbCkge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IFtlbmNvZGluZy5maWVsZFJlZihDT0wpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneC1heGVzJywge1xuICAgICAgICBheGVzOiBlbmNvZGluZy5oYXMoWCkgPyBheGlzLmRlZnMoWyd4J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgeDogaGFzQ29sID8ge3NjYWxlOiBDT0wsIGZpZWxkOiAna2V5cy4wJ30gOiB7dmFsdWU6IDB9LFxuICAgICAgICB3aWR0aDogaGFzQ29sICYmIHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofSwgLy9IQUNLP1xuICAgICAgICBmcm9tOiBmcm9tXG4gICAgICB9KTtcblxuICAgIHNwZWMubWFya3MudW5zaGlmdChheGVzR3JwKTsgLy8gbmVlZCB0byBwcmVwZW5kIHNvIGl0IGFwcGVhcnMgdW5kZXIgdGhlIHBsb3RzXG4gICAgKHNwZWMuYXhlcyA9IHNwZWMuYXhlcyB8fCBbXSk7XG4gICAgc3BlYy5heGVzLnB1c2guYXBwbHkoc3BlYy5heGVzLCBheGlzLmRlZnMoWydyb3cnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgfSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIHJvd1xuICAgIGlmIChlbmNvZGluZy5oYXMoWCkpIHtcbiAgICAgIC8va2VlcCB4IGF4aXMgaW4gdGhlIGNlbGxcbiAgICAgIGNlbGxBeGVzLnB1c2guYXBwbHkoY2VsbEF4ZXMsIGF4aXMuZGVmcyhbJ3gnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzQ29sKSB7XG4gICAgaWYgKCFlbmNvZGluZy5pc0RpbWVuc2lvbihDT0wpKSB7XG4gICAgICB1dGlsLmVycm9yKCdDb2wgZW5jb2Rpbmcgc2hvdWxkIGJlIG9yZGluYWwuJyk7XG4gICAgfVxuICAgIGVudGVyLnggPSB7c2NhbGU6IENPTCwgZmllbGQ6ICdrZXlzLicgKyBmYWNldEtleXMubGVuZ3RofTtcbiAgICBlbnRlci53aWR0aCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofTsgLy8gSEFDS1xuXG4gICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGRSZWYoQ09MKSk7XG5cbiAgICBpZiAoaGFzUm93KSB7XG4gICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogW2VuY29kaW5nLmZpZWxkUmVmKFJPVyldfSk7XG4gICAgfVxuXG4gICAgYXhlc0dycCA9IGdyb3VwZGVmKCd5LWF4ZXMnLCB7XG4gICAgICBheGVzOiBlbmNvZGluZy5oYXMoWSkgPyBheGlzLmRlZnMoWyd5J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSA6IHVuZGVmaW5lZCxcbiAgICAgIHk6IGhhc1JvdyAmJiB7c2NhbGU6IFJPVywgZmllbGQ6ICdrZXlzLjAnfSxcbiAgICAgIHg6IGhhc1JvdyAmJiB7dmFsdWU6IDB9LFxuICAgICAgaGVpZ2h0OiBoYXNSb3cgJiYgeyd2YWx1ZSc6IGxheW91dC5jZWxsSGVpZ2h0fSwgLy9IQUNLP1xuICAgICAgZnJvbTogZnJvbVxuICAgIH0pO1xuXG4gICAgc3BlYy5tYXJrcy51bnNoaWZ0KGF4ZXNHcnApOyAvLyBuZWVkIHRvIHByZXBlbmQgc28gaXQgYXBwZWFycyB1bmRlciB0aGUgcGxvdHNcbiAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICBzcGVjLmF4ZXMucHVzaC5hcHBseShzcGVjLmF4ZXMsIGF4aXMuZGVmcyhbJ2NvbCddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgY29sXG4gICAgaWYgKGVuY29kaW5nLmhhcyhZKSkge1xuICAgICAgY2VsbEF4ZXMucHVzaC5hcHBseShjZWxsQXhlcywgYXhpcy5kZWZzKFsneSddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc3VtaW5nIGVxdWFsIGNlbGxXaWR0aCBoZXJlXG4gIC8vIFRPRE86IHN1cHBvcnQgaGV0ZXJvZ2Vub3VzIGNlbGxXaWR0aCAobWF5YmUgYnkgdXNpbmcgbXVsdGlwbGUgc2NhbGVzPylcbiAgc3BlYy5zY2FsZXMgPSAoc3BlYy5zY2FsZXMgfHwgW10pLmNvbmNhdChzY2FsZS5kZWZzKFxuICAgIHNjYWxlLm5hbWVzKGVudGVyKS5jb25jYXQoc2NhbGUubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSkpLFxuICAgIGVuY29kaW5nLFxuICAgIGxheW91dCxcbiAgICBzdGF0cyxcbiAgICBzdHlsZSxcbiAgICBzb3J0aW5nLFxuICAgIHtzdGFjazogc3RhY2ssIGZhY2V0OiB0cnVlfVxuICApKTsgLy8gcm93L2NvbCBzY2FsZXMgKyBjZWxsIHNjYWxlc1xuXG4gIGlmIChjZWxsQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgZ3JvdXAuYXhlcyA9IGNlbGxBeGVzO1xuICB9XG5cbiAgLy8gYWRkIGZhY2V0IHRyYW5zZm9ybVxuICB2YXIgdHJhbnMgPSAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gfHwgKGdyb3VwLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogZmFjZXRLZXlzfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGZpbHRlciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBCSU5BUlkgPSB7XG4gICc+JzogIHRydWUsXG4gICc+PSc6IHRydWUsXG4gICc9JzogIHRydWUsXG4gICchPSc6IHRydWUsXG4gICc8JzogIHRydWUsXG4gICc8PSc6IHRydWVcbn07XG5cbmZpbHRlci5hZGRGaWx0ZXJzID0gZnVuY3Rpb24ocmF3VGFibGUsIGVuY29kaW5nKSB7XG4gIHZhciBmaWx0ZXJzID0gZW5jb2RpbmcuZmlsdGVyKCk7ICAvLyBhcHBseSBmaWx0ZXJzIHRvIHJhdyBkYXRhIGJlZm9yZSBhZ2dyZWdhdGlvblxuXG4gIGlmICghcmF3VGFibGUudHJhbnNmb3JtKVxuICAgIHJhd1RhYmxlLnRyYW5zZm9ybSA9IFtdO1xuXG4gIC8vIGFkZCBjdXN0b20gZmlsdGVyc1xuICBmb3IgKHZhciBpPTAsIGw9ZmlsdGVycy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgdmFyIGZpbHRlciA9IGZpbHRlcnNbaV07XG5cbiAgICB2YXIgY29uZGl0aW9uID0gJyc7XG4gICAgdmFyIG9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xuICAgIHZhciBvcGVyYW5kcyA9IGZpbHRlci5vcGVyYW5kcztcblxuICAgIHZhciBkID0gJ2QuJyArIChlbmNvZGluZy5fdmVnYTIgPyAnJyA6ICdkYXRhLicpO1xuXG4gICAgaWYgKEJJTkFSWVtvcGVyYXRvcl0pIHtcbiAgICAgIC8vIGV4cGVjdHMgYSBmaWVsZCBhbmQgYSB2YWx1ZVxuICAgICAgaWYgKG9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgICAgb3BlcmF0b3IgPSAnPT0nO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3AxID0gb3BlcmFuZHNbMF07XG4gICAgICB2YXIgb3AyID0gb3BlcmFuZHNbMV07XG4gICAgICBjb25kaXRpb24gPSBkICsgb3AxICsgb3BlcmF0b3IgKyBvcDI7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ25vdE51bGwnKSB7XG4gICAgICAvLyBleHBlY3RzIGEgbnVtYmVyIG9mIGZpZWxkc1xuICAgICAgZm9yICh2YXIgaj0wOyBqPG9wZXJhbmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbmRpdGlvbiArPSBkICsgb3BlcmFuZHNbal0gKyAnIT09bnVsbCc7XG4gICAgICAgIGlmIChqIDwgb3BlcmFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbmRpdGlvbiArPSAnICYmICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBvcGVyYXRvcjogJywgb3BlcmF0b3IpO1xuICAgIH1cblxuICAgIHJhd1RhYmxlLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgdGVzdDogY29uZGl0aW9uXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmF3VGFibGU7XG59O1xuXG4vLyByZW1vdmUgbGVzcyB0aGFuIDAgdmFsdWVzIGlmIHdlIHVzZSBsb2cgZnVuY3Rpb25cbmZpbHRlci5maWx0ZXJMZXNzVGhhblplcm8gPSBmdW5jdGlvbihkYXRhVGFibGUsIGVuY29kaW5nKSB7XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2Rpbmcuc2NhbGUoZW5jVHlwZSkudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgIGRhdGFUYWJsZS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgICB0ZXN0OiAnZC4nICsgZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSkgKyAnPjAnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZjogZ3JvdXBkZWZcbn07XG5cbmZ1bmN0aW9uIGdyb3VwZGVmKG5hbWUsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHJldHVybiB7XG4gICAgX25hbWU6IG5hbWUgfHwgdW5kZWZpbmVkLFxuICAgIHR5cGU6ICdncm91cCcsXG4gICAgZnJvbTogb3B0LmZyb20sXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDogb3B0LnggfHwgdW5kZWZpbmVkLFxuICAgICAgICB5OiBvcHQueSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHdpZHRoOiBvcHQud2lkdGggfHwge2dyb3VwOiAnd2lkdGgnfSxcbiAgICAgICAgaGVpZ2h0OiBvcHQuaGVpZ2h0IHx8IHtncm91cDogJ2hlaWdodCd9XG4gICAgICB9XG4gICAgfSxcbiAgICBzY2FsZXM6IG9wdC5zY2FsZXMgfHwgdW5kZWZpbmVkLFxuICAgIGF4ZXM6IG9wdC5heGVzIHx8IHVuZGVmaW5lZCxcbiAgICBtYXJrczogb3B0Lm1hcmtzIHx8IFtdXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gIGQzX2Zvcm1hdCA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZsbGF5b3V0O1xuXG5mdW5jdGlvbiB2bGxheW91dChlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGxheW91dCA9IGJveChlbmNvZGluZywgc3RhdHMpO1xuICBsYXlvdXQgPSBvZmZzZXQoZW5jb2RpbmcsIHN0YXRzLCBsYXlvdXQpO1xuICByZXR1cm4gbGF5b3V0O1xufVxuXG4vKlxuICBIQUNLIHRvIHNldCBjaGFydCBzaXplXG4gIE5PVEU6IHRoaXMgZmFpbHMgZm9yIHBsb3RzIGRyaXZlbiBieSBkZXJpdmVkIHZhbHVlcyAoZS5nLiwgYWdncmVnYXRlcylcbiAgT25lIHNvbHV0aW9uIGlzIHRvIHVwZGF0ZSBWZWdhIHRvIHN1cHBvcnQgYXV0by1zaXppbmdcbiAgSW4gdGhlIG1lYW50aW1lLCBhdXRvLXBhZGRpbmcgKG1vc3RseSkgZG9lcyB0aGUgdHJpY2tcbiAqL1xuZnVuY3Rpb24gYm94KGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksXG4gICAgICBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKSxcbiAgICAgIGhhc1ggPSBlbmNvZGluZy5oYXMoWCksXG4gICAgICBoYXNZID0gZW5jb2RpbmcuaGFzKFkpLFxuICAgICAgbWFya3R5cGUgPSBlbmNvZGluZy5tYXJrdHlwZSgpO1xuXG4gIC8vIEZJWE1FL0hBQ0sgd2UgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcbiAgdmFyIHhDYXJkaW5hbGl0eSA9IGhhc1ggJiYgZW5jb2RpbmcuaXNEaW1lbnNpb24oWCkgPyBlbmNvZGluZy5jYXJkaW5hbGl0eShYLCBzdGF0cykgOiAxLFxuICAgIHlDYXJkaW5hbGl0eSA9IGhhc1kgJiYgZW5jb2RpbmcuaXNEaW1lbnNpb24oWSkgPyBlbmNvZGluZy5jYXJkaW5hbGl0eShZLCBzdGF0cykgOiAxO1xuXG4gIHZhciB1c2VTbWFsbEJhbmQgPSB4Q2FyZGluYWxpdHkgPiBlbmNvZGluZy5jb25maWcoJ2xhcmdlQmFuZE1heENhcmRpbmFsaXR5JykgfHxcbiAgICB5Q2FyZGluYWxpdHkgPiBlbmNvZGluZy5jb25maWcoJ2xhcmdlQmFuZE1heENhcmRpbmFsaXR5Jyk7XG5cbiAgdmFyIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgY2VsbFBhZGRpbmcgPSBlbmNvZGluZy5jb25maWcoJ2NlbGxQYWRkaW5nJyk7XG5cbiAgLy8gc2V0IGNlbGxXaWR0aFxuICBpZiAoaGFzWCkge1xuICAgIGlmIChlbmNvZGluZy5pc09yZGluYWxTY2FsZShYKSkge1xuICAgICAgLy8gZm9yIG9yZGluYWwsIGhhc0NvbCBvciBub3QgZG9lc24ndCBtYXR0ZXIgLS0gd2Ugc2NhbGUgYmFzZWQgb24gY2FyZGluYWxpdHlcbiAgICAgIGNlbGxXaWR0aCA9ICh4Q2FyZGluYWxpdHkgKyBlbmNvZGluZy5maWVsZChYKS5iYW5kLnBhZGRpbmcpICogZW5jb2RpbmcuYmFuZFNpemUoWCwgdXNlU21hbGxCYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbFdpZHRoID0gaGFzQ29sIHx8IGhhc1JvdyA/IGVuY29kaW5nLmZpZWxkKENPTCkud2lkdGggOiAgZW5jb2RpbmcuY29uZmlnKCdzaW5nbGVXaWR0aCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobWFya3R5cGUgPT09IFRFWFQpIHtcbiAgICAgIGNlbGxXaWR0aCA9IGVuY29kaW5nLmNvbmZpZygndGV4dENlbGxXaWR0aCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShYKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgY2VsbEhlaWdodFxuICBpZiAoaGFzWSkge1xuICAgIGlmIChlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSkge1xuICAgICAgLy8gZm9yIG9yZGluYWwsIGhhc0NvbCBvciBub3QgZG9lc24ndCBtYXR0ZXIgLS0gd2Ugc2NhbGUgYmFzZWQgb24gY2FyZGluYWxpdHlcbiAgICAgIGNlbGxIZWlnaHQgPSAoeUNhcmRpbmFsaXR5ICsgZW5jb2RpbmcuZmllbGQoWSkuYmFuZC5wYWRkaW5nKSAqIGVuY29kaW5nLmJhbmRTaXplKFksIHVzZVNtYWxsQmFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxIZWlnaHQgPSBoYXNDb2wgfHwgaGFzUm93ID8gZW5jb2RpbmcuZmllbGQoUk9XKS5oZWlnaHQgOiAgZW5jb2RpbmcuY29uZmlnKCdzaW5nbGVIZWlnaHQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2VsbEhlaWdodCA9IGVuY29kaW5nLmJhbmRTaXplKFkpO1xuICB9XG5cbiAgLy8gQ2VsbCBiYW5kcyB1c2UgcmFuZ2VCYW5kcygpLiBUaGVyZSBhcmUgbi0xIHBhZGRpbmcuICBPdXRlcnBhZGRpbmcgPSAwIGZvciBjZWxsc1xuXG4gIHZhciB3aWR0aCA9IGNlbGxXaWR0aCwgaGVpZ2h0ID0gY2VsbEhlaWdodDtcbiAgaWYgKGhhc0NvbCkge1xuICAgIHZhciBjb2xDYXJkaW5hbGl0eSA9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIHdpZHRoID0gY2VsbFdpZHRoICogKCgxICsgY2VsbFBhZGRpbmcpICogKGNvbENhcmRpbmFsaXR5IC0gMSkgKyAxKTtcbiAgfVxuICBpZiAoaGFzUm93KSB7XG4gICAgdmFyIHJvd0NhcmRpbmFsaXR5ID0gIGVuY29kaW5nLmNhcmRpbmFsaXR5KFJPVywgc3RhdHMpO1xuICAgIGhlaWdodCA9IGNlbGxIZWlnaHQgKiAoKDEgKyBjZWxsUGFkZGluZykgKiAocm93Q2FyZGluYWxpdHkgLSAxKSArIDEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB3aG9sZSBjZWxsXG4gICAgY2VsbFdpZHRoOiBjZWxsV2lkdGgsXG4gICAgY2VsbEhlaWdodDogY2VsbEhlaWdodCxcbiAgICBjZWxsUGFkZGluZzogY2VsbFBhZGRpbmcsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2hhcnRcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgeCBhbmQgeSwgc3VjaCBhcyBiYW5kIHNpemVcbiAgICB4OiB7dXNlU21hbGxCYW5kOiB1c2VTbWFsbEJhbmR9LFxuICAgIHk6IHt1c2VTbWFsbEJhbmQ6IHVzZVNtYWxsQmFuZH1cbiAgfTtcbn1cblxuXG4vLyBGSVhNRSBmaWVsZFN0YXRzLm1heCBpc24ndCBhbHdheXMgdGhlIGxvbmdlc3RcbmZ1bmN0aW9uIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpIHtcbiAgdmFyIGZvcm1hdCA9IGVuY29kaW5nLm51bWJlckZvcm1hdChldCwgZmllbGRTdGF0cyk7XG5cbiAgcmV0dXJuIGQzX2Zvcm1hdC5mb3JtYXQoZm9ybWF0KShmaWVsZFN0YXRzLm1heCkubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBnZXRNYXhMZW5ndGgoZW5jb2RpbmcsIHN0YXRzLCBldCkge1xuICB2YXIgZmllbGQgPSBlbmNvZGluZy5maWVsZChldCksXG4gICAgZmllbGRTdGF0cyA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuXG4gIGlmIChmaWVsZC5iaW4pIHtcbiAgICAvLyBUT0RPIG9uY2UgYmluIHN1cHBvcnQgcmFuZ2UsIG5lZWQgdG8gdXBkYXRlIHRoaXNcbiAgICByZXR1cm4gZ2V0TWF4TnVtYmVyTGVuZ3RoKGVuY29kaW5nLCBldCwgZmllbGRTdGF0cyk7XG4gIH0gaWYgKGVuY29kaW5nLmlzVHlwZShldCwgUSkpIHtcbiAgICByZXR1cm4gZ2V0TWF4TnVtYmVyTGVuZ3RoKGVuY29kaW5nLCBldCwgZmllbGRTdGF0cyk7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKGV0LCBUKSkge1xuICAgIHJldHVybiB0aW1lLm1heExlbmd0aChlbmNvZGluZy5maWVsZChldCkudGltZVVuaXQsIGVuY29kaW5nKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGVzKGV0LCBbTiwgT10pKSB7XG4gICAgaWYoZmllbGRTdGF0cy50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oZmllbGRTdGF0cy5tYXgsIGVuY29kaW5nLmF4aXMoZXQpLm1heExhYmVsTGVuZ3RoIHx8IEluZmluaXR5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KGVuY29kaW5nLCBzdGF0cywgbGF5b3V0KSB7XG4gIFtYLCBZXS5mb3JFYWNoKGZ1bmN0aW9uIChldCkge1xuICAgIC8vIFRPRE8oa2FuaXR3KTogSnVsIDE5LCAyMDE1IC0gY3JlYXRlIGEgc2V0IG9mIHZpc3VhbCB0ZXN0IGZvciBleHRyYU9mZnNldFxuICAgIHZhciBleHRyYU9mZnNldCA9IGV0ID09PSBYID8gMjAgOiAyMixcbiAgICAgIG1heExlbmd0aDtcbiAgICBpZiAoZW5jb2RpbmcuaXNEaW1lbnNpb24oZXQpIHx8IGVuY29kaW5nLmlzVHlwZShldCwgVCkpIHtcbiAgICAgIG1heExlbmd0aCA9IGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gVE9ETyBvbmNlIHdlIGhhdmUgIzUxMiAoYWxsb3cgdXNpbmcgaW5mZXJyZWQgdHlwZSlcbiAgICAgIC8vIE5lZWQgdG8gYWRqdXN0IGNvbmRpdGlvbiBoZXJlLlxuICAgICAgZW5jb2RpbmcuaXNUeXBlKGV0LCBRKSB8fFxuICAgICAgZW5jb2RpbmcuYWdncmVnYXRlKGV0KSA9PT0gJ2NvdW50J1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBldD09PVlcbiAgICAgICAgLy8gfHwgKGV0PT09WCAmJiBmYWxzZSlcbiAgICAgICAgLy8gRklYTUUgZGV0ZXJtaW5lIHdoZW4gWCB3b3VsZCByb3RhdGUsIGJ1dCBzaG91bGQgbW92ZSB0aGlzIHRvIGF4aXMuanMgZmlyc3QgIzUwNlxuICAgICAgKSB7XG4gICAgICAgIG1heExlbmd0aCA9IGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90aGluZ1xuICAgIH1cblxuICAgIGlmIChtYXhMZW5ndGgpIHtcbiAgICAgIHNldHRlcihsYXlvdXQsW2V0LCAnYXhpc1RpdGxlT2Zmc2V0J10sIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKSAqICBtYXhMZW5ndGggKyBleHRyYU9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vIG1heCBsZW5ndGggKG5vIHJvdGF0aW9uIGNhc2UpLCB1c2UgbWF4TGVuZ3RoID0gM1xuICAgICAgc2V0dGVyKGxheW91dCxbZXQsICdheGlzVGl0bGVPZmZzZXQnXSwgZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpICogMyArIGV4dHJhT2Zmc2V0KTtcbiAgICB9XG5cbiAgfSk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIGxlZ2VuZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmxlZ2VuZC5kZWZzID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIGRlZnMgPSBbXTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhbHBoYVxuXG4gIGlmIChlbmNvZGluZy5oYXMoQ09MT1IpICYmIGVuY29kaW5nLmZpZWxkKENPTE9SKS5sZWdlbmQpIHtcbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihDT0xPUiwgZW5jb2RpbmcsIHtcbiAgICAgIGZpbGw6IENPTE9SLFxuICAgICAgb3JpZW50OiAncmlnaHQnXG4gICAgfSkpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmhhcyhTSVpFKSAmJiBlbmNvZGluZy5maWVsZChTSVpFKS5sZWdlbmQpIHtcbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihTSVpFLCBlbmNvZGluZywge1xuICAgICAgc2l6ZTogU0laRSxcbiAgICAgIG9yaWVudDogZGVmcy5sZW5ndGggPT09IDEgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgfSkpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmhhcyhTSEFQRSkgJiYgZW5jb2RpbmcuZmllbGQoU0hBUEUpLmxlZ2VuZCkge1xuICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMikge1xuICAgICAgLy8gVE9ETzogZml4IHRoaXNcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1ZlZ2EtbGl0ZSBjdXJyZW50bHkgb25seSBzdXBwb3J0cyB0d28gbGVnZW5kcycpO1xuICAgICAgcmV0dXJuIGRlZnM7XG4gICAgfVxuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKFNIQVBFLCBlbmNvZGluZywge1xuICAgICAgc2hhcGU6IFNIQVBFLFxuICAgICAgb3JpZW50OiBkZWZzLmxlbmd0aCA9PT0gMSA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gZGVmcztcbn07XG5cbmxlZ2VuZC5kZWYgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZywgcHJvcHMpIHtcbiAgdmFyIGRlZiA9IHByb3BzLFxuICAgIHRpbWVVbml0ID0gZW5jb2RpbmcuZmllbGQobmFtZSkudGltZVVuaXQ7XG5cbiAgZGVmLnRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmXG4gICAgdGltZVVuaXQgJiZcbiAgICB0aW1lLmhhc1NjYWxlKHRpbWVVbml0KVxuICApIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGRlZi5wcm9wZXJ0aWVzID0gZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBsYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyA9IHByb3BlcnRpZXMubGFiZWxzIHx8IHt9LFxuICAgICAgdGV4dCA9IGxhYmVscy50ZXh0ID0gbGFiZWxzLnRleHQgfHwge307XG5cbiAgICB0ZXh0LnNjYWxlID0gJ3RpbWUtJysgdGltZVVuaXQ7XG4gIH1cblxuICByZXR1cm4gZGVmO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgbWFya3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXJrcy5kZWYgPSBmdW5jdGlvbihtYXJrLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpIHtcbiAgdmFyIGRlZnMgPSBbXTtcblxuICAvLyB0byBhZGQgYSBiYWNrZ3JvdW5kIHRvIHRleHQsIHdlIG5lZWQgdG8gYWRkIGl0IGJlZm9yZSB0aGUgdGV4dFxuICBpZiAoZW5jb2RpbmcubWFya3R5cGUoKSA9PT0gVEVYVCAmJiBlbmNvZGluZy5oYXMoQ09MT1IpKSB7XG4gICAgdmFyIGJnID0ge1xuICAgICAgeDoge3ZhbHVlOiAwfSxcbiAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICB4Mjoge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRofSxcbiAgICAgIHkyOiB7dmFsdWU6IGxheW91dC5jZWxsSGVpZ2h0fSxcbiAgICAgIGZpbGw6IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihDT0xPUil9XG4gICAgfTtcbiAgICBkZWZzLnB1c2goe1xuICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgZnJvbToge2RhdGE6IFRBQkxFfSxcbiAgICAgIHByb3BlcnRpZXM6IHtlbnRlcjogYmcsIHVwZGF0ZTogYmd9XG4gICAgfSk7XG4gIH1cblxuICAvLyBhZGQgdGhlIG1hcmsgZGVmIGZvciB0aGUgbWFpbiB0aGluZ1xuICB2YXIgcCA9IG1hcmsucHJvcChlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpO1xuICBkZWZzLnB1c2goe1xuICAgIHR5cGU6IG1hcmsudHlwZSxcbiAgICBmcm9tOiB7ZGF0YTogVEFCTEV9LFxuICAgIHByb3BlcnRpZXM6IHtlbnRlcjogcCwgdXBkYXRlOiBwfVxuICB9KTtcblxuICByZXR1cm4gZGVmcztcbn07XG5cbm1hcmtzLmJhciA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzdGFjazogdHJ1ZSxcbiAgcHJvcDogYmFyX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMX1cbn07XG5cbm1hcmtzLmxpbmUgPSB7XG4gIHR5cGU6ICdsaW5lJyxcbiAgbGluZTogdHJ1ZSxcbiAgcHJvcDogbGluZV9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGRldGFpbDoxfVxufTtcblxubWFya3MuYXJlYSA9IHtcbiAgdHlwZTogJ2FyZWEnLFxuICBzdGFjazogdHJ1ZSxcbiAgbGluZTogdHJ1ZSxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgcHJvcDogYXJlYV9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDF9XG59O1xuXG5tYXJrcy50aWNrID0ge1xuICB0eXBlOiAncmVjdCcsXG4gIHByb3A6IHRpY2tfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy5jaXJjbGUgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBmaWxsZWRfcG9pbnRfcHJvcHMoJ2NpcmNsZScpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3Muc3F1YXJlID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKCdzcXVhcmUnKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IG1hcmtzLmNpcmNsZS5zdXBwb3J0ZWRFbmNvZGluZ1xufTtcblxubWFya3MucG9pbnQgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBwb2ludF9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIHNoYXBlOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy50ZXh0ID0ge1xuICB0eXBlOiAndGV4dCcsXG4gIHByb3A6IHRleHRfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsndGV4dCddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCBzaXplOiAxLCBjb2xvcjogMSwgdGV4dDogMX1cbn07XG5cbmZ1bmN0aW9uIGJhcl9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHgncyBhbmQgd2lkdGhcbiAgaWYgKGUuaXNNZWFzdXJlKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgaWYgKCFlLmhhcyhZKSB8fCBlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3ZhbHVlOiAwfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUuaGFzKFgpKSB7IC8vIGlzIG9yZGluYWxcbiAgICAgICBwLnhjID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgfSBlbHNlIHtcbiAgICAgICBwLnggPSB7dmFsdWU6IDAsIG9mZnNldDogZS5jb25maWcoJ3NpbmdsZUJhck9mZnNldCcpfTtcbiAgICB9XG4gIH1cblxuICAvLyB3aWR0aFxuICBpZiAoIXAueDIpIHtcbiAgICBpZiAoIWUuaGFzKFgpIHx8IGUuaXNPcmRpbmFsU2NhbGUoWCkpIHsgLy8gbm8gWCBvciBYIGlzIG9yZGluYWxcbiAgICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgICBwLndpZHRoID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwLndpZHRoID0ge1xuICAgICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCksXG4gICAgICAgICAgb2Zmc2V0OiAtMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIFggaXMgUXVhbnQgb3IgVGltZSBTY2FsZVxuICAgICAgcC53aWR0aCA9IHt2YWx1ZTogMn07XG4gICAgfVxuICB9XG5cbiAgLy8geSdzICYgaGVpZ2h0XG4gIGlmIChlLmlzTWVhc3VyZShZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICAgIHAueTIgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5oYXMoWSkpIHsgLy8gaXMgb3JkaW5hbFxuICAgICAgcC55YyA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnkyID0ge2dyb3VwOiAnaGVpZ2h0Jywgb2Zmc2V0OiAtZS5jb25maWcoJ3NpbmdsZUJhck9mZnNldCcpfTtcbiAgICB9XG5cbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuaGVpZ2h0ID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuaGVpZ2h0ID0ge1xuICAgICAgICB2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpLFxuICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBvcGFjaXR5XG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBvaW50X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGRSZWYoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gIH1cblxuICAvLyBzaGFwZVxuICBpZiAoZS5oYXMoU0hBUEUpKSB7XG4gICAgcC5zaGFwZSA9IHtzY2FsZTogU0hBUEUsIGZpZWxkOiBlLmZpZWxkUmVmKFNIQVBFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7dmFsdWU6IGUudmFsdWUoU0hBUEUpfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5maWVsZChTSEFQRSkuZmlsbGVkKSB7XG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgIH1cbiAgICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZygnc3Ryb2tlV2lkdGgnKX07XG4gIH1cblxuICAvLyBvcGFjaXR5XG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eSAgfHwgc3R5bGUub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGxpbmVfcHJvcHMoZSxsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gYXJlYV9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogMH07XG4gICAgICBwLm9yaWVudCA9IHt2YWx1ZTogJ2hvcml6b250YWwnfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogMH07XG4gIH0gZWxzZSBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdGlja19wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihYKSkge1xuICAgICAgcC54Lm9mZnNldCA9IC1lLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC55Lm9mZnNldCA9IC1lLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgcC53aWR0aCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogMX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5ICB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRfcG9pbnRfcHJvcHMoc2hhcGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgLy8geFxuICAgIGlmIChlLmhhcyhYKSkge1xuICAgICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuXG4gICAgLy8geVxuICAgIGlmIChlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuXG4gICAgLy8gc2l6ZVxuICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgcC5zaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gICAgfVxuXG4gICAgLy8gc2hhcGVcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBzaGFwZX07XG5cbiAgICAvLyBmaWxsXG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eSAgfHwgc3R5bGUub3BhY2l0eTtcbiAgICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gICAgcmV0dXJuIHA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSwgc3RhdHMpIHtcbiAgdmFyIHAgPSB7fSxcbiAgICBmaWVsZCA9IGUuZmllbGQoVEVYVCk7XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBpZiAoZS5oYXMoVEVYVCkgJiYgZS5pc1R5cGUoVEVYVCwgUSkpIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aC01fTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC54ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuZm9udFNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3ZhbHVlOiBmaWVsZC5mb250LnNpemV9O1xuICB9XG5cbiAgLy8gZmlsbFxuICAvLyBjb2xvciBzaG91bGQgYmUgc2V0IHRvIGJhY2tncm91bmRcbiAgcC5maWxsID0ge3ZhbHVlOiBmaWVsZC50ZXh0LmNvbG9yfTtcblxuICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHkgIHx8IHN0eWxlLm9wYWNpdHk7XG4gIGlmKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgLy8gdGV4dFxuICBpZiAoZS5oYXMoVEVYVCkpIHtcbiAgICBpZiAoZS5pc1R5cGUoVEVYVCwgUSkpIHtcbiAgICAgIHZhciBmaWVsZFN0YXRzID0gc3RhdHNbZS5maWVsZE5hbWUobmFtZSldLFxuICAgICAgICBudW1iZXJGb3JtYXQgPSBmaWVsZC5mb3JtYXQgfHwgZS5udW1iZXJGb3JtYXQoZmllbGRTdGF0cyk7XG5cbiAgICAgIHAudGV4dCA9IHt0ZW1wbGF0ZTogJ3t7JyArIGUuZmllbGRSZWYoVEVYVCkgKyAnIHwgbnVtYmVyOlxcJycgK1xuICAgICAgICBudW1iZXJGb3JtYXQgKydcXCd9fSd9O1xuICAgICAgcC5hbGlnbiA9IHt2YWx1ZTogZmllbGQuYWxpZ259O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnRleHQgPSB7ZmllbGQ6IGUuZmllbGRSZWYoVEVYVCl9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLnRleHQgPSB7dmFsdWU6IGZpZWxkLnBsYWNlaG9sZGVyfTtcbiAgfVxuXG4gIHAuZm9udCA9IHt2YWx1ZTogZmllbGQuZm9udC5mYW1pbHl9O1xuICBwLmZvbnRXZWlnaHQgPSB7dmFsdWU6IGZpZWxkLmZvbnQud2VpZ2h0fTtcbiAgcC5mb250U3R5bGUgPSB7dmFsdWU6IGZpZWxkLmZvbnQuc3R5bGV9O1xuICBwLmJhc2VsaW5lID0ge3ZhbHVlOiBmaWVsZC5iYXNlbGluZX07XG5cbiAgcmV0dXJuIHA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICBjb2xvcmJyZXdlciA9IHJlcXVpcmUoJ2NvbG9yYnJld2VyJyksXG4gIGludGVycG9sYXRlTGFiID0gcmVxdWlyZSgnZDMtY29sb3InKS5pbnRlcnBvbGF0ZUxhYixcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hL3NjaGVtYScpO1xuXG52YXIgc2NhbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5zY2FsZS5uYW1lcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gIHJldHVybiB1dGlsLmtleXModXRpbC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgIGlmIChwcm9wc1t4XSAmJiBwcm9wc1t4XS5zY2FsZSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufTtcblxuc2NhbGUuZGVmcyA9IGZ1bmN0aW9uKG5hbWVzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgc3R5bGUsIHNvcnRpbmcsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihhLCBuYW1lKSB7XG4gICAgdmFyIHMgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdHlwZTogc2NhbGUudHlwZShuYW1lLCBlbmNvZGluZyksXG4gICAgICBkb21haW46IHNjYWxlLmRvbWFpbihuYW1lLCBlbmNvZGluZywgc3RhdHMsIHNvcnRpbmcsIG9wdClcbiAgICB9O1xuXG4gICAgcy5zb3J0ID0gc2NhbGUuc29ydChzLCBlbmNvZGluZywgbmFtZSkgfHwgdW5kZWZpbmVkO1xuXG4gICAgc2NhbGUucmFuZ2UocywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCk7XG5cbiAgICByZXR1cm4gKGEucHVzaChzKSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbnNjYWxlLnNvcnQgPSBmdW5jdGlvbihzLCBlbmNvZGluZywgbmFtZSkge1xuICByZXR1cm4gcy50eXBlID09PSAnb3JkaW5hbCcgJiYgKFxuICAgICEhZW5jb2RpbmcuYmluKG5hbWUpIHx8XG4gICAgZW5jb2Rpbmcuc29ydChuYW1lKS5sZW5ndGggPT09IDBcbiAgKTtcbn07XG5cbnNjYWxlLnR5cGUgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZykge1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcudHlwZShuYW1lKSkge1xuICAgIGNhc2UgTjogLy9mYWxsIHRocm91Z2hcbiAgICBjYXNlIE86IHJldHVybiAnb3JkaW5hbCc7XG4gICAgY2FzZSBUOlxuICAgICAgdmFyIHRpbWVVbml0ID0gZW5jb2RpbmcuZmllbGQobmFtZSkudGltZVVuaXQ7XG4gICAgICByZXR1cm4gdGltZVVuaXQgPyB0aW1lLnNjYWxlLnR5cGUodGltZVVuaXQsIG5hbWUpIDogJ3RpbWUnO1xuICAgIGNhc2UgUTpcbiAgICAgIGlmIChlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09IENPTE9SID8gJ2xpbmVhcicgOiAnb3JkaW5hbCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2Rpbmcuc2NhbGUobmFtZSkudHlwZTtcbiAgfVxufTtcblxuc2NhbGUuZG9tYWluID0gZnVuY3Rpb24gKG5hbWUsIGVuY29kaW5nLCBzdGF0cywgc29ydGluZywgb3B0KSB7XG4gIHZhciBmaWVsZCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpO1xuXG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aW1lLnNjYWxlLmRvbWFpbihmaWVsZC50aW1lVW5pdCwgbmFtZSk7XG4gICAgaWYocmFuZ2UpIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIGlmIChmaWVsZC5iaW4pIHtcbiAgICAvLyBUT0RPKGthbml0dyk6IHRoaXMgbXVzdCBiZSBjaGFuZ2VkIGluIHZnMlxuICAgIHZhciBmaWVsZFN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXSxcbiAgICAgIGJpbnMgPSB1dGlsLmdldGJpbnMoZmllbGRTdGF0LCBmaWVsZC5iaW4ubWF4YmlucyB8fCBzY2hlbWEuTUFYQklOU19ERUZBVUxUKSxcbiAgICAgIG51bWJpbnMgPSAoYmlucy5zdG9wIC0gYmlucy5zdGFydCkgLyBiaW5zLnN0ZXA7XG4gICAgcmV0dXJuIHV0aWwucmFuZ2UobnVtYmlucykubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBiaW5zLnN0YXJ0ICsgYmlucy5zdGVwICogaTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChuYW1lID09IG9wdC5zdGFjaykge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBTVEFDS0VELFxuICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKG5hbWUsIHtcbiAgICAgICAgZGF0YTogIWVuY29kaW5nLl92ZWdhMixcbiAgICAgICAgcHJlZm46IChvcHQuZmFjZXQgPyAnbWF4XycgOiAnJykgKyAnc3VtXydcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB2YXIgYWdncmVnYXRlID0gZW5jb2RpbmcuYWdncmVnYXRlKG5hbWUpLFxuICAgIHRpbWVVbml0ID0gZmllbGQudGltZVVuaXQsXG4gICAgc2NhbGVVc2VSYXdEb21haW4gPSBlbmNvZGluZy5zY2FsZShuYW1lKS51c2VSYXdEb21haW4sXG4gICAgdXNlUmF3RG9tYWluID0gc2NhbGVVc2VSYXdEb21haW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICBzY2FsZVVzZVJhd0RvbWFpbiA6IGVuY29kaW5nLmNvbmZpZygndXNlUmF3RG9tYWluJyksXG4gICAgbm90Q291bnRPclN1bSA9ICFhZ2dyZWdhdGUgfHwgKGFnZ3JlZ2F0ZSAhPT0nY291bnQnICYmIGFnZ3JlZ2F0ZSAhPT0gJ3N1bScpO1xuXG4gIGlmICggdXNlUmF3RG9tYWluICYmIG5vdENvdW50T3JTdW0gJiYgKFxuICAgICAgLy8gUSBhbHdheXMgdXNlcyBub24tb3JkaW5hbCBzY2FsZSBleGNlcHQgd2hlbiBpdCdzIGJpbm5lZCBhbmQgdGh1cyB1c2VzIG9yZGluYWwgc2NhbGUuXG4gICAgICAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFEpICYmICFmaWVsZC5iaW4pIHx8XG4gICAgICAvLyBUIHVzZXMgbm9uLW9yZGluYWwgc2NhbGUgd2hlbiB0aGVyZSdzIG5vIHVuaXQgb3Igd2hlbiB0aGUgdW5pdCBpcyBub3Qgb3JkaW5hbC5cbiAgICAgIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgKCF0aW1lVW5pdCB8fCAhdGltZS5pc09yZGluYWxGbih0aW1lVW5pdCkpKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHtkYXRhOiBSQVcsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihuYW1lLCB7bm9mbjogIXRpbWVVbml0fSl9O1xuICB9XG5cbiAgcmV0dXJuIHtkYXRhOiBzb3J0aW5nLmdldERhdGFzZXQobmFtZSksIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihuYW1lKX07XG59O1xuXG5cbnNjYWxlLnJhbmdlID0gZnVuY3Rpb24gKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSB7XG4gIHZhciBzcGVjID0gZW5jb2Rpbmcuc2NhbGUocy5uYW1lKSxcbiAgICBmaWVsZCA9IGVuY29kaW5nLmZpZWxkKHMubmFtZSksXG4gICAgdGltZVVuaXQgPSBmaWVsZC50aW1lVW5pdDtcblxuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgWDpcbiAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbFdpZHRoID8gWzAsIGxheW91dC5jZWxsV2lkdGhdIDogJ3dpZHRoJztcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSxUKSAmJiB0aW1lVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAocy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgcy5uaWNlID0gdGltZVVuaXQgfHwgZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVOaWNlJyk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFk6XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgcy5yYW5nZSA9IGxheW91dC5jZWxsSGVpZ2h0ID9cbiAgICAgICAgICAoZmllbGQuYmluID8gW2xheW91dC5jZWxsSGVpZ2h0LCAwXSA6IFswLCBsYXlvdXQuY2VsbEhlaWdodF0pIDpcbiAgICAgICAgICAnaGVpZ2h0JztcbiAgICAgICAgcy5iYW5kV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5yYW5nZSA9IGxheW91dC5jZWxsSGVpZ2h0ID8gW2xheW91dC5jZWxsSGVpZ2h0LCAwXSA6ICdoZWlnaHQnO1xuICAgICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSxUKSAmJiB0aW1lVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuXG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IHRpbWVVbml0IHx8IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTmljZScpO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBST1c6IC8vIHN1cHBvcnQgb25seSBvcmRpbmFsXG4gICAgICBzLmJhbmRXaWR0aCA9IGxheW91dC5jZWxsSGVpZ2h0O1xuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDT0w6IC8vIHN1cHBvcnQgb25seSBvcmRpbmFsXG4gICAgICBzLmJhbmRXaWR0aCA9IGxheW91dC5jZWxsV2lkdGg7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJWkU6XG4gICAgICBpZiAoZW5jb2RpbmcuaXMoJ2JhcicpKSB7XG4gICAgICAgIC8vIEZJWE1FIHRoaXMgaXMgZGVmaW5pdGVseSBpbmNvcnJlY3RcbiAgICAgICAgLy8gYnV0IGxldCdzIGZpeCBpdCBsYXRlciBzaW5jZSBiYXIgc2l6ZSBpcyBhIGJhZCBlbmNvZGluZyBhbnl3YXlcbiAgICAgICAgcy5yYW5nZSA9IFszLCBNYXRoLm1heChlbmNvZGluZy5iYW5kU2l6ZShYKSwgZW5jb2RpbmcuYmFuZFNpemUoWSkpXTtcbiAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXMoVEVYVCkpIHtcbiAgICAgICAgcy5yYW5nZSA9IFs4LCA0MF07XG4gICAgICB9IGVsc2UgeyAvL3BvaW50XG4gICAgICAgIHZhciBiYW5kU2l6ZSA9IE1hdGgubWluKGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSkgLSAxO1xuICAgICAgICBzLnJhbmdlID0gWzEwLCAwLjggKiBiYW5kU2l6ZSpiYW5kU2l6ZV07XG4gICAgICB9XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSEFQRTpcbiAgICAgIHMucmFuZ2UgPSAnc2hhcGVzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ09MT1I6XG4gICAgICBzLnJhbmdlID0gc2NhbGUuY29sb3IocywgZW5jb2RpbmcsIHN0YXRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgbmFtZTogJysgcy5uYW1lKTtcbiAgfVxuXG4gIHN3aXRjaCAocy5uYW1lKSB7XG4gICAgY2FzZSBST1c6XG4gICAgY2FzZSBDT0w6XG4gICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5jb25maWcoJ2NlbGxQYWRkaW5nJyk7XG4gICAgICBzLm91dGVyUGFkZGluZyA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFg6XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7IC8vJiYgIXMuYmFuZFdpZHRoXG4gICAgICAgIHMucG9pbnRzID0gdHJ1ZTtcbiAgICAgICAgcy5wYWRkaW5nID0gZW5jb2RpbmcuZmllbGQocy5uYW1lKS5iYW5kLnBhZGRpbmc7XG4gICAgICB9XG4gIH1cbn07XG5cbnNjYWxlLmNvbG9yID0gZnVuY3Rpb24ocywgZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBjb2xvclNjYWxlID0gZW5jb2Rpbmcuc2NhbGUoQ09MT1IpLFxuICAgIHJhbmdlID0gY29sb3JTY2FsZS5yYW5nZSxcbiAgICBjYXJkaW5hbGl0eSA9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTE9SLCBzdGF0cyksXG4gICAgdHlwZSA9IGVuY29kaW5nLnR5cGUoQ09MT1IpO1xuXG4gIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG9yZGluYWxQYWxldHRlID0gY29sb3JTY2FsZS5vcmRpbmFsUGFsZXR0ZTtcbiAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGlmICh0eXBlID09PSBOKSB7XG4gICAgICAgIC8vIHVzZSBjYXRlZ29yaWNhbCBjb2xvciBzY2FsZVxuICAgICAgICBpZiAoY2FyZGluYWxpdHkgPD0gMTApIHtcbiAgICAgICAgICByYW5nZSA9IGNvbG9yU2NhbGUuYzEwcGFsZXR0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZSA9IGNvbG9yU2NhbGUuYzIwcGFsZXR0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhcmRpbmFsaXR5IDw9IDIpIHtcbiAgICAgICAgICByYW5nZSA9IFtjb2xvcmJyZXdlcltvcmRpbmFsUGFsZXR0ZV1bM11bMF0sIGNvbG9yYnJld2VyW29yZGluYWxQYWxldHRlXVszXVsyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UgPSBvcmRpbmFsUGFsZXR0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vdGltZSBvciBxdWFudGl0YXRpdmVcbiAgICAgIHZhciBwYWxldHRlID0gY29sb3JicmV3ZXJbb3JkaW5hbFBhbGV0dGVdWzldO1xuICAgICAgcmFuZ2UgPSBbcGFsZXR0ZVswXSwgcGFsZXR0ZVs4XV07XG4gICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjYWxlLmNvbG9yLnBhbGV0dGUocmFuZ2UsIGNhcmRpbmFsaXR5LCB0eXBlKTtcbn07XG5cbnNjYWxlLmNvbG9yLnBhbGV0dGUgPSBmdW5jdGlvbihyYW5nZSwgY2FyZGluYWxpdHksIHR5cGUpIHtcbiAgc3dpdGNoIChyYW5nZSkge1xuICAgIGNhc2UgJ2NhdGVnb3J5MTBrJzpcbiAgICAgIC8vIHRhYmxlYXUncyBjYXRlZ29yeSAxMCwgb3JkZXJlZCBieSBwZXJjZXB0dWFsIGtlcm5lbCBzdHVkeSByZXN1bHRzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdXdkYXRhL3BlcmNlcHR1YWwta2VybmVsc1xuICAgICAgcmV0dXJuIFsnIzJjYTAyYycsICcjZTM3N2MyJywgJyM3ZjdmN2YnLCAnIzE3YmVjZicsICcjOGM1NjRiJywgJyNkNjI3MjgnLCAnI2JjYmQyMicsICcjOTQ2N2JkJywgJyNmZjdmMGUnLCAnIzFmNzdiNCddO1xuXG4gICAgLy8gZDMvdGFibGVhdSBjYXRlZ29yeTEwLzIwLzIwYi8yMGNcbiAgICBjYXNlICdjYXRlZ29yeTEwJzpcbiAgICAgIHJldHVybiBbJyMxZjc3YjQnLCAnI2ZmN2YwZScsICcjMmNhMDJjJywgJyNkNjI3MjgnLCAnIzk0NjdiZCcsICcjOGM1NjRiJywgJyNlMzc3YzInLCAnIzdmN2Y3ZicsICcjYmNiZDIyJywgJyMxN2JlY2YnXTtcblxuICAgIGNhc2UgJ2NhdGVnb3J5MjAnOlxuICAgICAgcmV0dXJuIFsnIzFmNzdiNCcsICcjYWVjN2U4JywgJyNmZjdmMGUnLCAnI2ZmYmI3OCcsICcjMmNhMDJjJywgJyM5OGRmOGEnLCAnI2Q2MjcyOCcsICcjZmY5ODk2JywgJyM5NDY3YmQnLCAnI2M1YjBkNScsICcjOGM1NjRiJywgJyNjNDljOTQnLCAnI2UzNzdjMicsICcjZjdiNmQyJywgJyM3ZjdmN2YnLCAnI2M3YzdjNycsICcjYmNiZDIyJywgJyNkYmRiOGQnLCAnIzE3YmVjZicsICcjOWVkYWU1J107XG5cbiAgICBjYXNlICdjYXRlZ29yeTIwYic6XG4gICAgICByZXR1cm4gWycjMzkzYjc5JywgJyM1MjU0YTMnLCAnIzZiNmVjZicsICcjOWM5ZWRlJywgJyM2Mzc5MzknLCAnIzhjYTI1MicsICcjYjVjZjZiJywgJyNjZWRiOWMnLCAnIzhjNmQzMScsICcjYmQ5ZTM5JywgJyNlN2JhNTInLCAnI2U3Y2I5NCcsICcjODQzYzM5JywgJyNhZDQ5NGEnLCAnI2Q2NjE2YicsICcjZTc5NjljJywgJyM3YjQxNzMnLCAnI2E1NTE5NCcsICcjY2U2ZGJkJywgJyNkZTllZDYnXTtcblxuICAgIGNhc2UgJ2NhdGVnb3J5MjBjJzpcbiAgICAgIHJldHVybiBbJyMzMTgyYmQnLCAnIzZiYWVkNicsICcjOWVjYWUxJywgJyNjNmRiZWYnLCAnI2U2NTUwZCcsICcjZmQ4ZDNjJywgJyNmZGFlNmInLCAnI2ZkZDBhMicsICcjMzFhMzU0JywgJyM3NGM0NzYnLCAnI2ExZDk5YicsICcjYzdlOWMwJywgJyM3NTZiYjEnLCAnIzllOWFjOCcsICcjYmNiZGRjJywgJyNkYWRhZWInLCAnIzYzNjM2MycsICcjOTY5Njk2JywgJyNiZGJkYmQnLCAnI2Q5ZDlkOSddO1xuICB9XG5cbiAgaWYgKHJhbmdlIGluIGNvbG9yYnJld2VyKSB7XG4gICAgdmFyIHBhbGV0dGUgPSBjb2xvcmJyZXdlcltyYW5nZV0sXG4gICAgICBwcyA9IDU7XG5cbiAgICAvLyBpZiBjYXJkaW5hbGl0eSBwcmUtZGVmaW5lZCwgdXNlIGl0LlxuICAgIGlmIChjYXJkaW5hbGl0eSBpbiBwYWxldHRlKSByZXR1cm4gcGFsZXR0ZVtjYXJkaW5hbGl0eV07XG5cbiAgICAvLyBpZiBub3QsIHVzZSB0aGUgaGlnaGVzdCBjYXJkaW5hbGl0eSBvbmUgZm9yIG5vbWluYWxcbiAgICBpZiAodHlwZSA9PT0gTikge1xuICAgICAgcmV0dXJuIHBhbGV0dGVbTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5rZXlzKHBhbGV0dGUpKV07XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZVxuICAgIHJldHVybiBzY2FsZS5jb2xvci5pbnRlcnBvbGF0ZShwYWxldHRlW3BzXVswXSwgcGFsZXR0ZVtwc11bcHMtMV0sIGNhcmRpbmFsaXR5KTtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn07XG5cbnNjYWxlLmNvbG9yLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNhcmRpbmFsaXR5KSB7XG4gIHZhciBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0ZUxhYihzdGFydCwgZW5kKTtcbiAgcmV0dXJuIHV0aWwucmFuZ2UoY2FyZGluYWxpdHkpLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBpbnRlcnBvbGF0b3IoaSoxLjAvKGNhcmRpbmFsaXR5LTEpKTsgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB2bGZpZWxkID0gcmVxdWlyZSgnLi4vZmllbGQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTb3J0VHJhbnNmb3JtcztcblxuLy8gYWRkcyBuZXcgdHJhbnNmb3JtcyB0aGF0IHByb2R1Y2Ugc29ydGVkIGZpZWxkc1xuZnVuY3Rpb24gYWRkU29ydFRyYW5zZm9ybXMoZGF0YSwgZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuXG4gIHZhciBkYXRhc2V0TWFwcGluZyA9IHt9O1xuICB2YXIgY291bnRlciA9IDA7XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIHZhciBzb3J0QnkgPSBlbmNvZGluZy5zb3J0KGVuY1R5cGUsIHN0YXRzKTtcbiAgICBpZiAoc29ydEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBmaWVsZHMgPSBzb3J0QnkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvcDogZC5hZ2dyZWdhdGUsXG4gICAgICAgICAgZmllbGQ6IHZsZmllbGQuZmllbGRSZWYoZCwge25vZm46IHRydWUsIGRhdGE6ICFlbmNvZGluZy5fdmVnYTJ9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBieUNsYXVzZSA9IHNvcnRCeS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgcmV2ZXJzZSA9IChkLnJldmVyc2UgPyAnLScgOiAnJyk7XG4gICAgICAgIHJldHVybiByZXZlcnNlICsgdmxmaWVsZC5maWVsZFJlZihkLCB7ZGF0YTogIWVuY29kaW5nLl92ZWdhMn0pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBkYXRhTmFtZSA9ICdzb3J0ZWQnICsgY291bnRlcisrO1xuXG4gICAgICB2YXIgdHJhbnNmb3JtcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgIGdyb3VwYnk6IFsgZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSkgXSxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3NvcnQnLFxuICAgICAgICAgIGJ5OiBieUNsYXVzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBuYW1lOiBkYXRhTmFtZSxcbiAgICAgICAgc291cmNlOiBSQVcsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtc1xuICAgICAgfSk7XG5cbiAgICAgIGRhdGFzZXRNYXBwaW5nW2VuY1R5cGVdID0gZGF0YU5hbWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGdldERhdGFzZXQ6IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICAgIHZhciBkYXRhID0gZGF0YXNldE1hcHBpbmdbZW5jVHlwZV07XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFRBQkxFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9O1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja2luZztcblxuZnVuY3Rpb24gc3RhY2tpbmcoZGF0YSwgZW5jb2RpbmcsIG1kZWYsIGZhY2V0cykge1xuICBpZiAoIW1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLnN0YWNrKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHx8IGVuY29kaW5nLmhhcyhMT0QpIGhlcmUgb25jZSBMT0QgaXMgaW1wbGVtZW50ZWRcbiAgaWYgKCFlbmNvZGluZy5oYXMoQ09MT1IpKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRpbT1udWxsLCB2YWw9bnVsbCwgaWR4ID1udWxsLFxuICAgIGlzWE1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWCksXG4gICAgaXNZTWVhc3VyZSA9IGVuY29kaW5nLmlzTWVhc3VyZShZKTtcblxuICBpZiAoaXNYTWVhc3VyZSAmJiAhaXNZTWVhc3VyZSkge1xuICAgIGRpbSA9IFk7XG4gICAgdmFsID0gWDtcbiAgICBpZHggPSAwO1xuICB9IGVsc2UgaWYgKGlzWU1lYXN1cmUgJiYgIWlzWE1lYXN1cmUpIHtcbiAgICBkaW0gPSBYO1xuICAgIHZhbCA9IFk7XG4gICAgaWR4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm8gc3RhY2sgZW5jb2RpbmdcbiAgfVxuXG4gIC8vIGFkZCB0cmFuc2Zvcm0gdG8gY29tcHV0ZSBzdW1zIGZvciBzY2FsZVxuICB2YXIgc3RhY2tlZCA9IHtcbiAgICBuYW1lOiBTVEFDS0VELFxuICAgIHNvdXJjZTogVEFCTEUsXG4gICAgdHJhbnNmb3JtOiBbe1xuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBbZW5jb2RpbmcuZmllbGRSZWYoZGltKV0uY29uY2F0KGZhY2V0cyksIC8vIGRpbSBhbmQgb3RoZXIgZmFjZXRzXG4gICAgICBmaWVsZHM6IFt7b3A6ICdzdW0nLCBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYodmFsKX1dIC8vIFRPRE8gY2hlY2sgaWYgZmllbGQgd2l0aCBhZ2dyZWdhdGUgaXMgY29ycmVjdD9cbiAgICB9XVxuICB9O1xuXG4gIGlmIChmYWNldHMgJiYgZmFjZXRzLmxlbmd0aCA+IDApIHtcbiAgICBzdGFja2VkLnRyYW5zZm9ybS5wdXNoKHsgLy9jYWxjdWxhdGUgbWF4IGZvciBlYWNoIGZhY2V0XG4gICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgIGdyb3VwYnk6IGZhY2V0cyxcbiAgICAgIGZpZWxkczogW3tcbiAgICAgICAgb3A6ICdtYXgnLFxuICAgICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGROYW1lKHZhbCwge2ZuOiAnc3VtJ30pXG4gICAgICB9XVxuICAgIH0pO1xuICB9XG5cbiAgZGF0YS5wdXNoKHN0YWNrZWQpO1xuXG4gIC8vIGFkZCBzdGFjayB0cmFuc2Zvcm0gdG8gbWFya1xuICBtZGVmLmZyb20udHJhbnNmb3JtID0gW3tcbiAgICB0eXBlOiAnc3RhY2snLFxuICAgIHBvaW50OiBlbmNvZGluZy5maWVsZFJlZihkaW0pLFxuICAgIGhlaWdodDogZW5jb2RpbmcuZmllbGRSZWYodmFsKSxcbiAgICBvdXRwdXQ6IHt5MTogdmFsLCB5MDogdmFsICsgJzInfVxuICB9XTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIHN1cGVyIGhhY2staXNoIC0tIGNvbnNvbGlkYXRlIGludG8gbW9kdWxhciBtYXJrIHByb3BlcnRpZXM/XG4gIG1kZWYucHJvcGVydGllcy51cGRhdGVbdmFsXSA9IG1kZWYucHJvcGVydGllcy5lbnRlclt2YWxdID0ge3NjYWxlOiB2YWwsIGZpZWxkOiB2YWx9O1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbCArICcyJ10gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsICsgJzInXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsICsgJzInfTtcblxuICByZXR1cm4gdmFsOyAvL3JldHVybiBzdGFjayBlbmNvZGluZ1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB2bGZpZWxkID0gcmVxdWlyZSgnLi4vZmllbGQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvcGFjaXR5OiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2RpbmcsIHN0YXRzKSxcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGVzdGltYXRlT3BhY2l0eShlbmNvZGluZyxzdGF0cykge1xuICBpZiAoIXN0YXRzKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgbnVtUG9pbnRzID0gMDtcblxuICBpZiAoZW5jb2RpbmcuaXNBZ2dyZWdhdGUoKSkgeyAvLyBhZ2dyZWdhdGUgcGxvdFxuICAgIG51bVBvaW50cyA9IDE7XG5cbiAgICAvLyAgZ2V0IG51bWJlciBvZiBwb2ludHMgaW4gZWFjaCBcImNlbGxcIlxuICAgIC8vICBieSBjYWxjdWxhdGluZyBwcm9kdWN0IG9mIGNhcmRpbmFsaXR5XG4gICAgLy8gIGZvciBlYWNoIG5vbiBmYWNldGluZyBhbmQgbm9uLW9yZGluYWwgWCAvIFkgZmllbGRzXG4gICAgLy8gIG5vdGUgdGhhdCBvcmRpbmFsIHgseSBhcmUgbm90IGluY2x1ZGUgc2luY2Ugd2UgY2FuXG4gICAgLy8gIGNvbnNpZGVyIHRoYXQgb3JkaW5hbCB4IGFyZSBzdWJkaXZpZGluZyB0aGUgY2VsbCBpbnRvIHN1YmNlbGxzIGFueXdheVxuICAgIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcblxuICAgICAgaWYgKGVuY1R5cGUgIT09IFJPVyAmJiBlbmNUeXBlICE9PSBDT0wgJiZcbiAgICAgICAgICAhKChlbmNUeXBlID09PSBYIHx8IGVuY1R5cGUgPT09IFkpICYmXG4gICAgICAgICAgdmxmaWVsZC5pc09yZGluYWxTY2FsZShmaWVsZCkpXG4gICAgICAgICkge1xuICAgICAgICBudW1Qb2ludHMgKj0gZW5jb2RpbmcuY2FyZGluYWxpdHkoZW5jVHlwZSwgc3RhdHMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH0gZWxzZSB7IC8vIHJhdyBwbG90XG5cbiAgICAvLyBUT0RPOiBlcnJvciBoYW5kbGluZ1xuICAgIGlmICghc3RhdHNbJyonXSlcbiAgICAgIHJldHVybiAxO1xuXG4gICAgbnVtUG9pbnRzID0gc3RhdHNbJyonXS5tYXg7ICAvLyBjb3VudFxuXG4gICAgLy8gc21hbGwgbXVsdGlwbGVzIGRpdmlkZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgdmFyIG51bU11bHRpcGxlcyA9IDE7XG4gICAgaWYgKGVuY29kaW5nLmhhcyhST1cpKSB7XG4gICAgICBudW1NdWx0aXBsZXMgKj0gZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZy5oYXMoQ09MKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIH1cbiAgICBudW1Qb2ludHMgLz0gbnVtTXVsdGlwbGVzO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSAwO1xuICBpZiAobnVtUG9pbnRzIDw9IDI1KSB7XG4gICAgb3BhY2l0eSA9IDE7XG4gIH0gZWxzZSBpZiAobnVtUG9pbnRzIDwgMjAwKSB7XG4gICAgb3BhY2l0eSA9IDAuODtcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAxMDAwIHx8IGVuY29kaW5nLmlzKCd0aWNrJykpIHtcbiAgICBvcGFjaXR5ID0gMC43O1xuICB9IGVsc2Uge1xuICAgIG9wYWNpdHkgPSAwLjM7XG4gIH1cblxuICByZXR1cm4gb3BhY2l0eTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBncm91cGRlZiA9IHJlcXVpcmUoJy4vZ3JvdXAnKS5kZWY7XG5cbm1vZHVsZS5leHBvcnRzID0gc3ViZmFjZXRpbmc7XG5cbmZ1bmN0aW9uIHN1YmZhY2V0aW5nKGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBzdGFjaywgZW5jb2RpbmcpIHtcbiAgdmFyIG0gPSBncm91cC5tYXJrcyxcbiAgICBnID0gZ3JvdXBkZWYoJ3N1YmZhY2V0Jywge21hcmtzOiBtfSk7XG5cbiAgZ3JvdXAubWFya3MgPSBbZ107XG4gIGcuZnJvbSA9IG1kZWYuZnJvbTtcbiAgZGVsZXRlIG1kZWYuZnJvbTtcblxuICAvL1RPRE8gdGVzdCBMT0QgLS0gd2Ugc2hvdWxkIHN1cHBvcnQgc3RhY2sgLyBsaW5lIHdpdGhvdXQgY29sb3IgKExPRCkgZmllbGRcbiAgdmFyIHRyYW5zID0gKGcuZnJvbS50cmFuc2Zvcm0gfHwgKGcuZnJvbS50cmFuc2Zvcm0gPSBbXSkpO1xuICB0cmFucy51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBkZXRhaWxzfSk7XG5cbiAgaWYgKHN0YWNrICYmIGVuY29kaW5nLmhhcyhDT0xPUikpIHtcbiAgICB0cmFucy51bnNoaWZ0KHt0eXBlOiAnc29ydCcsIGJ5OiBlbmNvZGluZy5maWVsZFJlZihDT0xPUil9KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBncm91cGRlZiA9IHJlcXVpcmUoJy4vZ3JvdXAnKS5kZWYsXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuLi9maWVsZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShlbmNvZGluZywgbGF5b3V0LCBzdGF0cykge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG5cbiAgdmFyIGRhdGEgPSB7bmFtZTogUkFXLCBmb3JtYXQ6IHt9fSxcbiAgICB0YWJsZSA9IHtuYW1lOiBUQUJMRSwgc291cmNlOiBSQVd9LFxuICAgIGRhdGFVcmwgPSBlbmNvZGluZy5kYXRhKCd1cmwnKSxcbiAgICBkYXRhVHlwZSA9IGVuY29kaW5nLmRhdGEoJ2Zvcm1hdFR5cGUnKSxcbiAgICB2YWx1ZXMgPSBlbmNvZGluZy5kYXRhKCd2YWx1ZXMnKTtcblxuICBpZiAoZW5jb2RpbmcuaGFzVmFsdWVzKCkpIHtcbiAgICBkYXRhLnZhbHVlcyA9IHZhbHVlcztcbiAgfSBlbHNlIHtcbiAgICBkYXRhLnVybCA9IGRhdGFVcmw7XG4gICAgZGF0YS5mb3JtYXQudHlwZSA9IGRhdGFUeXBlO1xuICB9XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIHZhciBuYW1lO1xuICAgIGlmIChmaWVsZC50eXBlID09IFQpIHtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlID0gZGF0YS5mb3JtYXQucGFyc2UgfHwge307XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZVtmaWVsZC5uYW1lXSA9ICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKGZpZWxkLnR5cGUgPT0gUSkge1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2UgPSBkYXRhLmZvcm1hdC5wYXJzZSB8fCB7fTtcbiAgICAgIGlmICh2bGZpZWxkLmlzQ291bnQoZmllbGQpKSB7XG4gICAgICAgIG5hbWUgPSAnY291bnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IGZpZWxkLm5hbWU7XG4gICAgICB9XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZVtuYW1lXSA9ICdudW1iZXInO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbGF5b3V0LndpZHRoLFxuICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCxcbiAgICBwYWRkaW5nOiAnYXV0bycsXG4gICAgZGF0YTogW2RhdGEsIHRhYmxlXSxcbiAgICBtYXJrczogW2dyb3VwZGVmKCdjZWxsJywge1xuICAgICAgd2lkdGg6IGxheW91dC5jZWxsV2lkdGggPyB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGh9IDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiBsYXlvdXQuY2VsbEhlaWdodCA/IHt2YWx1ZTogbGF5b3V0LmNlbGxIZWlnaHR9IDogdW5kZWZpbmVkXG4gICAgfSldXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBkM190aW1lX2Zvcm1hdCA9IHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGltZTtcblxudmFyIExPTkdfREFURSA9IG5ldyBEYXRlKDIwMTQsIDgsIDE3KTtcblxuZnVuY3Rpb24gdGltZShzcGVjLCBlbmNvZGluZykgeyAvLyBGSVhNRSByZWZhY3RvciB0byByZWR1Y2Ugc2lkZSBlZmZlY3QgIzI3NlxuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0aW1lRmllbGRzID0ge30sIHRpbWVVbml0cyA9IHt9O1xuXG4gIC8vIGZpbmQgdW5pcXVlIGZvcm11bGEgdHJhbnNmb3JtYXRpb24gYW5kIGJpbiBmdW5jdGlvblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGZpZWxkLnR5cGUgPT09IFQgJiYgZmllbGQudGltZVVuaXQpIHtcbiAgICAgIHRpbWVGaWVsZHNbZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSldID0ge1xuICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgIGVuY1R5cGU6IGVuY1R5cGVcbiAgICAgIH07XG4gICAgICB0aW1lVW5pdHNbZmllbGQudGltZVVuaXRdID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFkZCBmb3JtdWxhIHRyYW5zZm9ybVxuICB2YXIgZGF0YSA9IHNwZWMuZGF0YVswXSxcbiAgICB0cmFuc2Zvcm0gPSBkYXRhLnRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtIHx8IFtdO1xuXG4gIGZvciAodmFyIGYgaW4gdGltZUZpZWxkcykge1xuICAgIHZhciB0ZiA9IHRpbWVGaWVsZHNbZl07XG4gICAgdGltZS50cmFuc2Zvcm0odHJhbnNmb3JtLCBlbmNvZGluZywgdGYuZW5jVHlwZSwgdGYuZmllbGQpO1xuICB9XG5cbiAgLy8gYWRkIHNjYWxlc1xuICB2YXIgc2NhbGVzID0gc3BlYy5zY2FsZXMgPSBzcGVjLnNjYWxlcyB8fCBbXTtcbiAgZm9yICh2YXIgdGltZVVuaXQgaW4gdGltZVVuaXRzKSB7XG4gICAgdmFyIHNjYWxlID0gdGltZS5zY2FsZS5kZWYodGltZVVuaXQsIGVuY29kaW5nKTtcbiAgICBpZiAoc2NhbGUpIHNjYWxlcy5wdXNoKHNjYWxlKTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn1cblxudGltZS5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSkge1xuICB2YXIgdGltZVVuaXQgPSBmaWVsZC50aW1lVW5pdDtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ3NlY29uZHMnOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnbWludXRlcyc6IHJldHVybiA2MDtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiAyNDtcbiAgICBjYXNlICdkYXknOiByZXR1cm4gNztcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIDMxO1xuICAgIGNhc2UgJ21vbnRoJzogcmV0dXJuIDEyO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgdmFyIHN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXSxcbiAgICAgICAgeWVhcnN0YXQgPSBzdGF0c1sneWVhcl8nK2ZpZWxkLm5hbWVdO1xuXG4gICAgICBpZiAoIXllYXJzdGF0KSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIHJldHVybiB5ZWFyc3RhdC5kaXN0aW5jdCAtXG4gICAgICAgIChzdGF0Lm51bGxzID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG50aW1lLm1heExlbmd0aCA9IGZ1bmN0aW9uKHRpbWVVbml0LCBlbmNvZGluZykge1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgICB2YXIgcmFuZ2UgPSB0aW1lLnJhbmdlKHRpbWVVbml0LCBlbmNvZGluZyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBsb25nZXN0IG5hbWUgaW4gdGhlIHJhbmdlXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCByYW5nZS5tYXAoZnVuY3Rpb24ocikge3JldHVybiByLmxlbmd0aDt9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHJldHVybiA0OyAvLycxOTk4J1xuICB9XG4gIC8vIG5vIHRpbWUgdW5pdFxuICB2YXIgdGltZUZvcm1hdCA9IGVuY29kaW5nLmNvbmZpZygndGltZUZvcm1hdCcpO1xuICByZXR1cm4gZDNfdGltZV9mb3JtYXQudXRjRm9ybWF0KHRpbWVGb3JtYXQpKExPTkdfREFURSkubGVuZ3RoO1xufTtcblxuZnVuY3Rpb24gZmllbGRGbihmdW5jLCBmaWVsZCkge1xuICByZXR1cm4gJ3V0YycgKyBmdW5jICsgJyhkLmRhdGEuJysgZmllbGQubmFtZSArJyknO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge1N0cmluZ30gZGF0ZSBiaW5uaW5nIGZvcm11bGEgb2YgdGhlIGdpdmVuIGZpZWxkXG4gKi9cbnRpbWUuZm9ybXVsYSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZEZuKGZpZWxkLnRpbWVVbml0LCBmaWVsZCk7XG59O1xuXG4vKiogYWRkIGZvcm11bGEgdHJhbnNmb3JtcyB0byBkYXRhICovXG50aW1lLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSwgZW5jb2RpbmcsIGVuY1R5cGUsIGZpZWxkKSB7XG4gIHRyYW5zZm9ybS5wdXNoKHtcbiAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpLFxuICAgIGV4cHI6IHRpbWUuZm9ybXVsYShmaWVsZClcbiAgfSk7XG59O1xuXG50aW1lLnJhbmdlID0gZnVuY3Rpb24odGltZVVuaXQsIGVuY29kaW5nKSB7XG4gIHZhciBsYWJlbExlbmd0aCA9IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTGFiZWxMZW5ndGgnKSxcbiAgICBzY2FsZUxhYmVsO1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHNjYWxlTGFiZWwgPSBlbmNvZGluZy5jb25maWcoJ2RheVNjYWxlTGFiZWwnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHNjYWxlTGFiZWwgPSBlbmNvZGluZy5jb25maWcoJ21vbnRoU2NhbGVMYWJlbCcpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKHNjYWxlTGFiZWwpIHtcbiAgICByZXR1cm4gbGFiZWxMZW5ndGggPyBzY2FsZUxhYmVsLm1hcChcbiAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5zdWJzdHIoMCwgbGFiZWxMZW5ndGgpO31cbiAgICAgICkgOiBzY2FsZUxhYmVsO1xuICB9XG4gIHJldHVybjtcbn07XG5cblxudGltZS5zY2FsZSA9IHt9O1xuXG4vKiogYXBwZW5kIGN1c3RvbSB0aW1lIHNjYWxlcyBmb3IgYXhpcyBsYWJlbCAqL1xudGltZS5zY2FsZS5kZWYgPSBmdW5jdGlvbih0aW1lVW5pdCwgZW5jb2RpbmcpIHtcbiAgdmFyIHJhbmdlID0gdGltZS5yYW5nZSh0aW1lVW5pdCwgZW5jb2RpbmcpO1xuXG4gIGlmIChyYW5nZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAndGltZS0nK3RpbWVVbml0LFxuICAgICAgdHlwZTogJ29yZGluYWwnLFxuICAgICAgZG9tYWluOiB0aW1lLnNjYWxlLmRvbWFpbih0aW1lVW5pdCksXG4gICAgICByYW5nZTogcmFuZ2VcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudGltZS5pc09yZGluYWxGbiA9IGZ1bmN0aW9uKHRpbWVVbml0KSB7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG50aW1lLnNjYWxlLnR5cGUgPSBmdW5jdGlvbih0aW1lVW5pdCwgbmFtZSkge1xuICBpZiAobmFtZSA9PT0gQ09MT1IpIHtcbiAgICByZXR1cm4gJ2xpbmVhcic7IC8vIHRpbWUgaGFzIG9yZGVyLCBzbyB1c2UgaW50ZXJwb2xhdGVkIG9yZGluYWwgY29sb3Igc2NhbGUuXG4gIH1cblxuICByZXR1cm4gdGltZS5pc09yZGluYWxGbih0aW1lVW5pdCkgfHwgbmFtZSA9PT0gQ09MIHx8IG5hbWUgPT09IFJPVyA/ICdvcmRpbmFsJyA6ICdsaW5lYXInO1xufTtcblxudGltZS5zY2FsZS5kb21haW4gPSBmdW5jdGlvbih0aW1lVW5pdCwgbmFtZSkge1xuICB2YXIgaXNDb2xvciA9IG5hbWUgPT09IENPTE9SO1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6IHJldHVybiBpc0NvbG9yID8gWzAsNTldIDogdXRpbC5yYW5nZSgwLCA2MCk7XG4gICAgY2FzZSAnaG91cnMnOiByZXR1cm4gaXNDb2xvciA/IFswLDIzXSA6IHV0aWwucmFuZ2UoMCwgMjQpO1xuICAgIGNhc2UgJ2RheSc6IHJldHVybiBpc0NvbG9yID8gWzAsNl0gOiB1dGlsLnJhbmdlKDAsIDcpO1xuICAgIGNhc2UgJ2RhdGUnOiByZXR1cm4gaXNDb2xvciA/IFsxLDMxXSA6IHV0aWwucmFuZ2UoMSwgMzIpO1xuICAgIGNhc2UgJ21vbnRoJzogcmV0dXJuIGlzQ29sb3IgPyBbMCwxMV0gOiB1dGlsLnJhbmdlKDAsIDEyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKiB3aGV0aGVyIGEgcGFydGljdWxhciB0aW1lIGZ1bmN0aW9uIGhhcyBjdXN0b20gc2NhbGUgZm9yIGxhYmVscyBpbXBsZW1lbnRlZCBpbiB0aW1lLnNjYWxlICovXG50aW1lLmhhc1NjYWxlID0gZnVuY3Rpb24odGltZVVuaXQpIHtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5jb25zdHMuZW5jb2RpbmdUeXBlcyA9IFtYLCBZLCBST1csIENPTCwgU0laRSwgU0hBUEUsIENPTE9SLCBURVhULCBERVRBSUxdO1xuXG5jb25zdHMuc2hvcnRoYW5kID0ge1xuICBkZWxpbTogICd8JyxcbiAgYXNzaWduOiAnPScsXG4gIHR5cGU6ICAgJywnLFxuICBmdW5jOiAgICdfJ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBzdGF0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3N0YXRzJyk7XG5cbnZhciB2bGRhdGEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKiogTWFwcGluZyBmcm9tIGRhdGFsaWIncyBpbmZlcnJlZCB0eXBlIHRvIFZlZ2EtbGl0ZSdzIHR5cGUgKi9cbnZsZGF0YS50eXBlcyA9IHtcbiAgJ2Jvb2xlYW4nOiBOLFxuICAnbnVtYmVyJzogUSxcbiAgJ2ludGVnZXInOiBRLFxuICAnZGF0ZSc6IFQsXG4gICdzdHJpbmcnOiBOXG59O1xuXG52bGRhdGEuc3RhdHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBzdW1tYXJ5ID0gc3RhdHMuc3VtbWFyeShkYXRhKTtcblxuICByZXR1cm4gc3VtbWFyeS5yZWR1Y2UoZnVuY3Rpb24ocywgcHJvZmlsZSkge1xuICAgIHNbcHJvZmlsZS5maWVsZF0gPSBwcm9maWxlO1xuICAgIHJldHVybiBzO1xuICB9LCB7XG4gICAgJyonOiB7XG4gICAgICBtYXg6IGRhdGEubGVuZ3RoLFxuICAgICAgbWluOiAwXG4gICAgfVxuICB9KTtcbn07IiwiLy8gdXRpbGl0eSBmb3IgZW5jXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIGMgPSBjb25zdHMuc2hvcnRoYW5kLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpLFxuICBlbmNUeXBlcyA9IHNjaGVtYS5lbmNUeXBlcztcblxudmFyIHZsZW5jID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmxlbmMuY291bnRSZXRpbmFsID0gZnVuY3Rpb24oZW5jKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmIChlbmMuY29sb3IpIGNvdW50Kys7XG4gIGlmIChlbmMuc2l6ZSkgY291bnQrKztcbiAgaWYgKGVuYy5zaGFwZSkgY291bnQrKztcbiAgcmV0dXJuIGNvdW50O1xufTtcblxudmxlbmMuaGFzID0gZnVuY3Rpb24oZW5jLCBlbmNUeXBlKSB7XG4gIHZhciBmaWVsZERlZiA9IGVuYyAmJiBlbmNbZW5jVHlwZV07XG4gIHJldHVybiBmaWVsZERlZiAmJiBmaWVsZERlZi5uYW1lO1xufTtcblxudmxlbmMuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihlbmMpIHtcbiAgZm9yICh2YXIgayBpbiBlbmMpIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykgJiYgZW5jW2tdLmFnZ3JlZ2F0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZsZW5jLmZvckVhY2ggPSBmdW5jdGlvbihlbmMsIGYpIHtcbiAgdmFyIGkgPSAwO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIGYoZW5jW2tdLCBrLCBpKyspO1xuICAgIH1cbiAgfSk7XG59O1xuXG52bGVuYy5tYXAgPSBmdW5jdGlvbihlbmMsIGYpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIGFyci5wdXNoKGYoZW5jW2tdLCBrLCBlbmMpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyO1xufTtcblxudmxlbmMucmVkdWNlID0gZnVuY3Rpb24oZW5jLCBmLCBpbml0KSB7XG4gIHZhciByID0gaW5pdDtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICByID0gZihyLCBlbmNba10sIGssICBlbmMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByO1xufTtcblxuLypcbiAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gKi9cbnZsZW5jLmZpZWxkcyA9IGZ1bmN0aW9uKGVuYykge1xuICByZXR1cm4gdmxlbmMucmVkdWNlKGVuYywgZnVuY3Rpb24gKG0sIGZpZWxkKSB7XG4gICAgdmFyIGZpZWxkTGlzdCA9IG1bZmllbGQubmFtZV0gPSBtW2ZpZWxkLm5hbWVdIHx8IFtdLFxuICAgICAgY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSA9IGZpZWxkTGlzdC5jb250YWluc1R5cGUgfHwge307XG5cbiAgICBpZiAoZmllbGRMaXN0LmluZGV4T2YoZmllbGQpID09PSAtMSkge1xuICAgICAgZmllbGRMaXN0LnB1c2goZmllbGQpO1xuICAgICAgLy8gYXVnbWVudCB0aGUgYXJyYXkgd2l0aCBjb250YWluc1R5cGUuUSAvIE8gLyBOIC8gVFxuICAgICAgY29udGFpbnNUeXBlW2ZpZWxkLnR5cGVdID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07XG5cbnZsZW5jLnNob3J0aGFuZCA9IGZ1bmN0aW9uKGVuYykge1xuICByZXR1cm4gdmxlbmMubWFwKGVuYywgZnVuY3Rpb24oZmllbGQsIGV0KSB7XG4gICAgcmV0dXJuIGV0ICsgYy5hc3NpZ24gKyB2bGZpZWxkLnNob3J0aGFuZChmaWVsZCk7XG4gIH0pLmpvaW4oYy5kZWxpbSk7XG59O1xuXG52bGVuYy5mcm9tU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kKSB7XG4gIHZhciBlbmMgPSB1dGlsLmlzQXJyYXkoc2hvcnRoYW5kKSA/IHNob3J0aGFuZCA6IHNob3J0aGFuZC5zcGxpdChjLmRlbGltKTtcbiAgcmV0dXJuIGVuYy5yZWR1Y2UoZnVuY3Rpb24obSwgZSkge1xuICAgIHZhciBzcGxpdCA9IGUuc3BsaXQoYy5hc3NpZ24pLFxuICAgICAgICBlbmN0eXBlID0gc3BsaXRbMF0udHJpbSgpLFxuICAgICAgICBmaWVsZCA9IHNwbGl0WzFdO1xuXG4gICAgbVtlbmN0eXBlXSA9IHZsZmllbGQuZnJvbVNob3J0aGFuZChmaWVsZCk7XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1dGlsaXR5IGZvciBmaWVsZFxuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIGMgPSBjb25zdHMuc2hvcnRoYW5kLFxuICB0aW1lID0gcmVxdWlyZSgnLi9jb21waWxlci90aW1lJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG5cbnZhciB2bGZpZWxkID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0gZmllbGRcbiAqIEBwYXJhbSBvcHRcbiAqICAgb3B0Lm5vZm4gLS0gZXhjbHVkZSBiaW4sIGFnZ3JlZ2F0ZSwgdGltZVVuaXRcbiAqICAgb3B0LmRhdGEgLSBpbmNsdWRlICdkYXRhLidcbiAqICAgb3B0LmZuIC0gcmVwbGFjZSBmbiB3aXRoIGN1c3RvbSBmdW5jdGlvbiBwcmVmaXhcbiAqICAgb3B0LnByZWZuIC0gcHJlcGVuZCBmbiB3aXRoIGN1c3RvbSBmdW5jdGlvbiBwcmVmaXhcblxuICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbnZsZmllbGQuZmllbGRSZWYgPSBmdW5jdGlvbihmaWVsZCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICB2YXIgZiA9IChvcHQuZGF0YSA/ICdkYXRhLicgOiAnJykgKyAob3B0LnByZWZuIHx8ICcnKSxcbiAgICBub2ZuID0gb3B0Lm5vZm4gfHwgb3B0LmZuLFxuICAgIG5hbWUgPSBmaWVsZC5uYW1lO1xuXG4gIGlmICh2bGZpZWxkLmlzQ291bnQoZmllbGQpKSB7XG4gICAgcmV0dXJuIGYgKyAnY291bnQnO1xuICB9IGVsc2UgaWYgKCFub2ZuICYmIGZpZWxkLmJpbikge1xuICAgIHJldHVybiBmICsgJ2Jpbl8nICsgbmFtZTtcbiAgfSBlbHNlIGlmICghbm9mbiAmJiBmaWVsZC5hZ2dyZWdhdGUpIHtcbiAgICByZXR1cm4gZiArIGZpZWxkLmFnZ3JlZ2F0ZSArICdfJyArIG5hbWU7XG4gIH0gZWxzZSBpZiAoIW5vZm4gJiYgZmllbGQudGltZVVuaXQpIHtcbiAgICByZXR1cm4gZiArIGZpZWxkLnRpbWVVbml0ICsgJ18nICsgbmFtZTtcbiAgfSBlbHNlIGlmIChvcHQuZm4pIHtcbiAgICByZXR1cm4gZiArIG9wdC5mbiArICdfJyArIG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGYgKyBuYW1lO1xuICB9XG59O1xuXG52bGZpZWxkLnNob3J0aGFuZCA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICByZXR1cm4gKGYuYWdncmVnYXRlID8gZi5hZ2dyZWdhdGUgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLnRpbWVVbml0ID8gZi50aW1lVW5pdCArIGMuZnVuYyA6ICcnKSArXG4gICAgKGYuYmluID8gJ2JpbicgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLm5hbWUgfHwgJycpICsgYy50eXBlICsgZi50eXBlO1xufTtcblxudmxmaWVsZC5zaG9ydGhhbmRzID0gZnVuY3Rpb24oZmllbGRzLCBkZWxpbSkge1xuICBkZWxpbSA9IGRlbGltIHx8IGMuZGVsaW07XG4gIHJldHVybiBmaWVsZHMubWFwKHZsZmllbGQuc2hvcnRoYW5kKS5qb2luKGRlbGltKTtcbn07XG5cbnZsZmllbGQuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCkge1xuICB2YXIgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy50eXBlKSwgaTtcbiAgdmFyIG8gPSB7XG4gICAgbmFtZTogc3BsaXRbMF0udHJpbSgpLFxuICAgIHR5cGU6IHNwbGl0WzFdLnRyaW0oKVxuICB9O1xuXG4gIC8vIGNoZWNrIGFnZ3JlZ2F0ZSB0eXBlXG4gIGZvciAoaSBpbiBzY2hlbWEuYWdncmVnYXRlLmVudW0pIHtcbiAgICB2YXIgYSA9IHNjaGVtYS5hZ2dyZWdhdGUuZW51bVtpXTtcbiAgICBpZiAoby5uYW1lLmluZGV4T2YoYSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoYS5sZW5ndGggKyAxKTtcbiAgICAgIGlmIChhID09ICdjb3VudCcgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gJyonO1xuICAgICAgby5hZ2dyZWdhdGUgPSBhO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgdGltZSB0aW1lVW5pdFxuICBmb3IgKGkgaW4gc2NoZW1hLnRpbWVmbnMpIHtcbiAgICB2YXIgdHUgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKHR1ICsgJ18nKSA9PT0gMCkge1xuICAgICAgby5uYW1lID0gby5uYW1lLnN1YnN0cihvLmxlbmd0aCArIDEpO1xuICAgICAgby50aW1lVW5pdCA9IHR1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgYmluXG4gIGlmIChvLm5hbWUgJiYgby5uYW1lLmluZGV4T2YoJ2Jpbl8nKSA9PT0gMCkge1xuICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoNCk7XG4gICAgby5iaW4gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG87XG59O1xuXG52YXIgaXNUeXBlID0gdmxmaWVsZC5pc1R5cGUgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGUpIHtcbiAgcmV0dXJuIGZpZWxkRGVmLnR5cGUgPT09IHR5cGU7XG59O1xuXG52YXIgaXNUeXBlcyA9IHZsZmllbGQuaXNUeXBlcyA9IGZ1bmN0aW9uIChmaWVsZERlZiwgdHlwZXMpIHtcbiAgZm9yICh2YXIgdD0wOyB0PHR5cGVzLmxlbmd0aDsgdCsrKSB7XG4gICAgaWYoZmllbGREZWYudHlwZSA9PT0gdHlwZXNbdF0pIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qXG4gKiBNb3N0IGZpZWxkcyB0aGF0IHVzZSBvcmRpbmFsIHNjYWxlIGFyZSBkaW1lbnNpb25zLlxuICogSG93ZXZlciwgWUVBUihUKSwgWUVBUk1PTlRIKFQpIHVzZSB0aW1lIHNjYWxlLCBub3Qgb3JkaW5hbCBidXQgYXJlIGRpbWVuc2lvbnMgdG9vLlxuICovXG52bGZpZWxkLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuICBpc1R5cGVzKGZpZWxkLCBbTiwgT10pIHx8IGZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiBmaWVsZC50aW1lVW5pdCAmJiB0aW1lLmlzT3JkaW5hbEZuKGZpZWxkLnRpbWVVbml0KSApO1xufTtcblxuZnVuY3Rpb24gaXNEaW1lbnNpb24oZmllbGQpIHtcbiAgcmV0dXJuICBpc1R5cGVzKGZpZWxkLCBbTiwgT10pIHx8ICEhZmllbGQuYmluIHx8XG4gICAgKCBpc1R5cGUoZmllbGQsIFQpICYmICEhZmllbGQudGltZVVuaXQgKTtcbn1cblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5pc0RpbWVuc2lvbigpIHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAqIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5pc0RpbWVuc2lvbiA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZCAmJiBpc0RpbWVuc2lvbihmaWVsZCk7XG59O1xuXG52bGZpZWxkLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZCAmJiAhaXNEaW1lbnNpb24oZmllbGQpO1xufTtcblxudmxmaWVsZC5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge25hbWU6JyonLCBhZ2dyZWdhdGU6ICdjb3VudCcsIHR5cGU6IFEsIGRpc3BsYXlOYW1lOiB2bGZpZWxkLmNvdW50LmRpc3BsYXlOYW1lfTtcbn07XG5cbnZsZmllbGQuY291bnQuZGlzcGxheU5hbWUgPSAnTnVtYmVyIG9mIFJlY29yZHMnO1xuXG52bGZpZWxkLmlzQ291bnQgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQuYWdncmVnYXRlID09PSAnY291bnQnO1xufTtcblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5jYXJkaW5hbGl0eSgpIHRvIGF2b2lkIGNvbmZ1c2lvbi4gIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCkge1xuICAvLyBGSVhNRSBuZWVkIHRvIHRha2UgZmlsdGVyIGludG8gYWNjb3VudFxuXG4gIHZhciBzdGF0ID0gc3RhdHNbZmllbGQubmFtZV07XG4gIHZhciB0eXBlID0gZmllbGQudHlwZTtcblxuICBmaWx0ZXJOdWxsID0gZmlsdGVyTnVsbCB8fCB7fTtcblxuICBpZiAoZmllbGQuYmluKSB7XG4gICAgdmFyIGJpbnMgPSB1dGlsLmdldGJpbnMoc3RhdCwgZmllbGQuYmluLm1heGJpbnMgfHwgc2NoZW1hLk1BWEJJTlNfREVGQVVMVCk7XG4gICAgcmV0dXJuIChiaW5zLnN0b3AgLSBiaW5zLnN0YXJ0KSAvIGJpbnMuc3RlcDtcbiAgfVxuICBpZiAoaXNUeXBlKGZpZWxkLCBUKSkge1xuICAgIHZhciBjYXJkaW5hbGl0eSA9IHRpbWUuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsLCB0eXBlKTtcbiAgICBpZihjYXJkaW5hbGl0eSAhPT0gbnVsbCkgcmV0dXJuIGNhcmRpbmFsaXR5O1xuICAgIC8vb3RoZXJ3aXNlIHVzZSBjYWxjdWxhdGlvbiBiZWxvd1xuICB9XG4gIGlmIChmaWVsZC5hZ2dyZWdhdGUpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBudWxsXG4gIHJldHVybiBzdGF0LmRpc3RpbmN0IC1cbiAgICAoc3RhdC5udWxscyA+IDAgJiYgZmlsdGVyTnVsbFt0eXBlXSA/IDEgOiAwKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGRlY2xhcmUgZ2xvYmFsIGNvbnN0YW50XG52YXIgZyA9IGdsb2JhbCB8fCB3aW5kb3c7XG5cbmcuVEFCTEUgPSAndGFibGUnO1xuZy5SQVcgPSAncmF3JztcbmcuU1RBQ0tFRCA9ICdzdGFja2VkJztcbmcuSU5ERVggPSAnaW5kZXgnO1xuXG5nLlggPSAneCc7XG5nLlkgPSAneSc7XG5nLlJPVyA9ICdyb3cnO1xuZy5DT0wgPSAnY29sJztcbmcuU0laRSA9ICdzaXplJztcbmcuU0hBUEUgPSAnc2hhcGUnO1xuZy5DT0xPUiA9ICdjb2xvcic7XG5nLlRFWFQgPSAndGV4dCc7XG5nLkRFVEFJTCA9ICdkZXRhaWwnO1xuXG5nLk4gPSAnTic7XG5nLk8gPSAnTyc7XG5nLlEgPSAnUSc7XG5nLlQgPSAnVCc7XG4iLCIvLyBQYWNrYWdlIG9mIGRlZmluaW5nIFZlZ2EtbGl0ZSBTcGVjaWZpY2F0aW9uJ3MganNvbiBzY2hlbWFcbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgc2NoZW1hID0gbW9kdWxlLmV4cG9ydHMgPSB7fSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdG9NYXAgPSB1dGlsLnRvTWFwLFxuICBjb2xvcmJyZXdlciA9IHJlcXVpcmUoJ2NvbG9yYnJld2VyJyk7XG5cbnNjaGVtYS51dGlsID0gcmVxdWlyZSgnLi9zY2hlbWF1dGlsJyk7XG5cbnNjaGVtYS5tYXJrdHlwZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsncG9pbnQnLCAndGljaycsICdiYXInLCAnbGluZScsICdhcmVhJywgJ2NpcmNsZScsICdzcXVhcmUnLCAndGV4dCddXG59O1xuXG5zY2hlbWEuYWdncmVnYXRlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydhdmcnLCAnc3VtJywgJ21lZGlhbicsICdtaW4nLCAnbWF4JywgJ2NvdW50J10sXG4gIHN1cHBvcnRlZEVudW1zOiB7XG4gICAgUTogWydhdmcnLCAnbWVkaWFuJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J10sXG4gICAgTzogWydtZWRpYW4nLCdtaW4nLCdtYXgnXSxcbiAgICBOOiBbXSxcbiAgICBUOiBbJ2F2ZycsICdtZWRpYW4nLCAnbWluJywgJ21heCddLFxuICAgICcnOiBbJ2NvdW50J11cbiAgfSxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRLCBOLCBPLCBULCAnJ10pXG59O1xuXG5zY2hlbWEuZ2V0U3VwcG9ydGVkUm9sZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgcmV0dXJuIHNjaGVtYS5zY2hlbWEucHJvcGVydGllcy5lbmNvZGluZy5wcm9wZXJ0aWVzW2VuY1R5cGVdLnN1cHBvcnRlZFJvbGU7XG59O1xuXG5zY2hlbWEudGltZVVuaXRzID0gWyd5ZWFyJywgJ21vbnRoJywgJ2RheScsICdkYXRlJywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddO1xuXG5zY2hlbWEuZGVmYXVsdFRpbWVGbiA9ICdtb250aCc7XG5cbnNjaGVtYS50aW1lVW5pdCA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IHNjaGVtYS50aW1lVW5pdHMsXG4gIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbVF0pXG59O1xuXG5zY2hlbWEuc2NhbGVfdHlwZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIC8vIFRPRE8oa2FuaXR3KSByZWFkIHZlZ2EncyBzY2hlbWEgaGVyZSwgYWRkIGRlc2NyaXB0aW9uXG4gIGVudW06IFsnbGluZWFyJywgJ2xvZycsICdwb3cnLCAnc3FydCcsICdxdWFudGlsZSddLFxuICBkZWZhdWx0OiAnbGluZWFyJyxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRXSlcbn07XG5cbnNjaGVtYS5maWVsZCA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNsb25lID0gdXRpbC5kdXBsaWNhdGU7XG52YXIgbWVyZ2UgPSBzY2hlbWEudXRpbC5tZXJnZTtcblxuc2NoZW1hLk1BWEJJTlNfREVGQVVMVCA9IDE1O1xuXG52YXIgYmluID0ge1xuICB0eXBlOiBbJ2Jvb2xlYW4nLCAnb2JqZWN0J10sXG4gIGRlZmF1bHQ6IGZhbHNlLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWF4Ymluczoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogc2NoZW1hLk1BWEJJTlNfREVGQVVMVCxcbiAgICAgIG1pbmltdW06IDIsXG4gICAgICBkZXNjcmlwdGlvbjogJ01heGltdW0gbnVtYmVyIG9mIGJpbnMuJ1xuICAgIH1cbiAgfSxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRXSkgLy8gVE9ETzogYWRkIE8gYWZ0ZXIgZmluaXNoaW5nICM4MVxufTtcblxudmFyIHR5cGljYWxGaWVsZCA9IG1lcmdlKGNsb25lKHNjaGVtYS5maWVsZCksIHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFtOLCBPLCBRLCBUXVxuICAgIH0sXG4gICAgYWdncmVnYXRlOiBzY2hlbWEuYWdncmVnYXRlLFxuICAgIHRpbWVVbml0OiBzY2hlbWEudGltZVVuaXQsXG4gICAgYmluOiBiaW4sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiBzY2hlbWEuc2NhbGVfdHlwZSxcbiAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1EsIFRdKVxuICAgICAgICB9LFxuICAgICAgICB6ZXJvOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5jbHVkZSB6ZXJvJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUSwgVF0pXG4gICAgICAgIH0sXG4gICAgICAgIG5pY2U6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJ10sXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtUXSlcbiAgICAgICAgfSxcbiAgICAgICAgdXNlUmF3RG9tYWluOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1VzZSB0aGUgcmF3IGRhdGEgcmFuZ2UgYXMgc2NhbGUgZG9tYWluIGluc3RlYWQgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdhZ2dyZWdhdGVkIGRhdGEgZm9yIGFnZ3JlZ2F0ZSBheGlzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ1RoaXMgb3B0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBzdW0gb3IgY291bnQgYWdncmVnYXRlJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdhcyB0aGV5IG1pZ2h0IGhhdmUgYSBzdWJzdGFudGlhbGx5IGxhcmdlciBzY2FsZSByYW5nZS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ0J5IGRlZmF1bHQsIHVzZSB2YWx1ZSBmcm9tIGNvbmZpZy51c2VSYXdEb21haW4uJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIG9ubHlPcmRpbmFsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlXG4gIH0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFtOLCBPLCBRLCBUXSAvLyBvcmRpbmFsLW9ubHkgZmllbGQgc3VwcG9ydHMgUSB3aGVuIGJpbiBpcyBhcHBsaWVkIGFuZCBUIHdoZW4gdGltZSB1bml0IGlzIGFwcGxpZWQuXG4gICAgfSxcbiAgICB0aW1lVW5pdDogc2NoZW1hLnRpbWVVbml0LFxuICAgIGJpbjogYmluLFxuICAgIGFnZ3JlZ2F0ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NvdW50J10sXG4gICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW04sIE9dKSAvLyBGSVhNRSB0aGlzIGxvb2tzIHdlaXJkIHRvIG1lXG4gICAgfVxuICB9XG59KTtcblxudmFyIGF4aXNNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIGF4aXM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIGZsYWcgaW5kaWNhdGUgaWYgZ3JpZGxpbmVzIHNob3VsZCBiZSBjcmVhdGVkIGluIGFkZGl0aW9uIHRvIHRpY2tzLidcbiAgICAgICAgfSxcbiAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnYmFjaycsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHN0cmluZyBpbmRpY2F0aW5nIGlmIHRoZSBheGlzIChhbmQgYW55IGdyaWRsaW5lcykgc2hvdWxkIGJlIHBsYWNlZCBhYm92ZSBvciBiZWxvdyB0aGUgZGF0YSBtYXJrcy4nXG4gICAgICAgIH0sXG4gICAgICAgIG9yaWVudDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBlbnVtOiBbJ3RvcCcsICdyaWdodCcsICdsZWZ0JywgJ2JvdHRvbSddLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIG9yaWVudGF0aW9uIG9mIHRoZSBheGlzLiBPbmUgb2YgdG9wLCBib3R0b20sIGxlZnQgb3IgcmlnaHQuIFRoZSBvcmllbnRhdGlvbiBjYW4gYmUgdXNlZCB0byBmdXJ0aGVyIHNwZWNpYWxpemUgdGhlIGF4aXMgdHlwZSAoZS5nLiwgYSB5IGF4aXMgb3JpZW50ZWQgZm9yIHRoZSByaWdodCBlZGdlIG9mIHRoZSBjaGFydCkuJ1xuICAgICAgICB9LFxuICAgICAgICB0aWNrcyA6e1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiA1LFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBkZXNpcmVkIG51bWJlciBvZiB0aWNrcywgZm9yIGF4ZXMgdmlzdWFsaXppbmcgcXVhbnRpdGF0aXZlIHNjYWxlcy4gVGhlIHJlc3VsdGluZyBudW1iZXIgbWF5IGJlIGRpZmZlcmVudCBzbyB0aGF0IHZhbHVlcyBhcmUgXCJuaWNlXCIgKG11bHRpcGxlcyBvZiAyLCA1LCAxMCkgYW5kIGxpZSB3aXRoaW4gdGhlIHVuZGVybHlpbmcgc2NhbGVcXCdzIHJhbmdlLidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIGZvciB0aGUgYXhpcy4gKFNob3dzIGZpZWxkIG5hbWUgYW5kIGl0cyBmdW5jdGlvbiBieSBkZWZhdWx0LiknXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlTWF4TGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ01heCBsZW5ndGggZm9yIGF4aXMgdGl0bGUgaWYgdGhlIHRpdGxlIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gdGhlIGZpZWxkXFwncyBkZXNjcmlwdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGVPZmZzZXQ6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSB0aXRsZSBvZmZzZXQgdmFsdWUgZm9yIHRoZSBheGlzLidcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGZvcm1hdHRpbmcgcGF0dGVybiBmb3IgYXhpcyBsYWJlbHMuICcrXG4gICAgICAgICAgICAgICAgICAgICAgICdJZiBub3QgdW5kZWZpbmVkLCB0aGlzIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ3NtYWxsL2xhcmdlTnVtYmVyRm9ybWF0IGFuZCB0aGUgbWF4IHZhbHVlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnb2YgdGhlIGZpZWxkLidcbiAgICAgICAgfSxcbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMjUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzb3J0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgc29ydDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbTiwgT10pLFxuICAgICAgICByZXF1aXJlZDogWyduYW1lJywgJ2FnZ3JlZ2F0ZSddLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFnZ3JlZ2F0ZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbnVtOiBbJ2F2ZycsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGJhbmRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBiYW5kOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgbGVnZW5kTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7J3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdyaWdodCdcbiAgICB9LFxuICAgIGJhc2VsaW5lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdtaWRkbGUnXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJyMwMDAwMDAnXG4gICAgfSxcbiAgICBtYXJnaW46IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDQsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnQWJjJ1xuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHdlaWdodDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2JvbGQnXSxcbiAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwLFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfSxcbiAgICAgICAgZmFtaWx5OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ0hlbHZldGljYSBOZXVlJ1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2l0YWxpYyddXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZvcm1hdDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICBkZXNjcmlwdGlvbjogJ1RoZSBmb3JtYXR0aW5nIHBhdHRlcm4gZm9yIHRleHQgdmFsdWUuICcrXG4gICAgICAgICAgICAgICAgICAgJ0lmIG5vdCB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICdzbWFsbC9sYXJnZU51bWJlckZvcm1hdCBhbmQgdGhlIG1heCB2YWx1ZSAnICtcbiAgICAgICAgICAgICAgICAgICAnb2YgdGhlIGZpZWxkLidcbiAgICB9LFxuICB9XG59O1xuXG52YXIgc2l6ZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGJhcjogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDMwLFxuICAgICAgbWluaW11bTogMFxuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbG9yTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgJ3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnc3RlZWxibHVlJ1xuICAgIH0sXG4gICAgb3BhY2l0eToge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMVxuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByYW5nZToge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2FycmF5J10sXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgJ2NvbG9yIHBhbGV0dGUsIGlmIHVuZGVmaW5lZCB2ZWdhLWxpdGUgd2lsbCB1c2UgZGF0YSBwcm9wZXJ0eScgK1xuICAgICAgICAgICAgJ3RvIHBpY2sgb25lIGZyb20gYzEwcGFsZXR0ZSwgYzIwcGFsZXR0ZSwgb3Igb3JkaW5hbFBhbGV0dGUnXG4gICAgICAgIH0sXG4gICAgICAgIGMxMHBhbGV0dGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnY2F0ZWdvcnkxMCcsXG4gICAgICAgICAgZW51bTogW1xuICAgICAgICAgICAgLy8gVGFibGVhdVxuICAgICAgICAgICAgJ2NhdGVnb3J5MTAnLCAnY2F0ZWdvcnkxMGsnLFxuICAgICAgICAgICAgLy8gQ29sb3IgQnJld2VyXG4gICAgICAgICAgICAnUGFzdGVsMScsICdQYXN0ZWwyJywgJ1NldDEnLCAnU2V0MicsICdTZXQzJ1xuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYzIwcGFsZXR0ZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdjYXRlZ29yeTIwJyxcbiAgICAgICAgICBlbnVtOiBbJ2NhdGVnb3J5MjAnLCAnY2F0ZWdvcnkyMGInLCAnY2F0ZWdvcnkyMGMnXVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFsZXR0ZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdCdUduJyxcbiAgICAgICAgICBlbnVtOiB1dGlsLmtleXMoY29sb3JicmV3ZXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaGFwZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnY2lyY2xlJywgJ3NxdWFyZScsICdjcm9zcycsICdkaWFtb25kJywgJ3RyaWFuZ2xlLXVwJywgJ3RyaWFuZ2xlLWRvd24nXSxcbiAgICAgIGRlZmF1bHQ6ICdjaXJjbGUnXG4gICAgfSxcbiAgICBmaWxsZWQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICd3aGV0aGVyIHRoZSBzaGFwZVxcJ3MgY29sb3Igc2hvdWxkIGJlIHVzZWQgYXMgZmlsbCBjb2xvciBpbnN0ZWFkIG9mIHN0cm9rZSBjb2xvcidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZXRhaWxNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBsaW5lOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX1cbn07XG5cbnZhciByb3dNaXhpbiA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMTUwXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29sTWl4aW4gPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMTUwXG4gICAgfSxcbiAgICBheGlzOiB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG1heExhYmVsTGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDEyLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUcnVuY2F0ZSBsYWJlbHMgdGhhdCBhcmUgdG9vIGxvbmcuJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFjZXRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCB0ZXh0OiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHBhZGRpbmc6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXF1aXJlZE5hbWVUeXBlID0ge1xuICByZXF1aXJlZDogWyduYW1lJywgJ3R5cGUnXVxufTtcblxudmFyIG11bHRpUm9sZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfVxufSk7XG5cbnZhciBxdWFudGl0YXRpdmVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgZGltZW5zaW9uOiAnb3JkaW5hbC1vbmx5JyAvLyB1c2luZyBzaXplIHRvIGVuY29kaW5nIGNhdGVnb3J5IGxlYWQgdG8gb3JkZXIgaW50ZXJwcmV0YXRpb25cbiAgfVxufSk7XG5cbnZhciBvbmx5UXVhbnRpdGF0aXZlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgeCA9IG1lcmdlKGNsb25lKG11bHRpUm9sZUZpZWxkKSwgYXhpc01peGluLCBiYW5kTWl4aW4sIHJlcXVpcmVkTmFtZVR5cGUsIHNvcnRNaXhpbik7XG52YXIgeSA9IGNsb25lKHgpO1xuXG52YXIgZmFjZXQgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgcmVxdWlyZWROYW1lVHlwZSwgZmFjZXRNaXhpbiwgc29ydE1peGluKTtcbnZhciByb3cgPSBtZXJnZShjbG9uZShmYWNldCksIGF4aXNNaXhpbiwgcm93TWl4aW4pO1xudmFyIGNvbCA9IG1lcmdlKGNsb25lKGZhY2V0KSwgYXhpc01peGluLCBjb2xNaXhpbik7XG5cbnZhciBzaXplID0gbWVyZ2UoY2xvbmUocXVhbnRpdGF0aXZlRmllbGQpLCBsZWdlbmRNaXhpbiwgc2l6ZU1peGluLCBzb3J0TWl4aW4pO1xudmFyIGNvbG9yID0gbWVyZ2UoY2xvbmUobXVsdGlSb2xlRmllbGQpLCBsZWdlbmRNaXhpbiwgY29sb3JNaXhpbiwgc29ydE1peGluKTtcblxudmFyIHNoYXBlID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIGxlZ2VuZE1peGluLCBzaGFwZU1peGluLCBzb3J0TWl4aW4pO1xudmFyIGRldGFpbCA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCBkZXRhaWxNaXhpbiwgc29ydE1peGluKTtcblxuLy8gd2Ugb25seSBwdXQgYWdncmVnYXRlZCBtZWFzdXJlIGluIHBpdm90IHRhYmxlXG52YXIgdGV4dCA9IG1lcmdlKGNsb25lKG9ubHlRdWFudGl0YXRpdmVGaWVsZCksIHRleHRNaXhpbiwgc29ydE1peGluKTtcblxuLy8gVE9ETyBhZGQgbGFiZWxcblxudmFyIGZpbHRlciA9IHtcbiAgdHlwZTogJ2FycmF5JyxcbiAgaXRlbXM6IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBvcGVyYW5kczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3BlcmF0b3I6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIGVudW06IFsnPicsICc+PScsICc9JywgJyE9JywgJzwnLCAnPD0nLCAnbm90TnVsbCddXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZGF0YSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyBkYXRhIHNvdXJjZVxuICAgIGZvcm1hdFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydqc29uJywgJ2NzdiddLFxuICAgICAgZGVmYXVsdDogJ2pzb24nXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Bhc3MgYXJyYXkgb2Ygb2JqZWN0cyBpbnN0ZWFkIG9mIGEgdXJsIHRvIGEgZmlsZS4nLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgY29uZmlnID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIC8vIHRlbXBsYXRlXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZpZXdwb3J0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ2ludGVnZXInXG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBncmlkQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICdibGFjaydcbiAgICB9LFxuICAgIGdyaWRPcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4wOFxuICAgIH0sXG5cbiAgICAvLyBmaWx0ZXIgbnVsbFxuICAgIGZpbHRlck51bGw6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBPOiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICAgICAgUToge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiB0cnVlfSxcbiAgICAgICAgVDoge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiB0cnVlfVxuICAgICAgfVxuICAgIH0sXG4gICAgdG9nZ2xlU29ydDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiBPXG4gICAgfSxcblxuICAgIC8vIHNpbmdsZSBwbG90XG4gICAgc2luZ2xlSGVpZ2h0OiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzaW5nbGVXaWR0aDoge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBiYW5kV2lkdGggKiAoY2FyZGluYWxpdHkgKyBwYWRkaW5nKVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gYmFuZCBzaXplXG4gICAgbGFyZ2VCYW5kU2l6ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjEsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzbWFsbEJhbmRTaXplOiB7XG4gICAgICAvL3NtYWxsIG11bHRpcGxlcyBvciBzaW5nbGUgcGxvdCB3aXRoIGhpZ2ggY2FyZGluYWxpdHlcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEyLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHk6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEwXG4gICAgfSxcbiAgICAvLyBzbWFsbCBtdWx0aXBsZXNcbiAgICBjZWxsUGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9LFxuICAgIGNlbGxHcmlkQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICdibGFjaydcbiAgICB9LFxuICAgIGNlbGxHcmlkT3BhY2l0eToge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRlZmF1bHQ6IDAuMTVcbiAgICB9LFxuICAgIGNlbGxCYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICd0cmFuc3BhcmVudCdcbiAgICB9LFxuICAgIHRleHRDZWxsV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDkwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG5cbiAgICAvLyBtYXJrc1xuICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgc2luZ2xlQmFyT2Zmc2V0OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gc2NhbGVzXG4gICAgdGltZVNjYWxlTGFiZWxMZW5ndGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVzY3JpcHRpb246ICdNYXggbGVuZ3RoIGZvciB2YWx1ZXMgaW4gZGF5U2NhbGVMYWJlbCBhbmQgbW9udGhTY2FsZUxhYmVsLiAgWmVybyBtZWFucyB1c2luZyBmdWxsIG5hbWVzIGluIGRheVNjYWxlTGFiZWwvbW9udGhTY2FsZUxhYmVsLidcbiAgICB9LFxuICAgIGRheVNjYWxlTGFiZWw6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQXhpcyBsYWJlbHMgZm9yIGRheSBvZiB3ZWVrLCBzdGFydGluZyBmcm9tIFN1bmRheS4nICtcbiAgICAgICAgJyhDb25zaXN0ZW50IHdpdGggSmF2YXNjcmlwdCAtLSBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXREYXkuJ1xuICAgIH0sXG4gICAgbW9udGhTY2FsZUxhYmVsOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQXhpcyBsYWJlbHMgZm9yIG1vbnRoLidcbiAgICB9LFxuICAgIC8vIG90aGVyXG4gICAgY2hhcmFjdGVyV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDZcbiAgICB9LFxuICAgIG1heFNtYWxsTnVtYmVyOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IDEwMDAwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIG51bWJlciB0aGF0IGEgZmllbGQgd2lsbCBiZSBjb25zaWRlcmVkIHNtYWxsTnVtYmVyLicrXG4gICAgICAgICAgICAgICAgICAgJ1VzZWQgZm9yIGF4aXMgbGFiZWxsaW5nLidcbiAgICB9LFxuICAgIHNtYWxsTnVtYmVyRm9ybWF0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICcnLFxuICAgICAgZGVzY3JpcHRpb246ICdEMyBOdW1iZXIgZm9ybWF0IGZvciBheGlzIGxhYmVscyBhbmQgdGV4dCB0YWJsZXMgJytcbiAgICAgICAgICAgICAgICAgICAnZm9yIG51bWJlciA8PSBtYXhTbWFsbE51bWJlci4gVXNlZCBmb3IgYXhpcyBsYWJlbGxpbmcuJ1xuICAgIH0sXG4gICAgbGFyZ2VOdW1iZXJGb3JtYXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJy4zcycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0QzIE51bWJlciBmb3JtYXQgZm9yIGF4aXMgbGFiZWxzIGFuZCB0ZXh0IHRhYmxlcyAnICtcbiAgICAgICAgICAgICAgICAgICAnZm9yIG51bWJlciA+IG1heFNtYWxsTnVtYmVyLidcbiAgICB9LFxuICAgIHRpbWVGb3JtYXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJyVZLSVtLSVkJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRGF0ZSBmb3JtYXQgZm9yIGF4aXMgbGFiZWxzLidcbiAgICB9LFxuICAgIHVzZVJhd0RvbWFpbjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ1VzZSB0aGUgcmF3IGRhdGEgcmFuZ2UgYXMgc2NhbGUgZG9tYWluIGluc3RlYWQgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgJ2FnZ3JlZ2F0ZWQgZGF0YSBmb3IgYWdncmVnYXRlIGF4aXMuICcgK1xuICAgICAgICAgICAgICAgICAgICdUaGlzIG9wdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggc3VtIG9yIGNvdW50IGFnZ3JlZ2F0ZScgK1xuICAgICAgICAgICAgICAgICAgICdhcyB0aGV5IG1pZ2h0IGhhdmUgYSBzdWJzdGFudGlhbGx5IGxhcmdlciBzY2FsZSByYW5nZS4nICtcbiAgICAgICAgICAgICAgICAgICAnQnkgZGVmYXVsdCwgdXNlIHZhbHVlIGZyb20gY29uZmlnLnVzZVJhd0RvbWFpbi4nXG4gICAgfVxuICB9XG59O1xuXG4vKiogQHR5cGUgT2JqZWN0IFNjaGVtYSBvZiBhIHZlZ2EtbGl0ZSBzcGVjaWZpY2F0aW9uICovXG5zY2hlbWEuc2NoZW1hID0ge1xuICAkc2NoZW1hOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjJyxcbiAgZGVzY3JpcHRpb246ICdTY2hlbWEgZm9yIFZlZ2EtbGl0ZSBzcGVjaWZpY2F0aW9uJyxcbiAgdHlwZTogJ29iamVjdCcsXG4gIHJlcXVpcmVkOiBbJ21hcmt0eXBlJywgJ2VuY29kaW5nJywgJ2RhdGEnXSxcbiAgcHJvcGVydGllczoge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgbWFya3R5cGU6IHNjaGVtYS5tYXJrdHlwZSxcbiAgICBlbmNvZGluZzoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHJvdzogcm93LFxuICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICB9XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICBjb25maWc6IGNvbmZpZ1xuICB9XG59O1xuXG5zY2hlbWEuZW5jVHlwZXMgPSB1dGlsLmtleXMoc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmVuY29kaW5nLnByb3BlcnRpZXMpO1xuXG4vKiogSW5zdGFudGlhdGUgYSB2ZXJib3NlIHZsIHNwZWMgZnJvbSB0aGUgc2NoZW1hICovXG5zY2hlbWEuaW5zdGFudGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjaGVtYS51dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5zY2hlbWEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNjaGVtYXV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59O1xuXG5zY2hlbWF1dGlsLmV4dGVuZCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYXV0aWwubWVyZ2Uoc2NoZW1hdXRpbC5pbnN0YW50aWF0ZShzY2hlbWEpLCBpbnN0YW5jZSk7XG59O1xuXG4vLyBpbnN0YW50aWF0ZSBhIHNjaGVtYVxuc2NoZW1hdXRpbC5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKHNjaGVtYSkge1xuICB2YXIgdmFsO1xuICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKCdkZWZhdWx0JyBpbiBzY2hlbWEpIHtcbiAgICB2YWwgPSBzY2hlbWEuZGVmYXVsdDtcbiAgICByZXR1cm4gdXRpbC5pc09iamVjdCh2YWwpID8gdXRpbC5kdXBsaWNhdGUodmFsKSA6IHZhbDtcbiAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICB2YWwgPSBzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5wcm9wZXJ0aWVzW25hbWVdKTtcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vLyByZW1vdmUgYWxsIGRlZmF1bHRzIGZyb20gYW4gaW5zdGFuY2VcbnNjaGVtYXV0aWwuc3VidHJhY3QgPSBmdW5jdGlvbihpbnN0YW5jZSwgZGVmYXVsdHMpIHtcbiAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBpbnN0YW5jZSkge1xuICAgIHZhciBkZWYgPSBkZWZhdWx0c1twcm9wXTtcbiAgICB2YXIgaW5zID0gaW5zdGFuY2VbcHJvcF07XG4gICAgLy8gTm90ZTogZG9lcyBub3QgcHJvcGVybHkgc3VidHJhY3QgYXJyYXlzXG4gICAgaWYgKCFkZWZhdWx0cyB8fCBkZWYgIT09IGlucykge1xuICAgICAgaWYgKHR5cGVvZiBpbnMgPT09ICdvYmplY3QnICYmICF1dGlsLmlzQXJyYXkoaW5zKSAmJiBkZWYpIHtcbiAgICAgICAgdmFyIGMgPSBzY2hlbWF1dGlsLnN1YnRyYWN0KGlucywgZGVmKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGMpKVxuICAgICAgICAgIGNoYW5nZXNbcHJvcF0gPSBjO1xuICAgICAgfSBlbHNlIGlmICghdXRpbC5pc0FycmF5KGlucykgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IGlucztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5zY2hlbWF1dGlsLm1lcmdlID0gZnVuY3Rpb24oLypkZXN0Kiwgc3JjMCwgc3JjMSwgLi4uKi8pe1xuICB2YXIgZGVzdCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yICh2YXIgaT0xIDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXN0ID0gbWVyZ2UoZGVzdCwgYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5cbi8vIHJlY3Vyc2l2ZWx5IG1lcmdlcyBzcmMgaW50byBkZXN0XG5mdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgZm9yICh2YXIgcCBpbiBzcmMpIHtcbiAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzcmNbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjW3BdICE9PSAnb2JqZWN0JyB8fCBzcmNbcF0gPT09IG51bGwpIHtcbiAgICAgIGRlc3RbcF0gPSBzcmNbcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdFtwXSAhPT0gJ29iamVjdCcgfHwgZGVzdFtwXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IG1lcmdlKHNyY1twXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBbXSA6IHt9LCBzcmNbcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZShkZXN0W3BdLCBzcmNbcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdDtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdkYXRhbGliL3NyYy91dGlsJyk7XG5cbnV0aWwuZXh0ZW5kKHV0aWwsIHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2dlbmVyYXRlJykpO1xudXRpbC5leHRlbmQodXRpbCwgcmVxdWlyZSgnZGF0YWxpYi9zcmMvc3RhdHMnKSk7XG51dGlsLmJpbiA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2JpbnMvYmlucycpO1xuXG51dGlsLmlzaW4gPSBmdW5jdGlvbihpdGVtLCBhcnJheSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xuXG51dGlsLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2guY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgZi5jYWxsKHRoaXNBcmcsIG9ialtrXSwgayAsIG9iaik7XG4gICAgfVxuICB9XG59O1xuXG51dGlsLnJlZHVjZSA9IGZ1bmN0aW9uKG9iaiwgZiwgaW5pdCwgdGhpc0FyZykge1xuICBpZiAob2JqLnJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlLmNhbGwodGhpc0FyZywgZiwgaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGluaXQgPSBmLmNhbGwodGhpc0FyZywgaW5pdCwgb2JqW2tdLCBrLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxufTtcblxudXRpbC5tYXAgPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5tYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcC5jYWxsKHRoaXNBcmcsIGYpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgb3V0cHV0LnB1c2goIGYuY2FsbCh0aGlzQXJnLCBvYmpba10sIGssIG9iaikpO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5hbnkgPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgdmFyIGkgPSAwLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYgKGYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG51dGlsLmFsbCA9IGZ1bmN0aW9uKGFyciwgZikge1xuICB2YXIgaSA9IDAsIGs7XG4gIGZvciAoayBpbiBhcnIpIHtcbiAgICBpZiAoIWYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG51dGlsLmdldGJpbnMgPSBmdW5jdGlvbihzdGF0cywgbWF4Ymlucykge1xuICByZXR1cm4gdXRpbC5iaW4oe1xuICAgIG1pbjogc3RhdHMubWluLFxuICAgIG1heDogc3RhdHMubWF4LFxuICAgIG1heGJpbnM6IG1heGJpbnNcbiAgfSk7XG59O1xuXG4vKipcbiAqIHhbcFswXV0uLi5bcFtuXV0gPSB2YWxcbiAqIEBwYXJhbSBub2F1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5zZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCB2YWwsIG5vYXVnbWVudCkge1xuICBmb3IgKHZhciBpPTA7IGk8cC5sZW5ndGgtMTsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICB4W3BbaV1dID0gdmFsO1xufTtcblxuXG4vKipcbiAqIHJldHVybnMgeFtwWzBdXS4uLltwW25dXVxuICogQHBhcmFtIGF1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5nZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIW5vYXVnbWVudCAmJiAhKHBbaV0gaW4geCkpe1xuICAgICAgeCA9IHhbcFtpXV0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHhbcFtpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufTtcblxudXRpbC5lcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICBjb25zb2xlLmVycm9yKCdbVkwgRXJyb3JdJywgbXNnKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcblxudmFyIHZsID0ge307XG5cbnV0aWwuZXh0ZW5kKHZsLCBjb25zdHMsIHV0aWwpO1xuXG52bC5FbmNvZGluZyA9IHJlcXVpcmUoJy4vRW5jb2RpbmcnKTtcbnZsLmNvbXBpbGVyID0gcmVxdWlyZSgnLi9jb21waWxlci9jb21waWxlcicpO1xudmwuY29tcGlsZSA9IHZsLmNvbXBpbGVyLmNvbXBpbGU7XG52bC5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG52bC5lbmMgPSByZXF1aXJlKCcuL2VuYycpO1xudmwuZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyk7XG52bC5zY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcbnZsLnRvU2hvcnRoYW5kID0gdmwuRW5jb2Rpbmcuc2hvcnRoYW5kO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZsOyJdfQ==\n","// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n","module.exports = require('./colorbrewer.js');\n","if (typeof Map === \"undefined\") {\n  Map = function() {};\n  Map.prototype = {\n    set: function(k, v) { this[\"$\" + k] = v; return this; },\n    get: function(k) { return this[\"$\" + k]; },\n    has: function(k) { return \"$\" + k in this; }\n  };\n}\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function Color() {}\n\n  Color.prototype = {\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  var named = (new Map)\n      .set(\"aliceblue\", 0xf0f8ff)\n      .set(\"antiquewhite\", 0xfaebd7)\n      .set(\"aqua\", 0x00ffff)\n      .set(\"aquamarine\", 0x7fffd4)\n      .set(\"azure\", 0xf0ffff)\n      .set(\"beige\", 0xf5f5dc)\n      .set(\"bisque\", 0xffe4c4)\n      .set(\"black\", 0x000000)\n      .set(\"blanchedalmond\", 0xffebcd)\n      .set(\"blue\", 0x0000ff)\n      .set(\"blueviolet\", 0x8a2be2)\n      .set(\"brown\", 0xa52a2a)\n      .set(\"burlywood\", 0xdeb887)\n      .set(\"cadetblue\", 0x5f9ea0)\n      .set(\"chartreuse\", 0x7fff00)\n      .set(\"chocolate\", 0xd2691e)\n      .set(\"coral\", 0xff7f50)\n      .set(\"cornflowerblue\", 0x6495ed)\n      .set(\"cornsilk\", 0xfff8dc)\n      .set(\"crimson\", 0xdc143c)\n      .set(\"cyan\", 0x00ffff)\n      .set(\"darkblue\", 0x00008b)\n      .set(\"darkcyan\", 0x008b8b)\n      .set(\"darkgoldenrod\", 0xb8860b)\n      .set(\"darkgray\", 0xa9a9a9)\n      .set(\"darkgreen\", 0x006400)\n      .set(\"darkgrey\", 0xa9a9a9)\n      .set(\"darkkhaki\", 0xbdb76b)\n      .set(\"darkmagenta\", 0x8b008b)\n      .set(\"darkolivegreen\", 0x556b2f)\n      .set(\"darkorange\", 0xff8c00)\n      .set(\"darkorchid\", 0x9932cc)\n      .set(\"darkred\", 0x8b0000)\n      .set(\"darksalmon\", 0xe9967a)\n      .set(\"darkseagreen\", 0x8fbc8f)\n      .set(\"darkslateblue\", 0x483d8b)\n      .set(\"darkslategray\", 0x2f4f4f)\n      .set(\"darkslategrey\", 0x2f4f4f)\n      .set(\"darkturquoise\", 0x00ced1)\n      .set(\"darkviolet\", 0x9400d3)\n      .set(\"deeppink\", 0xff1493)\n      .set(\"deepskyblue\", 0x00bfff)\n      .set(\"dimgray\", 0x696969)\n      .set(\"dimgrey\", 0x696969)\n      .set(\"dodgerblue\", 0x1e90ff)\n      .set(\"firebrick\", 0xb22222)\n      .set(\"floralwhite\", 0xfffaf0)\n      .set(\"forestgreen\", 0x228b22)\n      .set(\"fuchsia\", 0xff00ff)\n      .set(\"gainsboro\", 0xdcdcdc)\n      .set(\"ghostwhite\", 0xf8f8ff)\n      .set(\"gold\", 0xffd700)\n      .set(\"goldenrod\", 0xdaa520)\n      .set(\"gray\", 0x808080)\n      .set(\"green\", 0x008000)\n      .set(\"greenyellow\", 0xadff2f)\n      .set(\"grey\", 0x808080)\n      .set(\"honeydew\", 0xf0fff0)\n      .set(\"hotpink\", 0xff69b4)\n      .set(\"indianred\", 0xcd5c5c)\n      .set(\"indigo\", 0x4b0082)\n      .set(\"ivory\", 0xfffff0)\n      .set(\"khaki\", 0xf0e68c)\n      .set(\"lavender\", 0xe6e6fa)\n      .set(\"lavenderblush\", 0xfff0f5)\n      .set(\"lawngreen\", 0x7cfc00)\n      .set(\"lemonchiffon\", 0xfffacd)\n      .set(\"lightblue\", 0xadd8e6)\n      .set(\"lightcoral\", 0xf08080)\n      .set(\"lightcyan\", 0xe0ffff)\n      .set(\"lightgoldenrodyellow\", 0xfafad2)\n      .set(\"lightgray\", 0xd3d3d3)\n      .set(\"lightgreen\", 0x90ee90)\n      .set(\"lightgrey\", 0xd3d3d3)\n      .set(\"lightpink\", 0xffb6c1)\n      .set(\"lightsalmon\", 0xffa07a)\n      .set(\"lightseagreen\", 0x20b2aa)\n      .set(\"lightskyblue\", 0x87cefa)\n      .set(\"lightslategray\", 0x778899)\n      .set(\"lightslategrey\", 0x778899)\n      .set(\"lightsteelblue\", 0xb0c4de)\n      .set(\"lightyellow\", 0xffffe0)\n      .set(\"lime\", 0x00ff00)\n      .set(\"limegreen\", 0x32cd32)\n      .set(\"linen\", 0xfaf0e6)\n      .set(\"magenta\", 0xff00ff)\n      .set(\"maroon\", 0x800000)\n      .set(\"mediumaquamarine\", 0x66cdaa)\n      .set(\"mediumblue\", 0x0000cd)\n      .set(\"mediumorchid\", 0xba55d3)\n      .set(\"mediumpurple\", 0x9370db)\n      .set(\"mediumseagreen\", 0x3cb371)\n      .set(\"mediumslateblue\", 0x7b68ee)\n      .set(\"mediumspringgreen\", 0x00fa9a)\n      .set(\"mediumturquoise\", 0x48d1cc)\n      .set(\"mediumvioletred\", 0xc71585)\n      .set(\"midnightblue\", 0x191970)\n      .set(\"mintcream\", 0xf5fffa)\n      .set(\"mistyrose\", 0xffe4e1)\n      .set(\"moccasin\", 0xffe4b5)\n      .set(\"navajowhite\", 0xffdead)\n      .set(\"navy\", 0x000080)\n      .set(\"oldlace\", 0xfdf5e6)\n      .set(\"olive\", 0x808000)\n      .set(\"olivedrab\", 0x6b8e23)\n      .set(\"orange\", 0xffa500)\n      .set(\"orangered\", 0xff4500)\n      .set(\"orchid\", 0xda70d6)\n      .set(\"palegoldenrod\", 0xeee8aa)\n      .set(\"palegreen\", 0x98fb98)\n      .set(\"paleturquoise\", 0xafeeee)\n      .set(\"palevioletred\", 0xdb7093)\n      .set(\"papayawhip\", 0xffefd5)\n      .set(\"peachpuff\", 0xffdab9)\n      .set(\"peru\", 0xcd853f)\n      .set(\"pink\", 0xffc0cb)\n      .set(\"plum\", 0xdda0dd)\n      .set(\"powderblue\", 0xb0e0e6)\n      .set(\"purple\", 0x800080)\n      .set(\"rebeccapurple\", 0x663399)\n      .set(\"red\", 0xff0000)\n      .set(\"rosybrown\", 0xbc8f8f)\n      .set(\"royalblue\", 0x4169e1)\n      .set(\"saddlebrown\", 0x8b4513)\n      .set(\"salmon\", 0xfa8072)\n      .set(\"sandybrown\", 0xf4a460)\n      .set(\"seagreen\", 0x2e8b57)\n      .set(\"seashell\", 0xfff5ee)\n      .set(\"sienna\", 0xa0522d)\n      .set(\"silver\", 0xc0c0c0)\n      .set(\"skyblue\", 0x87ceeb)\n      .set(\"slateblue\", 0x6a5acd)\n      .set(\"slategray\", 0x708090)\n      .set(\"slategrey\", 0x708090)\n      .set(\"snow\", 0xfffafa)\n      .set(\"springgreen\", 0x00ff7f)\n      .set(\"steelblue\", 0x4682b4)\n      .set(\"tan\", 0xd2b48c)\n      .set(\"teal\", 0x008080)\n      .set(\"thistle\", 0xd8bfd8)\n      .set(\"tomato\", 0xff6347)\n      .set(\"turquoise\", 0x40e0d0)\n      .set(\"violet\", 0xee82ee)\n      .set(\"wheat\", 0xf5deb3)\n      .set(\"white\", 0xffffff)\n      .set(\"whitesmoke\", 0xf5f5f5)\n      .set(\"yellow\", 0xffff00)\n      .set(\"yellowgreen\", 0x9acd32);\n\n  function Rgb(r, g, b) {\n    this.r = Math.max(0, Math.min(255, Math.round(r)));\n    this.g = Math.max(0, Math.min(255, Math.round(g)));\n    this.b = Math.max(0, Math.min(255, Math.round(b)));\n  }\n\n  var _prototype = Rgb.prototype = new Color;\n\n  var darker = .7;\n\n  _prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  var brighter = 1 / darker;\n\n  _prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.rgb = function() {\n    return this;\n  };\n\n  function format(r, g, b) {\n    if (isNaN(r)) r = 0;\n    if (isNaN(g)) g = 0;\n    if (isNaN(b)) b = 0;\n    return \"#\"\n        + (r < 16 ? \"0\" + r.toString(16) : r.toString(16))\n        + (g < 16 ? \"0\" + g.toString(16) : g.toString(16))\n        + (b < 16 ? \"0\" + b.toString(16) : b.toString(16));\n  }\n\n  _prototype.toString = function() {\n    return format(this.r, this.g, this.b);\n  };\n\n  var rgb = function(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }\n\n  function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = Math.max(0, Math.min(1, +s));\n    this.l = Math.max(0, Math.min(1, +l));\n  }\n\n  var __prototype = Hsl.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };/* From FvD 13.37, CSS Color Module Level 3 */\n\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  __prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l <= .5 ? l * (1 + s) : l + s - l * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  var hsl = function(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }\n\n  var reHex3 = /^#([0-9a-f]{3})$/,\n      reHex6 = /^#([0-9a-f]{6})$/,\n      reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/,\n      reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/,\n      reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\n  var color = function(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.has(format) ? rgbn(named.get(format))\n        : null;\n  }// Done lazily to avoid circular dependency between Color, Rgb and Hsl.\n\n  color.prototype = Color.prototype;\n  rgb.prototype = Rgb.prototype;\n  hsl.prototype = Hsl.prototype;\n\n  function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }\n\n  var ___prototype = Lab.prototype = new Color;\n\n  var Kn = 18;\n\n  ___prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  var Xn = 0.950470, // D65 standard referent\n      Yn = 1,\n      Zn = 1.088830,\n      t0 = 4 / 29,\n      t1 = 6 / 29,\n      t2 = 3 * t1 * t1,\n      t3 = t1 * t1 * t1;\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  ___prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n\n  function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }\n\n  var ____prototype = Hcl.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var lab = function(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }\n  lab.prototype = Lab.prototype;\n  var rad2deg = 180 / Math.PI;\n\n  var hcl = function(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }\n  hcl.prototype = Hcl.prototype;\n\n  function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  var gamma = 1, // Default gamma. TODO Customize.\n      A = -0.14861,\n      B = +1.78277,\n      C = -0.29227,\n      D = -0.90649,\n      E = +1.97294,\n      ED = E * D,\n      EB = E * B,\n      BC_DA = B * C - D * A;\n\n  var cubehelix = function(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D, lgamma = Math.pow(l, gamma);\n        s = Math.sqrt(k * k + bl * bl) / (E * lgamma * (1 - lgamma)); // NaN if lgamma=0 or lgamma=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = Math.pow(this.l, gamma),\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n  cubehelix.prototype = Cubehelix.prototype;\n\n  var interpolateCubehelixLong = function(a, b) {\n    a = cubehelix(a);\n    b = cubehelix(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n  var deltaHue = function(h, h0) {\n    var delta = (h - h0) % 360;\n    return delta + (delta > 180 ? -360 : delta < -180 ? 360 : 0);\n  }\n\n  var interpolateCubehelix = function(a, b) {\n    a = cubehelix(a);\n    b = cubehelix(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHclLong = function(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHcl = function(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateLab = function(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHslLong = function(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateHsl = function(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  var interpolateRgb = function(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelix = interpolateCubehelix;\n  exports.interpolateCubehelixLong = interpolateCubehelixLong;\n\n}));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function identity(x) {\n    return x;\n  }\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  function localeFormat(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer “value” part that can be\n          // grouped, and fractional or exponential “suffix” part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  var locale = localeFormat({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  exports.format = locale.format;\n  exports.formatPrefix = locale.formatPrefix;\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  exports.formatSpecifier = formatSpecifier;\n  exports.localeFormat = localeFormat;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  var percentRe = /^%/;\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  var numberRe = /^\\s*\\d+/;\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, offset) {\n    date.setUTCFullYear(date.getUTCFullYear() + offset);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setUTCDate(date.getUTCDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcMonday = utcWeekday(1);\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  var utcSunday = utcWeekday(0);\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setUTCDate(date.getUTCDate() + offset);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setDate(date.getDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var monday = weekday(1);\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  var sunday = weekday(0);\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function localeFormat(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var locale = localeFormat({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  exports.format = locale.format;\n  exports.utcFormat = locale.utcFormat;\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : locale.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  exports.isoFormat = isoFormat;\n  exports.localeFormat = localeFormat;\n\n}));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n","var buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return name ? this._data[name] : this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|'+ field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!dataTable.transform) dataTable.transform = [];\n    dataTable.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name===COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name===X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  if (!dataTable.transform) dataTable.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      dataTable.transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n\n  return dataTable;\n}\n","'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  filter = compiler.filter = require('./filter'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.aggregate = require('./aggregate');\ncompiler.bin = require('./bin');\ncompiler.facet = require('./facet');\ncompiler.group = require('./group');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.template = require('./template');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compiler.layout(encoding, stats),\n    spec = compiler.template(encoding, layout, stats);\n\n  // .data related stuff\n  var rawTable = spec.data[0],\n    dataTable = spec.data[1];\n\n  rawTable = filter.addFilters(rawTable, encoding); // modify rawTable\n  spec = compiler.time(spec, encoding);              // modify rawTable, add scales\n  dataTable = compiler.bin(dataTable, encoding);     // modify dataTable\n  var aggResult = compiler.aggregate(dataTable, encoding); // modify dataTable\n  var sorting = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style, stats),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compiler.stack(spec.data, encoding, mdef, aggResult.facets); // modify spec.data, mdef.{from,properties}\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, stats, style, sorting, {stack: stack});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(dataTable, encoding);\n\n  return spec;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    stats,\n    style,\n    sorting,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(rawTable, encoding) {\n  var filters = encoding.filter();  // apply filters to raw data before aggregation\n\n  if (!rawTable.transform)\n    rawTable.transform = [];\n\n  // add custom filters\n  for (var i=0, l=filters.length; i<l; i++) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    rawTable.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n\n  return rawTable;\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.fieldRef(encType) + '>0'\n      });\n    }\n  });\n};\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props,\n    timeUnit = encoding.field(name).timeUnit;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ timeUnit;\n  }\n\n  return def;\n};\n","'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style, stats) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.text.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(name)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n","'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolateLab = require('d3-color').interpolateLab,\n  schema = require('../schema/schema');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, sorting, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, sorting, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  return {data: sorting.getDataset(name), field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette;\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n      } else {\n        if (cardinality <= 2) {\n          range = [colorbrewer[ordinalPalette][3][0], colorbrewer[ordinalPalette][3][2]];\n        } else {\n          range = ordinalPalette;\n        }\n      }\n    } else { //time or quantitative\n      var palette = colorbrewer[ordinalPalette][9];\n      range = [palette[0], palette[8]];\n      s.zero = false;\n    }\n  }\n  return scale.color.palette(range, cardinality, type);\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range],\n      ps = 5;\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    return scale.color.interpolate(palette[ps][0], palette[ps][ps-1], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n  var interpolator = interpolateLab(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n","'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nmodule.exports = time;\n\nvar LONG_DATE = new Date(2014, 8, 17);\n\nfunction time(spec, encoding) { // FIXME refactor to reduce side effect #276\n  // jshint unused:false\n  var timeFields = {}, timeUnits = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.timeUnit) {\n      timeFields[encoding.fieldRef(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeUnits[field.timeUnit] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[0],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var timeUnit in timeUnits) {\n    var scale = time.scale.def(timeUnit, encoding);\n    if (scale) scales.push(scale);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.timeUnit, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.fieldRef(encType),\n    expr: time.formula(field)\n  });\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n","'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.data ? 'data.' : '') + (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks :{\n          type: 'integer',\n          default: 5,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette'\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: 'BuGn',\n          enum: util.keys(colorbrewer)\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'whether the shape\\'s color should be used as fill color instead of stroke color'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n","'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;"],"sourceRoot":"/source/"}